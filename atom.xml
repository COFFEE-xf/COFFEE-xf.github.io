<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2025-05-10T14:15:44.320Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>谢斐</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>软件设计师 上午题 网络与信息安全基础知识</title>
    <link href="http://example.com/2025/05/09/note37/"/>
    <id>http://example.com/2025/05/09/note37/</id>
    <published>2025-05-09T13:26:04.000Z</published>
    <updated>2025-05-10T14:15:44.320Z</updated>
    
    <content type="html"><![CDATA[<style>.center {  width: auto;  display: table;  margin-left: auto;  margin-right: auto;}</style><h1>软件设计师 上午题 网络与信息安全基础知识</h1><p>  OSI网络分层示意图镇楼：</p><div class="center"><style>.umhbropatoao{}</style><img src="/2025/05/09/note37/note37_pic01.png" class="umhbropatoao"></div><h2 id="一、网络互联硬件">一、网络互联硬件</h2><p>  构建一个实际的网络需要网络的传输介质、网络互连设备作为支持，本节主要介绍构建网络的传输介质和互连设备。</p><h3 id="Ⅰ-网络的互联设备">Ⅰ 网络的互联设备</h3><p>  网络互连的目的是使一个网络的用户能够访问其它网络的资源，而且一般不能直接相连，需要一个互联设备来中转实现。这个中间设备要实现不同网络之间的协议转换功能，根据它们工作的协议层可以按如下方式进行分类：</p><h4 id="1-物理层的互联设备">1. 物理层的互联设备</h4><p>  物理层的互联设备有中继器和集线器：</p><ul><li>中继器：它是在物理层上实现局域网网段互联的，用于扩展局域网网段的长度。由于中继器仅能够放大和整形电信号，不具备协议转换或者路由能力，因此中继器只能连接相同的局域网网段，即两个或多个局域网在物理层上具有完全相同的技术标准。</li><li>集线器：集线器是早期的简单物理层广播设备，用于连接多台计算机或其他网络设备，组成一个共享式局域网（LAN）。集线器也可以看作一个特殊的多路中继器，也具有信号放大功能。</li></ul><h4 id="2-数据链路层的互联设备">2. 数据链路层的互联设备</h4><p>  数据链路层的互联设备有网桥和交换机：</p><ul><li>网桥：网桥的核心功能是根据MAC地址智能转发数据帧，从而减少不必要的网络流量。网桥要分析帧地址字段，以决定是否把收到的帧转发到另一个网络段上，所以网桥能够起到过滤帧的作用。</li><li>交换机：交换机是一个具有简化、低价、高性能和高端口密集特点的交换产品，用于在局域网内高效转发数据帧，它通过MAC地址表​智能识别设备，实现点对点通信​​，显著提升网络性能。</li></ul><h4 id="3-网络层的互联设备">3. 网络层的互联设备</h4><p>  网络层的互联设备主要就是路由器：</p><ul><li>路由器：​​路由器的核心功能是​连接不同网络​，并根据​IP地址​选择最佳路径转发数据包。路由器具有很强的异种网互联能力，互联网络的最低两层协议可以互不相同，通过驱动软件接口到第三层而得到统一。</li></ul><h4 id="4-应用层的互联设备">4. 应用层的互联设备</h4><p>  应用层的互联设备主要就是网关：</p><ul><li>网关：在一个计算机网络中，当连接不同类型且协议差别较大的网络时，则要选用网关设备。网关的功能体现在OSI模型的最高层，它将协议进行转换，将数据重新分组，以便在两个不同类型的网络系统之间进行通信。由于协议转换是一件复杂的事，一般来说，网关只进行一对一转换。</li></ul><hr><div class="center"><style>.hqmdxpmpondf{}</style><img src="/2025/05/09/note37/note37_pic02.png" class="hqmdxpmpondf"></div><p>  <strong>C</strong>，所谓广播域和冲突域的区别在于，前者意味着如果站点发出一个广播信号，所有能接收到这个信号的设备范围称为一个广播域，而后者意味着同一时间内只能有一台设备发送信息。而对于本题而言，路由器起到分割子网的作用，而子网显然是一个广播域，那么分割出的两个子网就是两个广播域；集线器中同时只有一个端口能够使用，整个共享一个冲突域；交换机的各个端口可以并行工作，一共是四个冲突域。综上所述，一共就是2个广播域和5个冲突域。</p><h2 id="二、网络的协议与标准">二、网络的协议与标准</h2><h3 id="Ⅰ-TCP-IP协议族">Ⅰ TCP/IP协议族</h3><p>  TCP/IP作为Internet的核心协议，通过近20多年的发展已日渐成熟，并被广泛应用于局域网和广域网中，目前已成为事实上的国际标准。</p><h4 id="1-TCP-IP分层模型">1. TCP/IP分层模型</h4><p>  TCP/IP是个协议族，它包含了多种协议。ISO/OSI模型、TCP/IP的分层模型及协议的对比如下图所示：</p><div class="center"><style>.zwytfqgyfuyn{}</style><img src="/2025/05/09/note37/note37_pic03.png" class="zwytfqgyfuyn"></div><p>  而其中具体的协议间的依赖关系、以及各个协议依赖的端口如下图所示：</p><div class="center"><style>.zcdvmglondzg{}</style><img src="/2025/05/09/note37/note37_pic05.png" class="zcdvmglondzg"></div><p>  而数据在TCP/IP协议中的传输遵循分层封装与解封装机制，数据从发送方到接收方需经过应用层-&gt;传输层-&gt;网际层-&gt;网络接口层的逐层处理，以下是详细流程：</p><ul><li>发送方：进行数据封装。<ul><li>应用层：当用户在应用程序中发送数据时，数据会首先在应用层被封装。例如，当用户通过浏览器访问页面时，HTTP请求会被封装成应用层数据。</li><li>传输层：随后应用层数据将被传递到传输层，而传输层的主要协议TCP/UDP会在数据前端添加传输层头部信息，生成段（Segment–TCP）或者数据报（Datagram–UDP）。</li><li>网际层：在这一层，网络层协议（如IP）会在数据前添加IP头部信息，将数据段/报封装成数据包（Packet）。</li><li>网络接口层：添加MAC头部，形成帧（Frame）。</li></ul></li><li>接收方：将先前添加的头部逐层剥离以完成解封装操作，将数据逐层上传，最后在应用层将最终数据呈现给用户。</li></ul><div class="center"><style>.igiesphymolg{}</style><img src="/2025/05/09/note37/note37_pic04.png" class="igiesphymolg"></div><h4 id="2-网际层协议——IP">2. 网际层协议——IP</h4><p>  IP所提供的服务一般被认为是无连接的和不可靠的：</p><ul><li>无连接的：所谓无连接传输是一个和面向连接传输相对应的一个概念：<ul><li>无连接：没有确定目标系统在已做好接收数据准备之前就发送数据，如IP。</li><li>面向连接：源系统与目标系统在应用层数据传送之前需要进行三次握手，如TCP。</li></ul></li><li>不可靠的：指目的系统不对成功接收的分组进行确认，IP只是尽可能地使数据传输成功。</li></ul><blockquote><p>由于IP只提供无连接、不可靠的服务，所以把差错检测和流量控制之类的服务授权给了其他的各层协议，这正是TCP/IP能够高效工作的一个重要保证。这样，可以根据传送数据的属性来确定所需的传送服务以及客户应该使用的协议。例如，传送大型文件的FTP会话需要面向连接的、可靠的服务(因为如果稍有损坏，就可能导致整个文件无法使用)。</p></blockquote><h4 id="3-网际层协议——ARP">3. 网际层协议——ARP</h4><p>  ARP协议（Address Resolution Protocol, 地址解析协议）的主要作用是将IP地址转换为物理地址。</p><blockquote><p>网络中的任何设备，主机、路由器和交换机等均有唯一的物理地址，该地址通过网卡给出，每个网卡出厂后都有不同的编号，这意味着用户所购买的网卡有着唯一的物理地址。另一方面，为了屏蔽底层协议及物理地址上的差异，IP协议又使用了IP地址，因此，在数据传输过程中，必须对IP地址与物理地址进行相互转换。</p></blockquote><p>  当主机A需要与主机B通信但未知其MAC地址时，会向局域网<strong>广播</strong>ARP请求包（包含目标IP），只有IP匹配的主机B会<strong>单播</strong>回复ARP响应包（携带自身MAC地址），主机A收到后将该映射存入本地ARP缓存表，后续通信直接查表即可。</p><h4 id="4-传输层协议——TCP">4. 传输层协议——TCP</h4><p>  TCP（Transmission Control Protocol, 传输控制协议）在IP提供的不可靠数据服务的基础上为应用程序提供了一个可靠的、面向连接的、全双工的数据传输服务。<br>TCP具有的特点有：可靠传输、连接管理、差错校验和重传、流量控制（采用可变大小的滑动窗口协议）、拥塞控制和端口寻址。</p><h4 id="5-传输层协议——UDP">5. 传输层协议——UDP</h4><p>  与TCP对应，在传输层中还有一种UDP协议（User Datagram Protocol, 用户数据报协议），这是一种不可靠的、无连接的协议。与TCP相比，UDP提供的错误检测功能要弱得多，因此其特点主要侧重于提高传输的高速率性。而TCP所做不到的功能，例如重新发送丢失或出错的数据、建立或终止连接等，都将由使用UDP进行通信的应用程序负责处理。</p><blockquote><p>TCP虽然提供了一个可靠的数据传输服务，但它是以牺牲通信量来实现的。也就是说，为了完成同样一个任务，TCP需要更多的时间和通信量。这在网络不可靠的时候通过牺牲一些时间换来达到网络的可靠性是可行的，但在网络十分可靠的情况下，则可以采用UDP，通信量的浪费就会很小。</p></blockquote><h4 id="6-电子邮件服务协议">6. 电子邮件服务协议</h4><p>  电子邮箱服务，亦即E-mail服务，整个系统基于的是客户端/服务器模式，由E-mail客户端软件、E-mail服务器和通信协议三部分组成。<br>  E-mail服务器主要采用SMTP协议（简单邮件传输协议），这个协议描述了电子邮件的信息格式以及其传递处理方法，这是一种面向文本的网络协议。<br>  但使用SMTP在PC上收信是非常困难的，因此我们常用SMTP来发信而用POP3保管用户未能及时取走的邮件。POP3协议是POP协议（Psot Office Protocol）的一个版本，目前的POP3协议既能与SMTP共同使用，也可以单独使用来传送和接收电子邮件。此外，POP协议每次传输以整个E-mail为单位，不能提供部分传输。</p><h2 id="三、网络命令">三、网络命令</h2><h3 id="1-Windows命令">1. Windows命令</h3><p>  软考中常见的Windows网络命令有以下几种：</p><ul><li>ipconfig/release: DHCP客户端手工释放IP地址。</li><li>ipconfig/flushdns: 清除本地DNS缓存内容。</li><li>ipconfig/displaydns: 显示本地DNS缓存内容。</li><li>ipconfig/registerdns: DNS客户端手工向服务器进行注册。</li><li>ipconfig: 显示所有网络适配器的IP地址、子网掩码和缺省网关值。</li><li>ipconfig/all: 显示所有网络适配器的完整TCP/IP配置信息，包括<strong>DHCP服务是否已经启动</strong>。</li><li>ipconfig/renew: DHCP客户端手工向服务器刷新请求（重新申请IP地址）。</li></ul><hr><ol><li>2016年上半年第68题：</li></ol><div class="center"><style>.yautprpbmigy{}</style><img src="/2025/05/09/note37/note37_pic07.png" class="yautprpbmigy"></div><p>  <strong>C</strong>，使用ping命令进行网络检测，按照由近及远原则，首先执行的是<code>ping 127.0.0.1</code>，其次是<code>ping 本地IP</code>，再次是<code>ping 默认网关</code>，最后是<code>ping 远程主机</code>。</p><h2 id="四、网络安全">四、网络安全</h2><h3 id="Ⅰ-防火墙技术">Ⅰ 防火墙技术</h3><blockquote><p>防火墙(Firewall)是建立在内外网络边界上的过滤封锁机制，它认为内部网络是安全和可信赖的，而外部网络是不安全和不可信赖的。防火墙的作用是防止不希望的、未经授权地进出被保护的内部网络，通过边界控制强化内部网络的安全策略。防火墙作为网络安全体系的基础和核心控制设施，贯穿于受控网络通信主干线，对通过受控干线的任何通信行为进行安全处理，如控制、审计、报警和反应等，同时也承担着繁重的通信任务。由于其自身处于网络系统中的敏感位置，自身还要面对各种安全威胁，因此，选用一个安全、稳定和可靠的防火墙产品，其重要性不言而喻。</p></blockquote><p>  不难发现，防火墙技术的一个基本理念是<strong>防外不防内</strong>，它会在外部环境和内部环境之间建立一个DMZ非军事区，并按照内网、DMZ、外网的优先顺序进行保护。</p><p>  防火墙技术经历了包过滤、应用代理网关和状态检测技术三个发展阶段，需要我们重点掌握的是前两种技术：</p><h4 id="1-包过滤防火墙">1. 包过滤防火墙</h4><p>  包过滤防火墙​​是最基础的防火墙技术，工作在​​网络层和传输层​​，其中有一个包检查块，能够分析<strong>数据包的​​源/目标IP地址、端口号及协议类型（如TCP/UDP/ICMP）​​等头部信息</strong>，依据预设规则（ACL）决定允许或阻断流量。其​​优点是处理速度快、对性能影响小​​，适合部署在路由器等网络边界设备；但​​缺点是无法检测传输数据的内容（因为这是应用层内容​），因此它对应用和用户是透明的；且​​缺乏状态跟踪能力​​（如无法识别TCP握手异常），现多作为其他高级防火墙的初级过滤模块使用。</p><h4 id="2-应用代理网关防火墙">2. 应用代理网关防火墙</h4><p>​  ​应用代理网关防火墙​​是工作在​​应用层​​的防火墙技术，通过扮演&quot;中间人&quot;角色代理客户端与服务器的通信，​​深度解析HTTP、FTP、SMTP等应用层协议内容​​，实现基于用户身份、文件类型、关键词等细粒度控制。其核心优势在于能​​彻底隔离内外网直接连接​​，有效防御SQL注入（一种以获得数据库权限为目的的攻击）、恶意文件上传等应用层攻击，但代价是​​需要为每种协议开发独立代理模块​​，且​​性能开销较大​​，通常用于需要高安全性的邮件服务器、Web应用等场景。</p>]]></content>
    
    
    <summary type="html">软考中级备考笔记</summary>
    
    
    
    <category term="软考" scheme="http://example.com/categories/%E8%BD%AF%E8%80%83/"/>
    
    <category term="软件设计师" scheme="http://example.com/categories/%E8%BD%AF%E8%80%83/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/"/>
    
    <category term="上午题" scheme="http://example.com/categories/%E8%BD%AF%E8%80%83/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/%E4%B8%8A%E5%8D%88%E9%A2%98/"/>
    
    
    <category term="软考" scheme="http://example.com/tags/%E8%BD%AF%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>软件设计师 上午题 知识点拾遗</title>
    <link href="http://example.com/2025/05/08/note36/"/>
    <id>http://example.com/2025/05/08/note36/</id>
    <published>2025-05-08T14:53:55.000Z</published>
    <updated>2025-05-10T12:31:53.530Z</updated>
    
    <content type="html"><![CDATA[<style>.center {  width: auto;  display: table;  margin-left: auto;  margin-right: auto;}</style><h1>软件设计师 上午题 知识点拾遗</h1><ol><li>2013年上半年第37题：</li></ol><div class="center"><style>.uclvvsmxgpsk{}</style><img src="/2025/05/08/note36/note36_pic01.png" class="uclvvsmxgpsk"></div><ul><li>参数多态：同一段代码可以处理多种数据类型，类型本身作为参数。</li><li>包含多态：通过继承和子类型替换实现多态（子类可替代父类）。</li><li>过载多态：<strong>同一个名字在不同上下文中可代表不同的含义</strong>。</li><li>强制多态：通过隐式或显式类型转换使得操作适用于不同类型。</li></ul><ol start="2"><li>2018年下半年第9题：</li></ol><div class="center"><style>.cdwekdfpzzdp{}</style><img src="/2025/05/08/note36/note36_pic02.png" class="cdwekdfpzzdp"></div><p>  <strong>BB</strong>，消息摘要算法是将任意长度的输入产生固定长度的伪随机输出的算法，MD5算法的摘要长度为128位，SHA1算法的摘要长度为160位。</p><ol start="3"><li>2009下半年第19题：</li></ol><div class="center"><style>.gmtcycgwspeu{}</style><img src="/2025/05/08/note36/note36_pic03.png" class="gmtcycgwspeu"></div><p>  <strong>D</strong>，风险预测从风险发生的可能性大小以及风险发生所产生的后果是否严重两个方面评估风险。</p><ol start="4"><li>2010年下半年第5题：</li></ol><div class="center"><style>.lflovvfeiqpt{}</style><img src="/2025/05/08/note36/note36_pic04.png" class="lflovvfeiqpt"></div><ul><li>程序计数器（PC）：PC中存储的是下一条待执行指令的内存地址，程序员<strong>可通过汇编指令直接修改PC的值</strong>。</li><li>指令寄存器（IR）：IR中临时存储当前正在执行的指令，对程序员透明。</li><li>存储器数据寄存器（MDR）：MDR中临时存储从内存中读取的或准备写入内存的数据，对程序员透明。</li><li>存储器地址寄存器（MAR）：MAR中存储​​当前内存访问的目标地址​，对程序员透明。</li></ul><ol start="5"><li>2010年上半年第9题：</li></ol><div class="center"><style>.wwsmnqyseeta{}</style><img src="/2025/05/08/note36/note36_pic05.png" class="wwsmnqyseeta"></div><p>  “Marco”表明这是<strong>宏病毒</strong>（Marco Virus），宏病毒依赖Office文档（如.doc、.xls）中的宏脚本传播，当用户打开带毒文件时自动执行恶意代码。</p><ol start="6"><li>2021年下半年第7题：</li></ol><div class="center"><style>.dfjevrucsqsl{}</style><img src="/2025/05/08/note36/note36_pic06.png" class="dfjevrucsqsl"></div><p>  我们先来了解题目中提到的几个概念：</p><ul><li>阶符：阶符是一位二进制数，用来表示阶码的正负。如果阶符为0，则阶码为正，若阶符为1，阶码为负。</li><li>阶码：阶码是用补码表示的二进制数，表示浮点数的指数部分。</li><li>数符：数符和阶符类似，是一个二进制数，用来表示尾数的正负，规则不再赘述。</li><li>尾数：尾数是用源码表示的二进制小数，用来表示浮点数的有效数字部分。</li></ul><p>  同时，一个二进制<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span>可以用以下形式表示：</p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>N</mi><mo>=</mo><msup><mn>2</mn><mtext>阶码</mtext></msup><mo>×</mo><mtext>尾数</mtext></mrow><annotation encoding="application/x-tex">N=2^{\text{阶码}}\times \text{尾数}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.9747em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord cjk_fallback mtight">阶码</span></span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord text"><span class="mord cjk_fallback">尾数</span></span></span></span></span></span></p><p>  那么题目中的浮点数即为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mrow><mo>−</mo><mn>15</mn></mrow></msup><mo>×</mo><msup><mn>2</mn><mrow><mo>−</mo><mn>10</mn></mrow></msup></mrow><annotation encoding="application/x-tex">2^{-15}×2^{-10}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">15</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">10</span></span></span></span></span></span></span></span></span></span></span></span>。</p><ol start="7"><li>2009年下半年：</li></ol><div class="center"><style>.qrchrvmrkwyl{}</style><img src="/2025/05/08/note36/note36_pic07.png" class="qrchrvmrkwyl"></div><ul><li>位图特性：占用空间大、缩放有失真、存储每个像素的颜色信息，分辨率越高，文件体积越大。</li><li>矢量图特性：占用空间小、无限缩放无失真、适合几何图形设计（如Logo），但显示需实时计算，速度慢。</li></ul><ol start="8"><li>2014年上半年第49题：</li></ol><div class="center"><style>.xselmeybjzpr{}</style><img src="/2025/05/08/note36/note36_pic08.png" class="xselmeybjzpr"></div><p>  上下文无关文法可定义​​递归和嵌套结构​​，<strong>是描述编程语言语法的标准工具</strong>。</p><ol start="9"><li>2010年下半年：</li></ol><div class="center"><style>.fwkknbfuiyqp{}</style><img src="/2025/05/08/note36/note36_pic09.png" class="fwkknbfuiyqp"></div><ul><li>开闭原则是指一个软件实体应当对扩展开放，对修改关闭。</li><li>里氏代换原则（LSP）是指一个软件实体如果使用的是一个基类的话，那么一定适用于其子类。</li><li>依赖倒转原则（DIP）就是要依赖于抽象，而不依赖于实现，或者说要针对接口编程，不要针对实现编程。</li></ul><ol start="10"><li></li></ol>]]></content>
    
    
    <summary type="html">软考中级备考笔记</summary>
    
    
    
    <category term="软考" scheme="http://example.com/categories/%E8%BD%AF%E8%80%83/"/>
    
    <category term="软件设计师" scheme="http://example.com/categories/%E8%BD%AF%E8%80%83/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/"/>
    
    <category term="上午题" scheme="http://example.com/categories/%E8%BD%AF%E8%80%83/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/%E4%B8%8A%E5%8D%88%E9%A2%98/"/>
    
    
    <category term="软考" scheme="http://example.com/tags/%E8%BD%AF%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>软件设计师 上午题 软件工程</title>
    <link href="http://example.com/2025/05/08/note35/"/>
    <id>http://example.com/2025/05/08/note35/</id>
    <published>2025-05-08T08:19:45.000Z</published>
    <updated>2025-05-10T12:34:04.614Z</updated>
    
    <content type="html"><![CDATA[<style>.center {  width: auto;  display: table;  margin-left: auto;  margin-right: auto;}</style><h1>软件设计师 上午题 软件工程</h1><p>  软件工程​旨在通过工程化方法（如需求分析、设计、开发、测试和维护）高效构建​​高质量、可靠、可维护​​的软件系统。其核心目标是​​解决“软件危机”​​（如成本超支、进度延迟、质量低下等问题），平衡用户需求、技术可行性和商业可持续性。</p><h2 id="一、软件过程">一、软件过程</h2><p>  软件开发中所遵循的路线图被称之为“软件过程”，为了有效管理软件过程，人们开发了以下几种模型：</p><h4 id="1-能力成熟度模型（CMM）">1. 能力成熟度模型（CMM）</h4><p>  一个软件组织在开发软件的过程中，其能力一定是一步步提高的，而CMM就是一个用来描述软件组织进化阶段的模型。它将软件过程改进分为以下五个成熟度级别：</p><ul><li><strong>初始级</strong>：该阶段的软件过程杂乱无章，几乎没有明确定义的步骤，想要完成项目必须依靠英雄式核心人物的作用。</li><li><strong>可重复级</strong>：建立了基本的项目管理过程和实践，有必要的过程准则来重复以前在同类项目中的成功。</li><li><strong>已定义级</strong>：管理和工程两方面的软件过程已经文档化和标准化。所有项目都采用根据实际情况修改后得到的标准软件过程来开发和维护软件。</li><li><strong>已管理级</strong>：制定了软件过程和产品质量的详细度量标准，软件过程的质量都被开发人员所理解和控制。</li><li><strong>优化级</strong>：加强了定量分析，有不断的反馈使得软件过程可以不断持续地改进。</li></ul><h4 id="2-能力成熟度模型集成（CMMI）">2. 能力成熟度模型集成（CMMI）</h4><p>  CMMI是若干个过程模型的综合和改进，能够支持多个工程学科。CMMI提供了两种表示方法：</p><ul><li>阶段式模型：阶段式模型的结构类似于CMM。<ul><li>初始的：过程不可预测且缺乏控制。</li><li>已管理的：过程为项目服务。</li><li>已定义的：过程为组织服务。</li><li>定量管理的：过程已度量和控制。</li><li>优化的：集中于过程改进。</li></ul></li><li>连续式模型：我们将软件过程中的特定领域的标准化实践集合称之为过程域，而连续式模型关注的就是过程域的能力。连续式模型中使用能力等级（CL）来评估过程域的能力：<ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><msub><mi>L</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">CL_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>（未完成的）：未完成<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><msub><mi>L</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">CL_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>中制定的目标即为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><msub><mi>L</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">CL_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><msub><mi>L</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">CL_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>（已执行的）：过程​​能被执行​​（能将可标识的输入转换为可标识的输出），但依赖个人能力，无标准化。</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><msub><mi>L</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">CL_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>（已管理的）：过程​​有计划、有监控​​，能按文档化流程执行。</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><msub><mi>L</mi><mn>3</mn></msub></mrow><annotation encoding="application/x-tex">CL_3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>（已定义的）：过程​​标准化​​，基于组织级最佳实践，并培训团队。</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><msub><mi>L</mi><mn>4</mn></msub></mrow><annotation encoding="application/x-tex">CL_4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>（定量管理的）：过程​通过数据（如需求变更率）优化。</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><msub><mi>L</mi><mn>5</mn></msub></mrow><annotation encoding="application/x-tex">CL_5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>（优化的）：使用<strong>量化手段</strong>​​持续改进过程​​，通过技术创新或流程再造提升效率。</li></ul></li></ul><h2 id="二、软件过程模型">二、软件过程模型</h2><p>  软件过程模型，亦即软件开发模型，它是软件开发全部过程、活动和任务的结构框架。</p><h3 id="Ⅰ-瀑布模型">Ⅰ 瀑布模型</h3><h4 id="1-瀑布模型">1. 瀑布模型</h4><p>  瀑布模型将软件生存周期中的各个活动规定为依照线性顺序连接的若干阶段的模型，各阶段间相互衔接，如同瀑布般逐级下落：</p><div class="center"><style>.nckbwbwqtlax{}</style><img src="/2025/05/08/note35/note35_pic01.png" class="nckbwbwqtlax"></div><p>  显然，瀑布模型很适合软件需求非常明确的模型，或者已经掌握了开发技术的软件。但是在瀑布模型中，客户必须能够完整清晰地表达他们的需求，而且需求或设计中的错误只有到了项目后期才会被发现，容易出现积重难返的现象。此外，瀑布模型也难以适应变化的需求。</p><h4 id="2-V模型">2. V模型</h4><p>  V模型是瀑布模型的一个变体，左侧用来描述开发，右侧用来描述测试，这样就使得测试与开发能够并行设计，能够在项目早期就发现缺陷。</p><div class="center"><style>.squtdpljcoqs{}</style><img src="/2025/05/08/note35/note35_pic02.png" class="squtdpljcoqs"></div><h3 id="Ⅱ-增量模型">Ⅱ 增量模型</h3><p>  增量模型事实上也是瀑布模型的一个变体，它融合了瀑布模型的迭代特征。在增量模型中将总体需求分段为一系列增量产品，每个增量包含一个完整的功能子集。</p><div class="center"><style>.xpycqtjvpwla{}</style><img src="/2025/05/08/note35/note35_pic03.png" class="xpycqtjvpwla"></div><p>  如图所示，每个增量都可以分别开发并分批发布。一般来说会将软件最核心的功能包含进第一个增量当中，这样一来用户就能在整个系统开发完毕之前抢先进行使用，并给出反馈以便下一个增量发布新特征和新功能。<br>  增量模型的困难在于需要比较长远的项目规划，否则前期开发的增量有可能造成后来增量的不稳定或者产生重新开发的成本。</p><h3 id="Ⅲ-演化模型">Ⅲ 演化模型</h3><p>  演化模型​​是一种​​渐进式、迭代式​​的软件开发方法，通过​​不断反馈和优化​​逐步完善系统，最终交付符合用户需求的完整产品。其核心思想是：​​“先构建核心功能，再逐步扩展和优化”​​，适用于需求不明确或可能频繁变化的项目。</p><p>  典型的演化模型有原型模型和螺旋模型等：</p><h4 id="1-原型模型">1. 原型模型</h4><p>​  ​原型模型​​是一种通过快速构建原型（预期系统的一个可执行版本）来验证需求和设计的开发方法，其核心是​​“先试错，再开发”​​。开发团队利用工具快速制作可交互原型，由用户试用并反馈，经过多次迭代优化后，最终确定需求或直接基于稳定原型开发完整系统。</p><div class="center"><style>.tfomebphcqsj{}</style><img src="/2025/05/08/note35/note35_pic04.png" class="tfomebphcqsj"></div><h4 id="2-螺旋模型">2. 螺旋模型</h4><p>  对于复杂的大型软件，开发一个原型往往达不到要求，那么人们就开发出了一种将瀑布模型和演化模型结合起来的模型，即螺旋模型。</p><div class="center"><style>.mydthkxdirew{}</style><img src="/2025/05/08/note35/note35_pic07.png" class="mydthkxdirew"></div><p>  和瀑布模型类似，螺旋模型​将开发过程分为多个循环周期，每个周期包含​​需求分析、风险评估、原型开发及用户验证​​四个阶段，通过逐步迭代完善系统。<br>  但是螺旋模型还支持用户需求的动态变化，其核心特点就是​​早期识别并控制风险，适用于复杂度高、不确定性大的项目（如军工、医疗软件）。相比瀑布模型更灵活，相比纯迭代模型更强调系统性风险管理，但成本较高且依赖专业风险评估能力。</p><hr><div class="center"><style>.xtepuayzydio{}</style><img src="/2025/05/08/note35/note35_pic05.png" class="xtepuayzydio"></div><p>  <strong>C</strong>，瀑布模型和V模型都是都是基于明确的开发需求的开发模型，而当用户的需求不明确时就需要用原型模型不断地捕捉需求。</p><hr><div class="center"><style>.bexozlqcqprq{}</style><img src="/2025/05/08/note35/note35_pic06.png" class="bexozlqcqprq"></div><p>  <strong>B</strong>，原型模型仅适用于小规模不复杂的软件，否则其原型开发也将消耗大量成本，并且难以满足需求。</p><hr><div class="center"><style>.ltjhdsivsihk{}</style><img src="/2025/05/08/note35/note35_pic08.png" class="ltjhdsivsihk"></div><p>  <strong>DC</strong>，不再赘述。</p><h3 id="Ⅳ-喷泉模型">Ⅳ 喷泉模型</h3><p>  喷泉模型是一种面向对象的软件开发方法，其核心特点是开发阶段的无缝迭代与回溯，强调各阶段之间的非线性交互和并行推进。与瀑布模型的线性流程不同，喷泉模型的开发活动之间不存在明显的边界，允许开发者在任意阶段根据需求动态调整（如设计时发现分析不足可回溯补充），尤其适合需求易变、需频繁重构的面向对象项目。其优势在于灵活性高、适应性强，但需严格管理文档和版本控制以避免混乱。</p><div class="center"><style>.qlllqpyhwqmh{}</style><img src="/2025/05/08/note35/note35_pic09.png" class="qlllqpyhwqmh"></div><h3 id="Ⅴ-敏捷方法">Ⅴ 敏捷方法</h3><p>  敏捷开发的总体目标是通过“尽可能早地、持续地对有价值的软件的交付”来使客户满意。在软件开发中假如灵活性之后，用户能够在敏捷方法的开发后期增加或改变需求。</p><p>  敏捷方法的典型方法有以下几种：</p><h4 id="1-极限编程（XP）">1. 极限编程（XP）</h4><p>  这一部分的知识点过于琐碎，做题的时候按直觉回答即可。</p><h4 id="2-水晶法">2. 水晶法</h4><p>  水晶法认为每一个不同的项目都需要一套不同的策略。</p><h4 id="3-并列争求法">3. 并列争求法</h4><p>  并列争求法使用迭代的方法，把每30天一次的迭代称为一个“冲刺”，并按需求的优先级别来实现产品。</p><h4 id="4-敏捷统一过程（AUP）">4. 敏捷统一过程（AUP）</h4><p>  AUP采用“在大型上连续”以及“在小型上迭代”的原理来构建软件系统。它采用经典的UP阶段性活动，能够使团队为软件项目构想出一个全面的过程流。</p><h2 id="三、需求分析">三、需求分析</h2><h3 id="Ⅰ-软件需求">Ⅰ 软件需求</h3><p>  软件需求是指用户对于目标软件系统的期望，主要包括以下几个方面：</p><ol><li>功能需求：考虑系统要做什么，在何时做，在何时以及如何修改或升级。</li><li>性能需求：考虑软件开发的技术性指标。</li><li>数据需求：考虑输入、输出数据的格式，接收、发送数据的频率等。</li></ol><hr><div class="center"><style>.lewsueoxmofs{}</style><img src="/2025/05/08/note35/note35_pic10.png" class="lewsueoxmofs"></div><p>  <strong>A</strong>，A为功能需求，BD为性能需求，C为数据需求。</p><h3 id="Ⅱ-系统设计">Ⅱ 系统设计</h3><p>  系统设计阶段的任务就是将软件“做什么”的逻辑模型转换为“怎么做”的物理模型。系统设计的基本任务大体上可以分为概要设计和详细设计两个步骤。</p><h4 id="1-概要设计">1. 概要设计</h4><p>  概要设计的重点是设计软件系统的总体结构：其基本任务是采用某种设计方法，将一个复杂的系统按功能划分为模块，并缕清每个模块的功能、模块之间的调用关系、确定模块之间的接口和评价模块结构的质量。</p><h4 id="2-详细设计">2. 详细设计</h4><ul><li>对每个模块进行详细的算法设计。</li><li>对模块的数据结构进行设计。</li><li>对数据库的物理结构进行设计。</li></ul><h3 id="Ⅲ-系统测试">Ⅲ 系统测试</h3><p>  系统测试是为了以最少的人力和时间发现潜在的各种错误和缺陷。</p><h4 id="1-系统测试的基本原则">1. 系统测试的基本原则</h4><p>  这一部分的知识点过于琐碎，做题的时候按直觉回答即可。</p><h4 id="2-传统软件的测试策略">2. 传统软件的测试策略</h4><p>  有效的软件测试实际上分为4步进行，即单元测试、集成测试、确认测试和系统测试，这里我们重点了解前两步。</p><h5 id="1）单元测试">1）单元测试</h5><p>  单元测试也称为模块测试，一般在模块编写完成之后并且无编译错误后就可以进行。单元测试针对代码中最小的可测试单元（如函数、方法、类）进行隔离测试，验证其功能是否符合预期。</p><p>  单元测试的主要内容为：</p><ul><li>模块接口</li><li>局部数据结构</li><li>重要的执行路径</li><li>出错处理</li><li>边界条件</li></ul><h5 id="2）集成测试">2）集成测试</h5><p>  集成测试就是把模块组合起来进行测试，因为即使所有模块都通过了测试，它们组合在一起使用之后仍然可能出现问题。我们一般采用增量式集成测试，即以小增量的方式逐步进行构造和测试，以下是一些常见的增量集成策略：</p><ul><li><strong>自顶向下测试</strong>：从系统最顶层的模块（如主控模块）开始测试，逐步集成下层模块。未集成的下层模块用​​桩​​模拟。</li><li><strong>自底向上测试</strong>：从系统最底层的模块（如工具类、数据库访问层）开始测试，逐步向上组合。未集成的上层模块用​​驱动（Driver）​​调用下层。</li><li><strong>回归测试</strong>：在每次集成新模块或修改代码后，重新运行已有的测试用例，确保原有功能未被破坏。</li><li><strong>冒烟测试</strong>：在正式测试前，快速验证系统​​基本功能是否可用​​（如“能否启动”、“核心接口是否响应”）。</li></ul><h3 id="Ⅳ-测试方法">Ⅳ 测试方法</h3><h4 id="1-黑盒测试">1. 黑盒测试</h4><p>  黑盒测试也称之为<strong>功能测试</strong>，它将整个软件看作一个看不到细节的黑盒，在完全不考虑软件的内部结构和特性的情况下，仅靠输入和输出来测试系统是否达到预期。</p><p>  常见的黑盒测试技术有：</p><h5 id="1）等价类划分">1）等价类划分</h5><p>  等价类划分法将程序的输入域划分为若干个等价类，然后从每个等价类中选取一个代表性数据作为测试用例，测试用例即等价于所在类的其他值，以实现用较少测试用例取得较好的测试效果。</p><h5 id="2）边界值分析">2）边界值分析</h5><p>  边界值分析法是一种用来补充等价类划分法的测试用例设计技术。其出发思想是输入的边界比中间更加容易发生错误，那么就要选择等价类边界的测试用例进行测试。</p><hr><div class="center"><style>.qwvcuojogfld{}</style><img src="/2025/05/08/note35/note35_pic11.png" class="qwvcuojogfld"></div><p>  <strong>C</strong>，基于等价类设计测试用例时，每个测试用例至多覆盖一个无效等价类，而选项C中包含两个无效等价类，故不是一个好的测试用例。</p><h4 id="2-白盒测试">2. 白盒测试</h4><p>  白盒测试也称之为<strong>结构测试</strong>，测试人员需要了解被测系统的​​内部结构、实现细节和代码逻辑​​，通过设计测试用例来验证代码的正确性、覆盖率和执行路径。<br>  白盒测试中最常见的技术是逻辑覆盖，它通过量化“被测代码的执行比例”来评估测试的充分性，主要的逻辑覆盖标准有以下几种：</p><div class="center"><table><thead><tr><th>覆盖标准</th><th>覆盖目标</th><th>严格性</th><th>适用场景</th></tr></thead><tbody><tr><td><strong>语句覆盖</strong></td><td>每条语句至少执行一次</td><td>★☆☆☆☆</td><td>快速检查基础执行</td></tr><tr><td><strong>判定覆盖（分支覆盖）</strong></td><td>每个分支真/假至少执行一次（针对判定结果）</td><td>★★☆☆☆</td><td>一般功能测试</td></tr><tr><td><strong>条件覆盖</strong></td><td>每个子条件真/假至少执行一次 （针对判定条件）</td><td>★★★☆☆</td><td>复杂条件表达式</td></tr><tr><td><strong>判定/条件覆盖</strong></td><td>分支+子条件真/假至少执行一次</td><td>★★★☆☆</td><td>平衡测试成本与效果</td></tr><tr><td><strong>条件组合覆盖</strong></td><td>所有条件组合至少执行一次</td><td>★★★★☆</td><td>高可靠性系统（如航天软件）</td></tr><tr><td><strong>路径覆盖</strong></td><td>所有执行路径至少执行一次</td><td>★★★★★</td><td>关键算法或模块</td></tr></tbody></table></div><h4 id="3-McCabe度量法">3. McCabe度量法</h4><p>  McCabe度量法又称为环路度量，它认为程序的复杂性在于控制的复杂性。单一的顺序程序结构最为简单，循环和选择构成的环路越多，程序就越复杂。</p><div class="center"><style>.qedgeajctovn{}</style><img src="/2025/05/08/note35/note35_pic12.png" class="qedgeajctovn"></div><p>  McCabe度量法的基础是图论，在一个程序图上研究其中的环的个数<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi><mo stretchy="false">(</mo><mi>G</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">V(G)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mopen">(</span><span class="mord mathnormal">G</span><span class="mclose">)</span></span></span></span>：</p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>V</mi><mtext>（</mtext><mi>G</mi><mtext>）</mtext><mo>=</mo><mi>m</mi><mo>−</mo><mi>n</mi><mo>+</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">V\text{（}G\text{）}=m-n+2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mord text"><span class="mord cjk_fallback">（</span></span><span class="mord mathnormal">G</span><span class="mord text"><span class="mord cjk_fallback">）</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span></span></p><p>  其中，图G首先需要是一个强连通图，而m是图G中弧的个数，n是图G中的节点数。</p><h2 id="四、运行和维护知识">四、运行和维护知识</h2><h3 id="Ⅰ-系统维护概述">Ⅰ 系统维护概述</h3><p>  软件维护是在软件已经交付使用之后为了改正错误或者满足新的需求而修改软件的过程，即软件在交付使用后对软件所做的一切改动。</p><h4 id="1-系统可维护性概念">1. 系统可维护性概念</h4><p>  提高可维护性是开发软件系统所有步骤的关键目的，系统能否被很好地维护，可以用系统的可维护性这一指标来衡量。</p><h5 id="1）系统可维护性的评价指标">1）系统可维护性的评价指标</h5><ul><li><strong>可理解性</strong>：指他人理解系统的结构、功能和内部过程的难易程度。</li><li><strong>可测试性</strong>：诊断和测试的容易程度取决于易理解的程度，好的资料文档有利于诊断和测试。此外，在进行系统维护时，应该充分利用在系统测试阶段留下来的测试用例。</li><li><strong>可修改性</strong>：模块的耦合、内聚、作用范围与控制范围的关系等都对可修改性有影响。</li></ul><h5 id="2）-软件文档与维护">2） 软件文档与维护</h5><p>  软件文档是软件产品的一部分，没有文档的软件不能称之为软件产品。软件系统的文档可分为用户文档和系统文档两类，前者描述使用方法而不关心怎样实现，后者描述系统设计、实现和测试等各方面的内容。<br>  此外，可维护性是所有软件都应具有的基本特点，必须在开发阶段保证软件具有可维护的特点。<strong>在软件工程的每一个阶段都应考虑并提高软件的可维护性</strong>，在每个阶段结束前的技术审查和管理复查中应该着重对可维护性进行复审。</p><h4 id="2-系统维护的内容及类型">2. 系统维护的内容及类型</h4><p>  我们主要讨论的是系统维护中的软件维护，即根据需求变化或者硬件环境的变化对应用程序进行部分或全部修改，一般包括以下几个方面：</p><ul><li><strong>正确性维护</strong>：改正在系统开发阶段已经发生而系统测试阶段尚未发现的错误。</li><li><strong>适应性维护</strong>：指使应用软件适应信息技术变化和管理需求变化而进行的修改。</li><li><strong>完善性维护</strong>：主要是针对已有的软件系统增加一些在系统分析和设计阶段中没有的规定的功能。</li><li><strong>预防性维护</strong>：为了适应未来的软硬件环境的变化，主动增加预防性的新功能。</li></ul><hr><div class="center"><style>.uhyipmbhgoum{}</style><img src="/2025/05/08/note35/note35_pic13.png" class="uhyipmbhgoum"></div><p>  <strong>A</strong>，这道题的重点在于“进行…程序设计”，这表明了这是在系统开发阶段就发生了的，属于正确性维护。</p><h2 id="五、软件项目管理">五、软件项目管理</h2><h3 id="Ⅰ-软件项目估算">Ⅰ 软件项目估算</h3><p>  我们重点来了解以下两种成本估算模型：</p><h4 id="1-COCOMO估算模型">1. COCOMO估算模型</h4><p>  COCOMO​的核心思想是通过​​项目规模​​（通常以代码行数KLOC衡量）和​​调整因子​​来量化开发成本。</p><div class="center"><table><thead><tr><th>模型类型</th><th>适用阶段</th><th>输入参数</th><th>特点</th></tr></thead><tbody><tr><td><strong>基本COCOMO</strong></td><td>早期可行性分析</td><td>代码行数（KLOC）、项目类型</td><td>静态单变量模型</td></tr><tr><td><strong>中级COCOMO</strong></td><td>需求分析后</td><td>代码行数 + 15个成本驱动因子</td><td>静态多变量模型</td></tr><tr><td><strong>详细COCOMO</strong></td><td>详细设计阶段</td><td>分模块估算 + 阶段级成本驱动因子</td><td>高精度，但需详细数据</td></tr></tbody></table></div><h4 id="2-COCOMOⅡ模型">2. COCOMOⅡ模型</h4><p>  COCOMO II​是经典COCOMO模型的现代化改进版本，它通过更灵活的规模估算和新增成本驱动因子，提高了成本预测的准确性。它也分为3个阶段性模型：</p><ul><li>应用组装模型：在软件工程的前期阶段使用。基于对象点进行估算。</li><li>早期设计阶段模型：在需求已经稳定并且基本的软件体系结构已经建立时使用。基于功能点进行估算。</li><li>体系结构阶段模型：在软件的构造过程中使用。基于源代码行进行估算。</li></ul><h3 id="Ⅱ-进度管理">Ⅱ 进度管理</h3><h4 id="1-进度安排">1. 进度安排</h4><p>  进度安排的常用图形描述方法有Gantt图（甘特图）和项目计划评审技术图（PERT图）：</p><h5 id="1）Gantt图">1）Gantt图</h5><p>  甘特图是一种以日历为基准描述项目任务的水平条形图。</p><div class="center"><style>.ddoyuzmhljwe{}</style><img src="/2025/05/08/note35/note35_pic15.png" class="ddoyuzmhljwe"></div><p>  甘特图能够清晰地描述每个人物从何时开始到何时结束，以及各个任务之间的并行性。但是显然它不能清晰地反映出各任务之间的依赖关系，因此难以确定整个项目的关键所在，也不能反映计划中哪一部分最有潜力。</p><h5 id="2）PERT图">2）PERT图</h5><p>  PERT图所描绘的图景和图论中的最短路径问题有一些相似之处，但是它所表示的信息更为直观和丰富。例如可以直接从松弛时间全部0的结点中找出关键路径。</p><div class="center"><style>.qccvkbkvbbeq{}</style><img src="/2025/05/08/note35/note35_pic16.png" class="qccvkbkvbbeq"></div><p>  PERT图不仅给出了每个任务的开始时间、结束时间和完成该任务所需的时间，还给出了任务之间的关系，即哪些任务完成后才能开始另外一些任务，以及如期完成整个工程的关键路径。图中的松弛时间则反映了完成某些任务时可以推迟其开始时间或延长其所需完成的时间。但是，PERT 图不能反映任务之间的并行关系。</p><h3 id="Ⅲ-风险管理">Ⅲ 风险管理</h3><p>  这一部分的知识点过于琐碎，答题时直接根据常识回答即可。</p><h2 id="六、软件质量">六、软件质量</h2><h3 id="Ⅰ-软件质量特性">Ⅰ 软件质量特性</h3><p>  讨论软件质量首先要了解软件的质量特性，我们下面来了解一下ISO/IEC 9126软件质量模型：</p><div class="center"><style>.wnzepdelvcnb{}</style><img src="/2025/05/08/note35/note35_pic14.png" class="wnzepdelvcnb"></div><p>  我们重点来关注一下可靠性、可用性和可维护性：</p><ul><li>可靠性：可靠性是指一个系统对于给定的时间间隔内、在给定条件下无失效运作的概率。可以用MTTF/(1+MTTF)来度量，<strong>其中MTTF为平均无故障时间</strong>。</li><li>可用性：可用性是在给定的时间点上，一个系统能够按照规格说明正确运作的概率。可以用MTBF/(1+MTBF)来度量，<strong>其中MTBF为平均失效间隔时间</strong>。</li><li>可维护性：可维护性是在给定的使用条件下，在规定的时间间隔内，使用规定的过程和资源完成维护活动的概率。可以用1/(1+MTTR)来度量，<strong>其中MTTR为平均修复时间</strong>。</li></ul><h3 id="Ⅱ-软件评审">Ⅱ 软件评审</h3><p>  通常，软件的“质量”即为“用户满意程度”，那么为了把控软件的质量就很有必要对软件进行评审：</p><h4 id="1-设计质量的评审内容">1. 设计质量的评审内容</h4><p>  在设计质量评审中，​​评审对象​​是设计阶段输出的各类交付物，目的是确保设计符合需求、标准及最佳实践。具体对象包括但不限于以下内容：</p><ul><li>评审软件的规格说明是否合乎用户的要求。</li><li>评审软件的可靠性，即能否避免输入异常等问题所产生的失效，一旦发生问题应该更够及时恢复或者采取代替手段。</li><li>评审保密措施的实施情况。</li><li>评审软件性能是否达到所规定性能的目标值。</li><li>评审软件是否具有可修改性、可扩充性、可互换性和可移植性。</li><li>评审软件是否具有可测试性。</li><li>评审软件是否具有复用性。</li></ul><h4 id="2-程序质量的评审内容">2. 程序质量的评审内容</h4><p>  程序质量评审的对象是​​代码本身及其相关产出物​​，目的是确保代码的正确性、可维护性、性能及安全性。评审范围涵盖以下几个方面：</p><ul><li>模块结构：<ul><li>控制流结构。</li><li>数据流结构。</li><li>模块结构与功能结构之间的对应关系。</li></ul></li><li>与运行环境的接口：<ul><li>与硬件的接口。</li><li>与用户的接口。</li></ul></li><li>正式的技术评审：正式的技术评审是一种由技术人员实施的程式化会议，其唯一目的是揭露质量问题。</li></ul><h3 id="Ⅲ-软件容错技术">Ⅲ 软件容错技术</h3><p>  容错技术，即对某些无法避开的差错，使其影响减至最小的技术，而实现容错的主要手段是冗余。通常，冗余技术分为4类：</p><ul><li>结构冗余：结构冗余是最常采用的冗余技术，按工作方法可继续细分为以下三种。<ul><li><strong>静态冗余</strong>：通过​​并行部署多个相同组件​​，所有组件同时工作，系统通过表决机制（如多数表决）输出正确结果。</li><li><strong>动态冗余</strong>：采用​​主备模式​​，主组件工作时备用组件待机，故障时通过检测机制切换至备用组件。</li><li><strong>混合冗余</strong>：结合静态与动态冗余的优点，​​部分组件始终运行，其余组件按需激活​​。</li></ul></li><li>信息冗余：通过​​添加额外校验数据​​来检测或纠正信息传输/存储中的错误，属于“数据层”冗余。</li><li>时间冗余：通过​​重复执行或延迟验证​​来消除瞬时错误，属于“时间层”冗余。</li></ul>]]></content>
    
    
    <summary type="html">软考中级备考笔记</summary>
    
    
    
    <category term="软考" scheme="http://example.com/categories/%E8%BD%AF%E8%80%83/"/>
    
    <category term="软件设计师" scheme="http://example.com/categories/%E8%BD%AF%E8%80%83/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/"/>
    
    <category term="上午题" scheme="http://example.com/categories/%E8%BD%AF%E8%80%83/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/%E4%B8%8A%E5%8D%88%E9%A2%98/"/>
    
    
    <category term="软考" scheme="http://example.com/tags/%E8%BD%AF%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>软件设计师 上午题 结构化开发</title>
    <link href="http://example.com/2025/05/08/note34/"/>
    <id>http://example.com/2025/05/08/note34/</id>
    <published>2025-05-08T06:40:25.000Z</published>
    <updated>2025-05-08T08:27:17.522Z</updated>
    
    <content type="html"><![CDATA[<style>.center {  width: auto;  display: table;  margin-left: auto;  margin-right: auto;}</style><h1>软件设计师 上午题 结构化开发</h1><p>结构化开发是一种系统化的软件开发方法，强调通过清晰的步骤、模块化设计和标准化工具来提升软件的可维护性、可靠性和开发效率。其核心思想是将复杂问题分解为更小、更易管理的部分，通常与​​结构化编程​​和​​结构化设计​​密切相关。</p><h2 id="一、系统分析与设计概述">一、系统分析与设计概述</h2><h3 id="Ⅰ-系统设计的基本原理">Ⅰ 系统设计的基本原理</h3><h4 id="1-抽象">1. 抽象</h4><p>抽象，即将一个复杂的现象简化到可以分析、实验或者可以理解的程度。例如在设计用户登录模块时，在较高层次的抽象中只需定义输入（账号/密码）、输出（成功/失败），无需关心密码加密的具体算法。具体的算法可以在较低的抽象层次中细化。</p><h4 id="2-模块化">2. 模块化</h4><p>模块化即将系统分解为功能独立的模块，每个模块完成单一职责。这是一种对复杂问题分而治之的原则。</p><h4 id="3-信息隐蔽">3. 信息隐蔽</h4><p>信息隐蔽意味着将每个程序的成分封装在一个单一的设计模块中，在定义每一个模块时尽可能少地显露其内部的处理。</p><h4 id="4-模块独立">4. 模块独立</h4><p>模块独立是指每个模块完成一个相对独立的特定子功能，并且要求模块之间的联系要尽可能简单。我们可以使用两个指标来衡量模块独立的程度：</p><h5 id="1）耦合">1）耦合</h5><p>耦合定义的是模块间依赖关系的紧密程度。耦合越低，独立性越强。一般来说，模块之间的耦合会有以下几种类型：</p><div class="center"><style>.iccxdefsrrmd{}</style><img src="/2025/05/08/note34/note34_pic01.png" class="iccxdefsrrmd"></div><ul><li><strong>无直接耦合</strong>：两个模块间没有直接的关系。</li><li><strong>数据耦合</strong>：两个模块之间存在值传递。</li><li><strong>标记耦合</strong>：两个模块之间存在数据结构的传递。</li><li><strong>控制耦合</strong>：一个模块调用另一个模块中的某一功能。</li><li><strong>外部耦合</strong>：模块间通过软件之外的环境连接，比如I/O将模块耦合到特定的设备上。</li><li><strong>公共耦合</strong>：多个模块共享全局数据。</li><li><strong>内容耦合</strong>：一个模块直接使用另一个模块的内部数据，或者一个模块通过非正常入口转入另一个模块内部。</li></ul><h5 id="2）内聚">2）内聚</h5><p>内聚着眼于一个模块内部，即一个模块中的各个元素彼此结合的紧密程度。一个高内聚的模块应当只做一件事。模块的内聚一般有以下几种类型：</p><div class="center"><style>.sxvmjijdxkrw{}</style><img src="/2025/05/08/note34/note34_pic02.png" class="sxvmjijdxkrw"></div><ul><li><strong>偶然内聚</strong>：一个模块内的各个元素之间没有任何联系。</li><li><strong>逻辑内聚</strong>：一个模块能够执行若干个逻辑上相似的功能。</li><li><strong>时间内聚</strong>：把需要同时执行的动作组合在一起的模块称作时间内聚模块。</li><li><strong>过程内聚</strong>：一个模块完成多个任务，且这些任务必须按指定的过程执行。</li><li><strong>通信内聚</strong>：模块内的所有元素都在同一个数据结构上操作，这样一来大体的效果就是各处理在使用相同的输入时会产生相同的输出。</li><li><strong>顺序内聚</strong>：一个模块内的各个处理元素都密切相关于完成一个功能且必须顺序执行。</li><li><strong>功能内聚</strong>：一个模块内的所有元素都密切相关于完成一个功能，缺一不可。</li></ul><h3 id="Ⅱ-系统总体结构设计">Ⅱ 系统总体结构设计</h3><h4 id="1-系统结构设计原则">1. 系统结构设计原则</h4><ul><li><strong>分解-协调原则</strong>：解决复杂问题的一个重要原则为将其分解成多个小问题分别处理，在处理过程中根据系统的总体要求协调各部门之间的关系。</li><li><strong>自顶向下的原则</strong>：首先抓住系统总的功能，再逐层分解实现。</li><li><strong>信息隐蔽、抽象的原则</strong>：上层模块只规定下层模块要干什么，而不干涉怎么实现，以保证模块间的独立性和层次性。</li><li><strong>一致性原则</strong>：整个软件设计过程中需要有统一的规范。</li><li><strong>明确性原则</strong>：每个模块必须功能明确、接口明确，消除冗余的功能和接口。</li><li><strong>模块的扇入系数和扇出系数要合理</strong>：一个模块直接调用其它模块的个数称之为扇出系数，反之则称之为扇入系数。扇出系数和扇入系数必须适当。</li><li><strong>模块之间的耦合尽可能小，模块的内聚度尽可能高</strong>。</li><li><strong>模块的规模适当</strong>。</li><li><strong>模块的作用范围应该在其控制范围之内</strong>。</li></ul><h2 id="二、结构化分析方法">二、结构化分析方法</h2><h3 id="Ⅰ-数据流图（DFD）">Ⅰ 数据流图（DFD）</h3><p>数据流图的详细内容请参见：<a href="https://loquattree.xyz/2025/04/23/note28/">软件设计师 下午题 试题一 数据流图设计</a></p><hr><ol><li>2012年上半年：</li></ol><div class="center"><style>.ptsdlqufiosu{}</style><img src="/2025/05/08/note34/note34_pic03.png" class="ptsdlqufiosu"></div><p><strong>B</strong>，在分层数据流图中有顶层数据流图、0层数据流图和底层数据流图三种。它们的功能依次是1）以最简形式描述系统的边界、主要输入/输出流；2）将系统分解为关键的处理过程，如“订单处理”、“支付验证”等；3）进一步细化每个处理过程的内部逻辑。</p><h3 id="Ⅱ-数据字典（DD）">Ⅱ 数据字典（DD）</h3><blockquote><p>数据流图描述了系统的分解，但没有对图中各成分进行说明。数据字典就是为数据流图中的每个数据流、文件、加工，以及组成数据流或文件的数据项做出说明。其中，对加工的描述称为“小说明”，也可以称为“加工逻辑说明”。</p></blockquote><h4 id="1-数据字典的内容">1. 数据字典的内容</h4><p>数据字典中有以下4类条目：</p><ul><li><strong>数据流条目</strong>：通常列出数据流的来源、去向和组成。</li><li><strong>数据存储条目</strong>：定义系统中持久化数据的存储结构（如数据库表、文件）。</li><li><strong>数据项条目</strong>：细化数据流或数据存储中的​​最小数据单元​​，包括类型、长度、约束等。</li><li><strong>基本加工条目</strong>：用来说明DFD中基本加工的处理逻辑。</li></ul><div class="center"><style>.rbljyvnrlzfc{}</style><img src="/2025/05/08/note34/note34_pic04.png" class="rbljyvnrlzfc"></div><h4 id="2-结构化语言">2. 结构化语言</h4><p>结构化语言是一种常见的用来描述加工逻辑的方法，这是一种介于自然语言和形式化语言之间的半形式化语言。结构化语言的结构通常可分为内层和外层：</p><ul><li>外层：用来描述控制结构，有以下几种基本结构：<ul><li>顺序结构：一组祈使语句、选择语句、重复语句的顺序排列。</li><li>选择结构：一般采用IF-ELSE等关键词。</li><li>重复结构：一般采用DO-WHILE-ENDDO等关键词。</li></ul></li><li>内层：了解即可，语法比较灵活，一般是采用祈使语句的自然语言短语。</li></ul>]]></content>
    
    
    <summary type="html">软考中级备考笔记</summary>
    
    
    
    <category term="软考" scheme="http://example.com/categories/%E8%BD%AF%E8%80%83/"/>
    
    <category term="软件设计师" scheme="http://example.com/categories/%E8%BD%AF%E8%80%83/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/"/>
    
    <category term="上午题" scheme="http://example.com/categories/%E8%BD%AF%E8%80%83/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/%E4%B8%8A%E5%8D%88%E9%A2%98/"/>
    
    
    <category term="软考" scheme="http://example.com/tags/%E8%BD%AF%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>访问Apache服务器时出现“403 Forbidden”的解决方案</title>
    <link href="http://example.com/2025/05/07/md07/"/>
    <id>http://example.com/2025/05/07/md07/</id>
    <published>2025-05-07T03:30:43.000Z</published>
    <updated>2025-05-07T03:35:51.459Z</updated>
    
    <content type="html"><![CDATA[<style>.center {  width: auto;  display: table;  margin-left: auto;  margin-right: auto;}</style><h1>访问Apache服务器时出现“403 Forbidden”的解决方案</h1><div class="center"><style>.qvmyjqhyqqjd{}</style><img src="/2025/05/07/md07/md07_pic01.png" class="qvmyjqhyqqjd"></div><p>在配置Apache服务器时，如果修改了默认的根目录就可能出现被拒绝访问的情况，可以执行以下命令解决：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">确保目录可读</span><br>sudo chmod 755 /home/rhauser/public_html<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">确保文件可读</span><br>sudo chmod 644 /home/rhauser/public_html/*<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">确保Apache对父目录也有权限</span><br>sudo chmod +x /home /home/rhauser<br></code></pre></td></tr></table></figure><p>成功解决：</p><div class="center"><style>.dgjbylyyugbg{}</style><img src="/2025/05/07/md07/md07_pic02.png" class="dgjbylyyugbg"></div>]]></content>
    
    
    <summary type="html">该问题一般出现更改了Apache服务器默认地址时</summary>
    
    
    
    <category term="疑难杂症解决方案" scheme="http://example.com/categories/%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    
    
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>VMWare扩容虚拟机时“指定的虚拟磁盘需要进行修复”报错的解决方案</title>
    <link href="http://example.com/2025/05/06/md06/"/>
    <id>http://example.com/2025/05/06/md06/</id>
    <published>2025-05-06T14:26:41.000Z</published>
    <updated>2025-05-06T14:31:06.046Z</updated>
    
    <content type="html"><![CDATA[<style>.center {  width: auto;  display: table;  margin-left: auto;  margin-right: auto;}</style><h1>VMWare扩容虚拟机时“指定的虚拟磁盘需要进行修复”报错的解决方案</h1><p>在Windows命令提示符中依次执行以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd VMWare安装路径<br><br>vmware-vdiskmanager -R &quot;虚拟磁盘路径&quot;<br></code></pre></td></tr></table></figure><p>以我的安装路径为例：</p><div class="center"><style>.zjnzjqvynixh{}</style><img src="/2025/05/06/md06/md06.png" class="zjnzjqvynixh"></div><p>当出现提示<code>The virtual disk, 'E:\VIT1204 Ass1 Lab3\Ass1 Lab3.vmdk', was corrupted and has been successfully repaired.</code>即为修复成功。</p>]]></content>
    
    
    <summary type="html">该问题一般出现为虚拟机扩容时</summary>
    
    
    
    <category term="疑难杂症解决方案" scheme="http://example.com/categories/%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    
    
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>CentOS 7 dnf命令“conflicting requests”报错的解决方案</title>
    <link href="http://example.com/2025/05/06/md05/"/>
    <id>http://example.com/2025/05/06/md05/</id>
    <published>2025-05-06T11:15:17.000Z</published>
    <updated>2025-05-06T15:39:48.930Z</updated>
    
    <content type="html"><![CDATA[<style>.center {  width: auto;  display: table;  margin-left: auto;  margin-right: auto;}</style><h1>CentOS 7 dnf命令“conflicting requests”报错的解决方案</h1><h3 id="Reference">Reference</h3><ul><li><a href="https://blog.csdn.net/SerMa/article/details/131226445">centos7升级glibc2.25避坑指南</a></li><li><a href="https://blog.csdn.net/yutenys/article/details/122154162">centos7升级gcc&amp;glibc(踩坑)</a></li></ul><p>笔者在CentOS 7系统中安装Chrome浏览器时使用到了<code>dnf</code>命令来处理其安装包，但是出现了以下报错：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">错误：<br> 问题: conflicting requests<br>  - nothing provides libc.so.6(GLIBC_2.18)(64bit) needed by google-chrome-stable-136.0.7103.59-1.x86_64<br></code></pre></td></tr></table></figure><p>GLIBC是GNU发布的libc库，即c运行库。GLIBC是linux系统中最底层的api，几乎其它任何运行库都会依赖于GLIBC，而CentOS 7系统中的GLIBC版本为<code>GLIBC_2.17</code>，而报错信息则说明在使用这一命令时需要<code>GLIBC_2.18</code>及以上版本，因此我们需要对GLIBC库进行更新（直接升级到<code>GLIBC_2.31</code>版本）：</p><h3 id="1-基础环境准备">1. 基础环境准备</h3><p>将GLIBC库升级到目标版本需要满足两个基础条件：</p><ul><li>GCC版本为9.X.X及以上</li><li>make版本为4.0.X及以上</li></ul><h4 id="1）make升级">1）make升级</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">检查版本，满足条件可以跳过此步</span><br>make -v<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">----------------------------</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">安装依赖</span><br>yum -y install gcc gcc+<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">建立根目录</span><br>mkdir /backup<br><span class="hljs-meta prompt_"> </span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">下载make安装包</span><br>cd /backup<br>wget https://mirrors.aliyun.com/gnu/make/make-4.3.tar.gz<br><span class="hljs-meta prompt_"> </span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">解压压缩包并建立构建目录</span><br>tar -xf make-4.3.tar.gz<br>cd make-4.3<br>mkdir build<br>cd build<br><span class="hljs-meta prompt_"> </span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">指定安装到具体的目录下，此示例表示将make安装到/opt下</span><br>../configure --prefix=/opt/make<br><span class="hljs-meta prompt_"> </span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">编译安装</span><br>make &amp;&amp; make install<br><span class="hljs-meta prompt_"> </span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">建立软连接</span><br>ln -sf /opt/make/bin/make /usr/bin/make<br><span class="hljs-meta prompt_"> </span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">检查make版本</span><br>make --version<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">----------------------------</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">目标输出</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">GNU Make 4.3</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">为 x86_64-pc-linux-gnu 编译</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Copyright (C) 1988-2020 Free Software Foundation, Inc.</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">许可证：GPLv3+：GNU 通用公共许可证第 3 版或更新版本&lt;http://gnu.org/licenses/gpl.html&gt;。</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">本软件是自由软件：您可以自由修改和重新发布它。</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">在法律允许的范围内没有其他保证。</span><br></code></pre></td></tr></table></figure><h4 id="2）GCC升级">2）GCC升级</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">检查版本，满足条件可以跳过此步</span><br>gcc -v<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">----------------------------</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">安装升级依赖</span><br>yum install -y gcc-c++ glibc-devel mpfr-devel libmpc-devel gmp-devel glibc-devel.i686<br>​<br><span class="hljs-meta prompt_"># </span><span class="language-bash">下载gcc9.3.1安装包</span><br>cd /backup<br>wget https://ftp.gnu.org/gnu/gcc/gcc-9.3.0/gcc-9.3.0.tar.gz --no-check-certificate<br>​<br><span class="hljs-meta prompt_"># </span><span class="language-bash">解包并执行编译前的准备</span><br>tar -xf gcc-9.3.0.tar.gz<br>cd gcc-9.3.0<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">下载依赖包</span><br>./contrib/download_prerequisites<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">建立构建目录</span><br>mkdir build<br>cd build<br>​<br><span class="hljs-meta prompt_"># </span><span class="language-bash">指定安装到具体的目录下，此示例表示将make安装到/usr下</span><br>../configure --enable-checking=release --enable-language=c,c++ --disable-multilib --prefix=/usr<br>​<br><span class="hljs-meta prompt_"># </span><span class="language-bash">编译安装</span><br>make -j4 # -j代表编译时的任务数，一般有几个cpu核心就写几，构建速度会更快一些。该步骤执行时间很长！！！大概需要一个半钟头左右。<br>make install<br>​<br><span class="hljs-meta prompt_"># </span><span class="language-bash">7.安装完成后检查gcc版本</span><br>gcc -v<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">----------------------------</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">目标输出</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">使用内建 specs。</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">COLLECT_GCC=gcc</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">COLLECT_LTO_WRAPPER=/usr/libexec/gcc/x86_64-pc-linux-gnu/9.3.0/lto-wrapper</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">目标：x86_64-pc-linux-gnu</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">配置为：../configure --enable-checking=release --enable-language=c,c++ --disable-multilib --prefix=/usr</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">线程模型：posix</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">gcc 版本 9.3.0 (GCC)</span> <br></code></pre></td></tr></table></figure><h3 id="2-升级GLIBC库">2. 升级GLIBC库</h3><p>执行以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">下载安装包</span><br>cd /opt<br>wget https://mirrors.aliyun.com/gnu/glibc/glibc-2.31.tar.gz<br><br>tar -zxf glibc-2.31.tar.gz<br>cd glibc-2.31/<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">检查是否满足基本需求</span><br>cat INSTALL | grep -E &quot;newer|later&quot;<br><br>mkdir build<br>cd build<br><br>../configure  --prefix=/usr --disable-profile --enable-add-ons --with-headers=/usr/include --with-binutils=/usr/bin --disable-sanity-checks --disable-werror<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">一定要有这一步，python2安装会报错</span><br>yum install python3 <br><br>make -j8 # 使用8核编译后速度显著快于-j4<br>make install<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">解决新启动远程终端时报一个WARNING</span><br>make localedata/install-locales<br></code></pre></td></tr></table></figure><p>如果再升级后仍出现和原先相同的报错，使用强制安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo rpm -ivh --nodeps /tmp/chrome.rpm<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">该问题一般出现使用Linux dnf命令时</summary>
    
    
    
    <category term="疑难杂症解决方案" scheme="http://example.com/categories/%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    
    
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>CentOS 7 yum命令“There are no enabled repos”报错的解决方案</title>
    <link href="http://example.com/2025/05/06/md04/"/>
    <id>http://example.com/2025/05/06/md04/</id>
    <published>2025-05-06T07:31:10.000Z</published>
    <updated>2025-05-06T11:46:24.952Z</updated>
    
    <content type="html"><![CDATA[<style>.center {  width: auto;  display: table;  margin-left: auto;  margin-right: auto;}</style><h1>CentOS 7 yum命令“There are no enabled repos”报错的解决方案</h1><p>当在Linux CentOS当中使用<code>yum</code>命令并出现以下报错时：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">error:There are no enabled repositories in &quot;/etc/yum.repos.d&quot;, &quot;/etc/yum/repos.d&quot;<br></code></pre></td></tr></table></figure><p>并且使用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo yum grouplist<br></code></pre></td></tr></table></figure><p>后出现报错为</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">http://mirrors.cloud.aliyuncs.com/centos/7/os/x86_64/repodata/repomd.xml: [Errno 14] HTTP Error 404 - Not Found<br>Trying other mirror.<br></code></pre></td></tr></table></figure><p>这种情况一般就是YUM仓库（repository）的配置问题，导致无法正常解析，需要对YUM仓库进行换源。</p><h3 id="1-备份原yum源">1. 备份原yum源</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup<br></code></pre></td></tr></table></figure><h3 id="2-下载新的yum源">2. 下载新的yum源</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo wget -O /etc/yum.repos.d/CentOS-Base.repo https://mirrors.aliyun.com/repo/Centos-7.repo<br></code></pre></td></tr></table></figure><h3 id="3-更新配置">3. 更新配置</h3><p>随后运行以下命令更新配置即可：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">yum clear all<br>yum makecache<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">该问题一般出现使用Linux yum命令时</summary>
    
    
    
    <category term="疑难杂症解决方案" scheme="http://example.com/categories/%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    
    
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>VMWare “Capacity mismatch for disk XXX。”报错的解决方案</title>
    <link href="http://example.com/2025/05/05/md03/"/>
    <id>http://example.com/2025/05/05/md03/</id>
    <published>2025-05-05T12:17:42.000Z</published>
    <updated>2025-05-06T11:46:35.824Z</updated>
    
    <content type="html"><![CDATA[<style>.center {  width: auto;  display: table;  margin-left: auto;  margin-right: auto;}</style><h1>VMWare “Capacity mismatch for disk XXX。”报错的解决方案</h1><p>笔者在使用<em>VMware Workstation Pro</em>虚拟机环境完成<a href="https://loquattree.xyz/2025/05/05/php02/">课内大作业</a>的过程中需要导入一个老师提供的.ova文件，但是在导入时出现了以下报错：</p><div class="center"><style>.rfpjyvdwqlsh{}</style><img src="/2025/05/05/md03/md03_pic01.png" class="rfpjyvdwqlsh"></div><p>以下是解决方案：</p><h3 id="一、解压-ova文件">一、解压.ova文件</h3><p>​​.ova文件​​（Open Virtual Appliance）是一种​​虚拟设备打包格式，因此它实际上是一个压缩包文件，其中包含了以下内容：</p><ul><li>.ovf文件​​（Open Virtualization Format）：描述虚拟机的硬件配置（CPU、内存、网络等）、磁盘信息和其他元数据（XML格式）。</li><li>vmdk/.vhd等磁盘镜像​​：存储虚拟机的操作系统和数据（格式取决于虚拟化平台，如VMware用VMDK，Hyper-V用VHD）。</li><li>​​.mf文件​​（Manifest File）：是虚拟设备中的​​清单文件​​，用于验证文件完整性和确保虚拟机的安全导入。</li></ul><p>但是常见的解压缩工具都无法直接解压.ova文件，因此需要先手动将其后缀改为.zip格式再解压缩即可。解压结果如下图所示：</p><div class="center"><style>.oiuapssgsdke{}</style><img src="/2025/05/05/md03/md03_pic02.png" class="oiuapssgsdke"></div><h3 id="二、配置-ovf文件">二、配置.ovf文件</h3><p>笔者搜索到的绝大部分解决方案都是将.ovf文件中的虚拟机软件的版本号修改为当前自己使用到的版本号即可，如下图所示：</p><div class="center"><style>.neyddcdaixsi{}</style><img src="/2025/05/05/md03/md03_pic03.png" class="neyddcdaixsi"></div><p>可以一试，可能对低版本的VMware Workstation Pro是起效的，但是笔者使用的版本在修改后依旧会报错，因此需要更彻底的更改：</p><h4 id="1-删除“-Disk-ovf-capacity-“18103500800”-ovf-diskId-“vmdisk2”-ovf-fileRef-“file1”-ovf-format-“http-www-vmware-com-interfaces-specifications-vmdk-html-streamOptimized”-vbox-uuid-“bf38c60b-49bd-48c9-9c03-55acfcec0141”-”">1. 删除“&lt;Disk ovf:capacity=“18103500800” ovf:diskId=“vmdisk2” ovf:fileRef=“file1” ovf:format=“<a href="http://www.vmware.com/interfaces/specifications/vmdk.html#streamOptimized">http://www.vmware.com/interfaces/specifications/vmdk.html#streamOptimized</a>” vbox:uuid=“bf38c60b-49bd-48c9-9c03-55acfcec0141”/&gt;”</h4><p>在.ovf文件的最开始，内容可能不太一致，删除即可。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">DiskSection</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">Info</span>&gt;</span>List of the virtual disks used in the package<span class="hljs-tag">&lt;/<span class="hljs-name">Info</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">Disk</span> <span class="hljs-attr">ovf:capacity</span>=<span class="hljs-string">&quot;18103500800&quot;</span> <span class="hljs-attr">ovf:diskId</span>=<span class="hljs-string">&quot;vmdisk2&quot;</span> <span class="hljs-attr">ovf:fileRef</span>=<span class="hljs-string">&quot;file1&quot;</span> <span class="hljs-attr">ovf:format</span>=<span class="hljs-string">&quot;http://www.vmware.com/interfaces/specifications/vmdk.html#streamOptimized&quot;</span> <span class="hljs-attr">vbox:uuid</span>=<span class="hljs-string">&quot;bf38c60b-49bd-48c9-9c03-55acfcec0141&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">DiskSection</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="2-删除“-Image-uuid-“-bf38c60b-49bd-48c9-9c03-55acfcec0141-”-”">2. 删除“&lt;Image uuid=“{bf38c60b-49bd-48c9-9c03-55acfcec0141}”/&gt;”</h4><p>在.ovf文件的最末尾：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">AttachedDevice</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;HardDisk&quot;</span> <span class="hljs-attr">hotpluggable</span>=<span class="hljs-string">&quot;false&quot;</span> <span class="hljs-attr">port</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">device</span>=<span class="hljs-string">&quot;0&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">Image</span> <span class="hljs-attr">uuid</span>=<span class="hljs-string">&quot;&#123;bf38c60b-49bd-48c9-9c03-55acfcec0141&#125;&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">AttachedDevice</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="3-继续删除">3. 继续删除</h4><p>在文章中间部分，可搜索<code>/disk/vmdisk</code>找到，全部删除：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">Item</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">rasd:AddressOnParent</span>&gt;</span>0<span class="hljs-tag">&lt;/<span class="hljs-name">rasd:AddressOnParent</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">rasd:Caption</span>&gt;</span>disk2<span class="hljs-tag">&lt;/<span class="hljs-name">rasd:Caption</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">rasd:Description</span>&gt;</span>Disk Image<span class="hljs-tag">&lt;/<span class="hljs-name">rasd:Description</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">rasd:ElementName</span>&gt;</span>disk2<span class="hljs-tag">&lt;/<span class="hljs-name">rasd:ElementName</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">rasd:HostResource</span>&gt;</span>/disk/vmdisk2<span class="hljs-tag">&lt;/<span class="hljs-name">rasd:HostResource</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">rasd:InstanceID</span>&gt;</span>9<span class="hljs-tag">&lt;/<span class="hljs-name">rasd:InstanceID</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">rasd:Parent</span>&gt;</span>5<span class="hljs-tag">&lt;/<span class="hljs-name">rasd:Parent</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">rasd:ResourceType</span>&gt;</span>17<span class="hljs-tag">&lt;/<span class="hljs-name">rasd:ResourceType</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">Item</span>&gt;</span><br></code></pre></td></tr></table></figure><p>保存退出即可。</p><h3 id="三、配置-mf文件">三、配置.mf文件</h3><p>随便找一个文件Hash值的在线计算网站，计算出更改后的.ovf文件的SHA1值，并对应地将.mf文件中的值修改即可，不然无法导入.ovf文件：</p><div class="center"><style>.xbcfdnfstnyk{}</style><img src="/2025/05/05/md03/md03_pic04.png" class="xbcfdnfstnyk"></div><h3 id="四、导入-ovf文件">四、导入.ovf文件</h3><p>全部完成之后使用VMware Workstation Pro打开修改过后的.ovf文件即可：</p><div class="center"><style>.wdtybpmkyvdv{}</style><img src="/2025/05/05/md03/md03_pic05.png" class="wdtybpmkyvdv"></div><h2 id="Bingo！">Bingo！</h2>]]></content>
    
    
    <summary type="html">该问题一般出现在ova文件导入环节</summary>
    
    
    
    <category term="疑难杂症解决方案" scheme="http://example.com/categories/%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    
    
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>使用Linux部署Apache服务器</title>
    <link href="http://example.com/2025/05/05/php02/"/>
    <id>http://example.com/2025/05/05/php02/</id>
    <published>2025-05-05T09:27:00.000Z</published>
    <updated>2025-05-08T07:40:58.601Z</updated>
    
    <content type="html"><![CDATA[<style>.center {  width: auto;  display: table;  margin-left: auto;  margin-right: auto;}</style><h1>使用Linux部署Apache服务器</h1><h2 id="要求文档">要求文档</h2><div class="center"><style>.gdprxahditib{}</style><img src="/2025/05/05/php02/php02_pic08.png" class="gdprxahditib"></div><h2 id="Task-1">Task 1</h2><h3 id="一、在虚拟机环境中安装Apache服务器">一、在虚拟机环境中安装Apache服务器</h3><h4 id="1-为虚拟机配置网络环境">1. 为虚拟机配置网络环境</h4><p>对于一个全新的虚拟机环境来说，它是没有网络连接的，因此在安装Apache服务器之前需要先配置其网络环境。</p><h5 id="1）在VMWare当中将虚拟机的网络适配器更改为NAT模式">1）在VMWare当中将虚拟机的网络适配器更改为NAT模式</h5><div class="center"><style>.pmbwwgesvloh{}</style><img src="/2025/05/05/php02/php02_pic01.png" class="pmbwwgesvloh"></div><h5 id="2）修改虚拟机的网络配置信息">2）修改虚拟机的网络配置信息</h5><p>首先在Linux终端中输入命令以查看配置信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo vim /etc/sysconfig/network-scripts/ifcfg-ens33<br></code></pre></td></tr></table></figure><p>结果如下图所示：</p><div class="center"><style>.vtrjgrrqbvpj{}</style><img src="/2025/05/05/php02/php02_pic02.png" class="vtrjgrrqbvpj"></div><p>将其中的<code>ONBOOT=no</code>更改为<code>ONBOOT=yes</code>以启用ens33端口。</p><p>随后在重启网络配置之后输入<code>ifconfig</code>命令以查看虚拟机IP地址信息：</p><div class="center"><style>.xtnsyqnsooot{}</style><img src="/2025/05/05/php02/php02_pic03.png" class="xtnsyqnsooot"></div><p>记录其中ens33端口对应的IP地址，并将其添加到<code>/etc/sysconfig/network-scripts/ifcfg-ens33</code>文件当中：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">在源文件内容下新增：</span><br>GATEWAY= # 输入记录下来的IP地址<br>DNS1=114.114.114.114<br></code></pre></td></tr></table></figure><p>随后继续输入命令修改配置文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo vim /etc/resolv.conf<br></code></pre></td></tr></table></figure><p>将其中<code>nameserver</code>一行的值替换为<code>114.114.114.114</code>。</p><p>重启网络后成功ping通，网络环境配置完毕：</p><div class="center"><style>.tobfrlnjesxi{}</style><img src="/2025/05/05/php02/php02_pic04.png" class="tobfrlnjesxi"></div><h4 id="2-更新安装包">2. 更新安装包</h4><p>使用以下命令更新所有已安装的包：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo yum update<br>sudo yum install tree<br></code></pre></td></tr></table></figure><p><em>注：如有需要请参见<a href="https://loquattree.xyz/2025/05/06/md04/">CentOS yum命令“There are no enabled repos”报错的解决方案</a></em></p><h4 id="3-安装Apache服务器">3. 安装Apache服务器</h4><p>执行以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">安装并启用Apache服务器软件</span><br>sudo yum install -y httpd httpd-tools mod_ssl<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">启用并启动服务器</span><br>sudo systemctl enable httpd<br>sudo systemctl start httpd<br></code></pre></td></tr></table></figure><h4 id="4-检查配置结果">4. 检查配置结果</h4><h5 id="1）在Linux中安装chrome浏览器">1）在Linux中安装chrome浏览器</h5><p>执行以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">wget -O /tmp/chrome.rpm https://dl.google.com/linux/direct/google-chrome-stable_current_x86_64.rpm<br><br>su -<br><br>dnf localinstall /tmp/chrome.rpm<br></code></pre></td></tr></table></figure><p><em>注：如有需要请参见<a href="https://loquattree.xyz/2025/05/06/md05/">CentOS 7 dnf命令“conflicting requests”报错的解决方案</a></em></p><p>安装成功后如下图所示：</p><div class="center"><style>.tsdchdlbexmf{}</style><img src="/2025/05/05/php02/php02_pic05.png" class="tsdchdlbexmf"></div><h5 id="2）使用chrome浏览器检查配置结果">2）使用chrome浏览器检查配置结果</h5><p>执行以下命令以修改Apache配置文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo nano /etc/httpd/conf/httpd.conf<br></code></pre></td></tr></table></figure><p>使用Crtl+w检索<code>SeverName</code>，如下图所示添加<code>ServerName localhost:80</code>：</p><div class="center"><style>.hdxtiwdfuxva{}</style><img src="/2025/05/05/php02/php02_pic06.png" class="hdxtiwdfuxva"></div><p>保存并退出文件后继续执行命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">重启服务</span><br>sudo systemctl stop httpd<br>sudo systemctl restart httpd<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">切换到指定目录</span><br>cd /var/www/html<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">创建index页，在其中输入任意内容即可</span><br>sudo nano index.html<br></code></pre></td></tr></table></figure><div class="center"><style>.lkokfgoabcxy{}</style><img src="/2025/05/05/php02/php02_pic07.png" class="lkokfgoabcxy"></div><h3 id="二、在虚拟机环境中安装PHP服务器">二、在虚拟机环境中安装PHP服务器</h3><h4 id="1-安装PHP服务器">1. 安装PHP服务器</h4><p>依次执行以下命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">yum clean metadata<br><br>sudo yum install php-cli php-pdo php-fpm php-mysqlnd<br>sudo yum install php php-&#123;pear,cgi,common,curl,mbstring,gd,mysqlnd,gettext,bcmath,json,xml,fpm,intl,zip,imap&#125;<br></code></pre></td></tr></table></figure><h4 id="2-检查配置结果">2. 检查配置结果</h4><p>执行以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd /var/www/html<br><br>sudo mv index.html index.php<br><br>sudo nano /etc/httpd/conf/httpd.conf # 检索“DirectoryIndex”，在index.html同一行中继续添加index.php<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">重启服务</span><br>sudo systemctl stop httpd<br>sudo systemctl restart httpd<br></code></pre></td></tr></table></figure><p>随后在浏览器中输入<code>localhost/index.php</code>检查结果，如果有正常显示即为配置成功。</p><h2 id="Task-2">Task 2</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">创建存放目录</span><br>cd ~<br>mkdir public_html<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">修改主配置文件</span><br>sudo vim /etc/httpd/conf/httpd.conf<br></code></pre></td></tr></table></figure><div class="center"><style>.bkhkbswzaiwb{}</style><img src="/2025/05/05/php02/php02_pic09.png" class="bkhkbswzaiwb"></div><p>将第<code>120</code>, <code>125</code>和<code>131</code>中的地址都改为自定义地址<code>/home/rhauser/public_html</code>并重新启动Apache服务器即可。</p><p><em>注：如有需要请参见<a href="https://loquattree.xyz/2025/05/07/md07/">访问Apache服务器时出现“403 Forbidden”的解决方案</a></em></p><p>随后在<code>public_html</code>文件夹中创建一个<code>index.php</code>文件和一个空文件夹<code>sub_test</code>，将要求的模板写入<code>index.php</code>文件后保存退出。此时打开该文件和该文件夹的效果应该如下所示：</p><div class="center"><style>.wrnilvnjixyr{}</style><img src="/2025/05/05/php02/php02_pic10.png" class="wrnilvnjixyr"></div><div class="center"><style>.byrrssiuxwvo{}</style><img src="/2025/05/05/php02/php02_pic11.png" class="byrrssiuxwvo"></div><h2 id="Task-3">Task 3</h2><p>执行以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo mkdir -p /home/rhauser/public_html/secure/development/restricted # -p确保自动创建父级目录<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">进入受限文件夹并创建目标文件</span><br>cd /home/rhauser/public_html/secure/development/restricted<br>sudo nano index.php<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">----------------------------</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">在index.php中写入以下内容</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">&lt;!DOCTYPE html&gt;</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">&lt;html&gt;</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">&lt;<span class="hljs-built_in">head</span>&gt;</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">&lt;title&gt;Example site name&lt;/title&gt;</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">&lt;/head&gt;</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">&lt;body&gt;</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">&lt;h1&gt;You are visiting the restricted area!!!&lt;/h1&gt;</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">&lt;br&gt;&lt;br&gt;</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">&lt;!-- Any other links goes here --&gt;</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">&lt;br&gt;&lt;br&gt;</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">&lt;pre&gt;</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Current Directory: &lt;?= <span class="hljs-built_in">dirname</span>(__FILE__) ?&gt;</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">&lt;/pre&gt;</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">----------------------------</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">修改Apache配置文件</span><br>sudo vim /etc/httpd/conf/httpd.conf<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">----------------------------</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">目标样式：</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-comment"># 建立虚拟路径和物理路径之间的映射</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Alias /restricted /home/rhauser/public_html/secure/development/restricted</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">&lt;Directory <span class="hljs-string">&quot;/home/rhauser/public_html&quot;</span>&gt;</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">    Options Indexes FollowSymLinks</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">    AllowOverride None</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">    Require all granted</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">&lt;/Directory&gt;</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">----------------------------</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">检查语法是否正确并重启服务</span><br>sudo apachectl configtest  <br>sudo systemctl restart httpd<br></code></pre></td></tr></table></figure><p>完成后访问限制路径内的索引页的效果如下图所示：</p><div class="center"><style>.ogbuncghofke{}</style><img src="/2025/05/05/php02/php02_pic12.png" class="ogbuncghofke"></div><h2 id="Task-4">Task 4</h2><p>执行以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">首先需要确认主配置允许使用 .htaccess 文件：</span><br>sudo vim /etc/httpd/conf/httpd.conf<br><span class="hljs-meta prompt_"># </span><span class="language-bash">----------------------------</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">在 /etc/httpd/conf/httpd.conf 中找到对应目录配置</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">&lt;Directory <span class="hljs-string">&quot;/var/www/html&quot;</span>&gt;</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">    AllowOverride AuthConfig</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">    <span class="hljs-comment"># 其他配置...</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">&lt;/Directory&gt;</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">----------------------------</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">创建密码文件并添加第一个用户Alice</span><br>sudo htpasswd -c /etc/httpd/.htpasswd Alice # 系统会提示输入密码，输入&quot;redhat&quot;并确认<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">添加第二个用户Bob</span><br>sudo htpasswd /etc/httpd/.htpasswd Bob # 同样输入密码&quot;redhat&quot;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">设置适当权限</span><br>sudo chown apache:apache /etc/httpd/.htpasswd<br>sudo chmod 640 /etc/httpd/.htpasswd<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">创建 .htaccess 文件</span><br>sudo vim /home/rhauser/public_html/secure/development/restricted/.htaccess<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">文件内容如下：</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">----------------------------</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">AuthType Basic</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">AuthName <span class="hljs-string">&quot;Restricted Area&quot;</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">AuthUserFile /etc/httpd/.htpasswd</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Require valid-user</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">----------------------------</span><br></code></pre></td></tr></table></figure><p>完成后就能实现访问限制区域后需要登录的效果：</p><div class="center"><style>.bdjpohlmgnyc{}</style><img src="/2025/05/05/php02/php02_pic13.png" class="bdjpohlmgnyc"></div><p>登录后就能收到访问限制提示：</p><div class="center"><style>.fripegnkjcag{}</style><img src="/2025/05/05/php02/php02_pic14.png" class="fripegnkjcag"></div><h2 id="Task-5">Task 5</h2><p>执行以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">创建新用户并设置密码</span><br>sudo useradd -m sxxxxxxx<br>echo &quot;redhat&quot; | sudo passwd --stdin sxxxxxxx<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">将新用户添加到sudoers当中</span><br>su -<br>sudo usermod -aG wheel sxxxxxxx<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">创建新的目录</span><br>sudo -u sxxxxxxx mkdir /home/sxxxxxxx/public_html<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">创建新的php文件</span><br>sudo su - sxxxxxxx<br>sudo vim ~/public_html/index.php<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">文件内容如下：</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">----------------------------</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">&lt;!DOCTYPE html&gt;</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">&lt;html&gt;</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">&lt;<span class="hljs-built_in">head</span>&gt;</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">&lt;title&gt;Example site name&lt;/title&gt;</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">&lt;/head&gt;</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">&lt;body&gt;</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">&lt;h1&gt;Welcome to S8118532<span class="hljs-string">&#x27;s Page!!&lt;/h1&gt;</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">&lt;br&gt;&lt;br&gt;</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">&lt;!-- Any other links goes here --&gt;</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">&lt;br&gt;&lt;br&gt;</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">&lt;pre&gt;</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">Current Directory: &lt;?= dirname(__FILE__) ?&gt;</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">&lt;/pre&gt;</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">----------------------------</span></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">启用用户目录模块</span></span><br>sudo sed -i &#x27;s/^#UserDir public_html/UserDir public_html/&#x27; /etc/httpd/conf.d/userdir.conf<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">设置目录权限</span></span><br>sudo chmod 711 /home/sxxxxxxx<br>sudo chmod 755 /home/sxxxxxxx/public_html<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">启用用户目录功能</span></span><br>sudo nano /etc/httpd/conf.d/userdir.conf<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">文件内容修改如下：</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">----------------------------</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">&lt;IfModule mod_userdir.c&gt;</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">    # 注释掉禁用行，启用用户目录功能</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">    #UserDir disabled</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">    UserDir public_html</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">    UserDir disabled root  # 禁止root用户使用此功能</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">&lt;/IfModule&gt;</span></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">&lt;Directory &quot;/home/*/public_html&quot;&gt;</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">    AllowOverride FileInfo AuthConfig Limit Indexes</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">    Options MultiViews Indexes SymLinksIfOwnerMatch IncludesNoExec</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">    Require method GET POST OPTIONS</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">&lt;/Directory&gt;</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">----------------------------</span></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">重启Apache</span></span><br>sudo systemctl restart httpd<br>sudo systemctl enable httpd<br></code></pre></td></tr></table></figure><p>最终效果如下所示：</p><div class="center"><style>.jzhzinabfikd{}</style><img src="/2025/05/05/php02/php02_pic15.png" class="jzhzinabfikd"></div><h2 id="Task-6">Task 6</h2><p>执行以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">创建错误页目录及文件</span><br>mkdir -p /home/rhauser/public_html/error<br>vi /home/rhauser/public_html/error/403.php<br>vi /home/rhauser/public_html/error/404.php<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">设置权限（确保Apache用户可读）</span><br>chmod 755 /home/rhauser/public_html/error<br>chmod 644 /home/rhauser/public_html/error/*.php<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">修改Apache配置</span><br>sudo vi /etc/httpd/conf/httpd.conf<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">---------------------</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">在配置文件中 ​​全局或对应&lt;VirtualHost&gt;段​​ 添加：</span><br>ErrorDocument 403 /error/403.php # 路径 /error/... 是相对于DocumentRoot的，无需写绝对路径<br>ErrorDocument 404 /error/404.php # 这里我输入的内容是“This is a diy 404 page!!”<br><span class="hljs-meta prompt_"># </span><span class="language-bash">---------------------</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">修改限制目录的权限</span><br>chmod 611 /home/rhauser/public_html/secure/development/restricted<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">重启Apache服务器</span><br>sudo systemctl restart httpd<br></code></pre></td></tr></table></figure><p>完成后，访问一个不存在的页面，例如<code>localhost/notfound</code>页面，打开的效果如下图所示：</p><div class="center"><style>.tssgisiytdjk{}</style><img src="/2025/05/05/php02/php02_pic16.png" class="tssgisiytdjk"></div>]]></content>
    
    
    <summary type="html">VIT1024 Ass01 Lab3实现小结</summary>
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="PHP" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/PHP/"/>
    
    
    <category term="PHP" scheme="http://example.com/tags/PHP/"/>
    
    <category term="linux" scheme="http://example.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>软件设计师 上午题 操作系统知识</title>
    <link href="http://example.com/2025/04/28/note33/"/>
    <id>http://example.com/2025/04/28/note33/</id>
    <published>2025-04-28T14:32:24.000Z</published>
    <updated>2025-05-08T08:27:13.937Z</updated>
    
    <content type="html"><![CDATA[<style>.center {  width: auto;  display: table;  margin-left: auto;  margin-right: auto;}.heimu, .heimu a, a .heimu, .heimu a.new {  background-color: #252525;  color: #252525;  text-shadow: none;}.heimu:hover, .heimu:active,.heimu:hover .heimu, .heimu:active .heimu {  color: white !important;}.heimu:hover a, a:hover .heimu,.heimu:active a, a:active .heimu {  color: lightblue !important;}.heimu:hover .new, .heimu .new:hover, .new:hover .heimu,.heimu:active .new, .heimu .new:active, .new:active .heimu {  color: #BA0000 !important;}</style><h1>软件设计师 上午题 操作系统知识</h1><p>操作系统(Operating System, OS)是为裸机配置的一种系统软件，用于填补人与机器之间的鸿沟。操作系统在计算机系统中的地位如下图所示：</p><div class="center"><style>.yuscpvljdlko{}</style><img src="/2025/04/28/note33/note33_pic01.png" class="yuscpvljdlko"></div><p>不难发现，操作系统是裸机上的第一层软件，是对硬件系统功能的首次扩充，是用户与计算机之间的接口。有了操作系统，系统软件和应用软件等大量其它软件才有了使用基础，因此，操作系统已成为现代计算机系统中必不可少的最重要的系统软件。<br>操作系统的核心功能模块分为进程管理、存储管理、设备管理、文件管理和作业管理五个部分，它们共同构成了操作系统对计算机硬件和软件资源的管理体系。</p><h2 id="一、进程管理">一、进程管理</h2><p>进程管理也称之为处理机管理，为了描述系统中程序执行时的动态变化，操作系统中引入了进程的概念。所谓进程管理即管理计算机中正在运行的程序，其管理重点是研究诸进程之间的并发特性，以及进程之间相互合作与资源竞争产生的问题，进而确保CPU资源被合理分配。</p><h3 id="Ⅰ-基本概念">Ⅰ 基本概念</h3><h4 id="1-程序与进程">1. 程序与进程</h4><p>程序的执行方式大致可以分为顺序执行和并发执行两类：</p><p><strong>1）程序顺序执行的特征</strong>：</p><p>顺序执行是指程序严格按照代码编写的顺序依次执行，前一条语句执行完毕才会执行下一句。程序顺序执行时的主要特征包括顺序性、封闭性和可再现性。<br>此外，有一种有向无环图叫做前驱图，它可以用来描述程序中各个任务之间的依赖关系。因此顺序执行的任务就可以转换为一条线性前驱图，如下图所示：</p><div class="center"><style>.sctncbbkskdf{}</style><img src="/2025/04/28/note33/note33_pic02.png" class="sctncbbkskdf"></div><p>其中，输入结束之后才能进行计算，计算结束之后才能进行输出。</p><p><strong>2）程序并发执行的特征</strong>：</p><p>若在计算机系统当中采用多道程序设计技术，则主存中的多道程序可处于并发执行状态。虽然每个作业中有前驱关系的各程序段不能并行执行，但是每个作业中没有前驱关系的程序段或者不同作业的程序段可以并行执行。</p><div class="center"><style>.vkqzijkunzxq{}</style><img src="/2025/04/28/note33/note33_pic03.png" class="vkqzijkunzxq"></div><p>若每个程序有三个程序段：输入<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>I</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">I_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>、计算<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>C</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">C_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>和输出<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">P_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。如图4-2所示，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>I</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">I_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>就可以和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>C</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">C_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>并行执行，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>I</mi><mn>3</mn></msub></mrow><annotation encoding="application/x-tex">I_3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>、<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>C</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">C_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">P_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>也可以并行执行等等。<br>同时，程序并发执行时有以下特征：</p><ul><li><strong>失去了程序的封闭性</strong>：在顺序执行时，程序独占所有资源，其执行过程不受外界干扰，结果完全由程序自身决定，这也就是所谓的封闭性。而在并发执行的过程中，多个程序共享资源就会打破这一封闭性。</li><li><strong>程序和机器的执行程序的活动不再一一对应</strong>：在顺序执行中，程序指令严格按照代码顺序执行，程序行为是可预测的。但是在并发执行当中因CPU调度、中断、抢占等问题，指令的执行顺序可能被打乱。</li><li><strong>并发程序间的相互制约性</strong>：并发程序由于共享资源或者协作关系，会彼此制约和影响。其中又分为直接制约和间接制约。前者是指程序间进行显式通信，而后者指的是竞争同一资源导致阻塞。</li></ul><hr><div class="center"><style>.ggbiwpftrnyd{}</style><img src="/2025/04/28/note33/note33_pic04.png" class="ggbiwpftrnyd"></div><p>首先需要了解的是什么是信号量和PV操作。信号量本质上是一个计数器+等待队列+原子操作(即PV操作)。其中计数器中的整型变量，也就是题目中所谓的<code>S1</code>，<code>S2</code>，<code>S3</code>，<code>S4</code>，是用来表示当前可用的“通行许可证”数量，可以用来衡量当前系统中剩余的资源数量。而P操作（Proberen，荷兰语“通过”）是申请资源，操作结果是计数器<code>S</code>-=1，V操作（Verhogen，荷兰语“释放”）是释放资源，作结果是计数器<code>S</code>+=1。另外，信号量是针对于进程转换这个过程而言的，也就是图中的每一个“箭头”，而非针对进程本身。<strong>在每一个箭头当中应该先完成一次V操作再完成一次P操作</strong>。<br>那么对于本题来说，<code>S1</code>是指P1P2之间的箭头，其余以此类推。那么P1进行时，应该先分别完成一次V(S1)和一次V(S2)；然后为了使P2准备就绪，就应该再完成一次P(S1)。重复执行这个思路就能得到最终答案。</p><hr><div class="center"><style>.pjxyxdkrytas{}</style><img src="/2025/04/28/note33/note33_pic05.png" class="pjxyxdkrytas"></div><p>BAC，捋顺<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>I</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">I_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>-&gt;<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>C</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">C_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>-&gt;<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">P_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的关系即可。</p><h4 id="2-进程的状态及其状态间的切换">2. 进程的状态及其状态间的切换</h4><p>进程一般有3种基本状态：运行、就绪和阻塞：</p><ul><li>运行：当一个进程在处理机上运行时，则称该进程处于运行状态。</li><li>就绪：一个进程获得了除处理机外的一切所需资源，一旦得到处理机即可运行，则称此进程处于就绪状态。</li><li>阻塞：阻塞也称等待或者睡眠状态，当一个进程正在等待某一事件发生而暂停运行（即使把处理机分配给进程也无法运行），此时该进程处于阻塞状态。</li></ul><p>当在这三种基本状态中捋顺了转换关系，就构成了三态模型：</p><div class="center"><style>.nmvizjhjnidg{}</style><img src="/2025/04/28/note33/note33_pic06.png" class="nmvizjhjnidg"></div><h3 id="Ⅱ-进程间的通信">Ⅱ 进程间的通信</h3><p>显而易见，在一个多道程序环境的系统当中，进程间必然存在资源共享和相互合作的问题，而进程通信就是指各个进程之间交换信息的过程。</p><h4 id="1-同步与互斥">1. 同步与互斥</h4><blockquote><p>同步是合作进程间的直接制约问题，互斥是申请临界资源进程间的间接制约问题。<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="软件设计师教程（第五版）. (2018).">[1]</span></a></sup></p></blockquote><p>用人话说就是，同步是多个进程需要按照特定的顺序协作完成任务，互斥是多个进程竞争同一资源，需要保证同一时间仅一个进程访问。</p><p><strong>1）进程间的同步</strong></p><p>在计算机系统当中，多个进程可以并发执行，每个进程都以各自独立的、不可预知的速度向前推进，但是需要在某些确定点上协调相互合作进程间的工作。例如进程A煮米，进程B炒米，那显然必须是进程A完成了之后才能进行进程B，否则进程B就要停下来等待进程A。</p><p><strong>2）进程间的互斥</strong></p><p>在多道程序系统环境当中，有一种资源一次只能供一个进程使用，这种资源我们称其为临界资源，比如打印机。那么进程之间的互斥就是系统中多个进程因争用临界资源而发生的互斥执行。</p><p><strong>3）临界区管理的原则</strong></p><p>临界区即进程中对临界资源实施操作的那段程序，对互斥临界区的管理有以下几条原则：</p><ul><li>有空即进。</li><li>无空则等。</li><li>有限等待：应该保证进程在<strong>有限的时间</strong>内能够进入临界区，以免其陷入“饥饿”状态。</li><li>让权等待：当进程不能进入自己的临界区时，应立即释放处理机，以免进程陷入忙等待（如果暂时轮不到你的时候就先去忙别的事情）。</li></ul><h4 id="2-信号量机制">2. 信号量机制</h4><p>在本文的前边我们已经了解过信号量和PV操作相关的内容，这里我们主要探讨如何使用PV操作实现进程间的同步和互斥：</p><p><strong>1）利用PV操作实现进程间的同步</strong></p><p>要实现进程的同步可以用一个信号量与消息联系起来，当信号量的值为0时表示希望的消息未产生，当信号量的值为非0的时候表示希望的消息已经存在。那么进程就可以通过调用P操作测试消息是否到达，通过调用V操作通知消息已经准备好。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c">semaphore sync = <span class="hljs-number">0</span>; <span class="hljs-comment">// 初始值为0的同步信号量</span><br><br>Process <span class="hljs-title function_">A</span><span class="hljs-params">()</span> <br>&#123;<br>    <span class="hljs-comment">// 执行操作A</span><br>    V(sync);    <span class="hljs-comment">// 通知进程B操作A已完成</span><br>&#125;<br><br>Process <span class="hljs-title function_">B</span><span class="hljs-params">()</span> <br>&#123;<br>    P(sync);    <span class="hljs-comment">// 等待操作A完成</span><br>    <span class="hljs-comment">// 执行操作B</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>2）利用PV操作实现进程间的互斥</strong></p><p>令信号量S的初值为1，当进入临界区时执行P操作，退出临界区时执行V操作。这样一来，每当有程序段调用临界资源时S就能减1，防止共用一个临界资源的情况产生。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c">semaphore mutex = <span class="hljs-number">1</span>; <span class="hljs-comment">// 初始值为1的互斥信号量</span><br><br>Process <span class="hljs-title function_">P1</span><span class="hljs-params">()</span> <br>&#123;<br>    P(mutex);    <span class="hljs-comment">// 进入临界区前申请锁</span><br>    <span class="hljs-comment">// 临界区代码</span><br>    V(mutex);    <span class="hljs-comment">// 离开临界区后释放锁</span><br>&#125;<br><br>Process <span class="hljs-title function_">P2</span><span class="hljs-params">()</span> <br>&#123;<br>    P(mutex);<br>    <span class="hljs-comment">// 临界区代码</span><br>    V(mutex);<br>&#125;<br></code></pre></td></tr></table></figure><hr><div class="center"><style>.nexjchszimwn{}</style><img src="/2025/04/28/note33/note33_pic07.png" class="nexjchszimwn"></div><p><strong>D</strong>。系统内有两台打印机，那么说明起始的可用资源总数应为2，即S的最大值应为2。当第一个进程想要调用打印机时，它就需要进行一次P(S)操作，S变为1。随后依次类推，每个进程逐次进行P(S)操作，最后就得到了S的最小值为-(n-2)。</p><hr><div class="center"><style>.dkhxamhkicph{}</style><img src="/2025/04/28/note33/note33_pic08.png" class="dkhxamhkicph"></div><p><strong>BA</strong>，不难发现，生产者甲和生产者乙两者之间需要保持一种同步关系，而生产者甲和生产者乙自身所处的过程则需要保持一种互斥关系。在之前的学习中我们了解到，如果要保持同步关系，需要先执行一次V操作通知资源已经准备好，而如果要保持互斥关系，需要先执行一次P操作来占用资源。据此分析，S1是一个互斥信号量，在存放前减一，在取出后加一，用来表示的应该是半成品箱中被占用的资源，<strong>因此其初值应该为n</strong>；而S2是一个同步信号量，用来表示生产者甲通知生产者乙已经完成了一个半成品，<strong>因此其初值应该为0</strong>。此外，根据题目，S也是一个互斥信号量，鉴于它在每一个临界区中都会出现，它表示的应该是半成品箱是否正在被占用以存取物品，<strong>因此其初值应该为1</strong>。</p><hr><div class="center"><style>.midqelctfigi{}</style><img src="/2025/04/28/note33/note33_pic09.png" class="midqelctfigi"></div><p><strong>CD</strong>， <span class="heimu"><s>信号量S应该与一个互斥的进程有关，即当前还有几个购票终端可以使用，那么这个信号量的初值就应该为n-1。</s></span>  用户在选定具体的终端<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">P_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>之后需要占用这个终端，因此需要一个互斥信号量S，<strong>其初始值应该为1</strong>；<strong>(a)处应该为P(S)</strong>，因为当一个乘客想要买票时会占用一个终端；<strong>(b)处和©处都应该是V(S)</strong>，因为此时已经完成了购票流程，可以释放终端了。</p><h3 id="Ⅲ-死锁">Ⅲ 死锁</h3><p>死锁现象的一般表现为：多个进程/线程均无法继续执行，系统整体或部分功能停滞（如程序无响应、任务无法完成），在本小节中我们仅了解同类资源分配不当引起的死锁。<br>当系统中有n个进程，每个进程所需要的资源数为k，系统中的资源总数为m，且系统采用的分配策略是轮流地为每个进程分配资源时，若<strong>m &lt; n*（k-1）+1</strong>，则会发生死锁。</p><h4 id="1-进程资源图">1. 进程资源图</h4><p>进程资源图是一种​​有向图​​，用于描述操作系统中的​​进程与资源之间的分配和请求关系​​，是分析和检测死锁的重要工具，其一般形式如下图所示：</p><div class="center"><style>.yfuaqiyieblo{}</style><img src="/2025/04/28/note33/note33_pic10.png" class="yfuaqiyieblo"></div><p>其中，一个圆圈代表一个进程，一个矩形代表一个资源，其中的圆圈个数是其资源的数量。</p><p>不同数字代表的箭头含义不同：</p><ol><li>表示P1向R申请一个资源</li><li>表示R向P1分配一个资源</li><li>表示<strong>R先分配给P1一个资源</strong>，P1再向R申请一个资源</li><li>R已经向三个进程分配了自己全部的三个资源，此时P1再向R申请资源就会进入等待态，即堵塞状态。</li></ol><p>此外，进程资源图是可化简的，其步骤如下所述：</p><ol><li>把不阻塞的进程的所有边都去掉，形成一个孤立的点，再把系统分配给这个进程的资源回收回来。</li><li>看剩下的进程有哪些是不阻塞的，然后又把它们逐个变成孤立的点。</li><li>最后，所有的资源和进程都变成孤立的点。这样的图就叫做“可完全简化”。</li></ol><p>如果一个图可完全简化，该系统就不会产生死锁，反之就会产生死锁。</p><hr><div class="center"><style>.jmrkveclxwwi{}</style><img src="/2025/04/28/note33/note33_pic11.png" class="jmrkveclxwwi"></div><p><strong>BC</strong>，在图(a)中，R1中两个资源已经分配完毕但依旧有P2的申请，因此P2是一个堵塞结点，P1同理，图(b)同理。</p><hr><h4 id="2-死锁的避免策略">2. 死锁的避免策略</h4><p>银行家算法​​是一种经典的​​死锁避免算法​​，由Dijkstra提出，用于确保操作系统在分配资源时不会进入死锁状态。它的核心思想是​​模拟资源分配​​，仅当分配后系统仍处于​​安全状态​​时才批准请求，否则让进程等待。</p><blockquote><p>银行家（操作系统）需要确保手头的现金（资源）能满足所有客户（进程）的贷款需求，同时避免资金链断裂（死锁）。</p></blockquote><div class="center"><style>.weiyuflfzewf{}</style><img src="/2025/04/28/note33/note33_pic12.png" class="weiyuflfzewf"></div><p>以此题为例，通过对已分配资源数的加和计算，不难发现R1，R2和R3的剩余资源数分别为1、1、0。<br>那么显然此时不能再继续执行还需要R3分配资源的进程了，观察后发现只有P4符合这一条件，因此执行序列的第一个应该为P4，<strong>排除①②</strong>。<br>下面可以讨论序列③能否完成，可以借助下图分析：</p><div class="center"><style>.ccghlndiskrx{}</style><img src="/2025/04/28/note33/note33_pic13.png" class="ccghlndiskrx"></div><p>如果一个进程最终能够执行完毕，我们就给它打上一个<code>True</code>的标志。而检查其是否能够执行完毕的条件即为<code>可用</code>能否覆盖<code>需求</code>。同时，一个进程完成之后会释放所有已经占用的资源，即<code>可用+已分</code>部分的内容。据此分析，P1是无法完成的，因此<strong>排除序列③</strong>。</p><h3 id="Ⅳ-线程">Ⅳ 线程</h3><blockquote><p>传统的进程有两个基本属性:可拥有资源的独立单位;可独立调度和分配的基本单位。引入线程的原因是进程在创建、撤销和切换中，系统必须为之付出较大的时空开销，故在系统中设置的进程数目不宜过多，进程切换的频率不宜太高，这就限制了并发程度的提高。引入线程后，将传统进程的两个基本属性分开，线程作为调度和分配的基本单位，进程作为独立分配资源的单位。用户可以通过创建线程来完成任务，以减少程序并发执行时付出的时空开销。<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="软件设计师教程（第五版）. (2018).">[1]</span></a></sup></p></blockquote><div class="center"><table><thead><tr><th><strong>对比维度</strong></th><th><strong>进程（Process）</strong></th><th><strong>线程（Thread）</strong></th></tr></thead><tbody><tr><td><strong>定义</strong></td><td>操作系统资源分配的基本单位，拥有独立的内存空间。</td><td>进程内的执行单元，共享进程资源，是CPU调度的基本单位。</td></tr><tr><td><strong>资源占用</strong></td><td>独立的内存、文件句柄、CPU时间等。</td><td>共享进程的内存和资源，仅私有栈和寄存器。</td></tr><tr><td><strong>创建/销毁开销</strong></td><td>高（需分配独立资源）。</td><td>低（共享进程资源，仅需少量初始化）。</td></tr><tr><td><strong>切换成本</strong></td><td>高（需切换内存空间、更新页表等）。</td><td>低（仅切换寄存器、栈等线程私有数据）。</td></tr><tr><td><strong>独立性</strong></td><td>崩溃后不影响其他进程。</td><td>崩溃可能导致整个进程终止（共享地址空间）。</td></tr><tr><td><strong>并发性</strong></td><td>多进程依赖进程间切换（上下文切换成本高）。</td><td>多线程可真正并行（同一进程内线程切换成本低）。</td></tr><tr><td><strong>适用场景</strong></td><td>需要隔离性、安全性的任务（如不同用户的程序）。</td><td>需要高并发、低延迟的任务（如Web服务器处理请求）。</td></tr><tr><td><strong>类比</strong></td><td>独立的“工厂”，拥有自己的设备和资源。</td><td>工厂中的“工人”，共享设备但独立执行任务。</td></tr></tbody></table></div><p>此外，同一个进程中的不同线程都可以共享这个进程中的资源。</p><h2 id="二、存储管理">二、存储管理</h2><blockquote><p>存储器管理的对象是主存存储器简称主存或内存。存储器是计算机系统中的关键性资源，是存放各种信息的主要场所。尽管近年来内存越来越便宜、容量越来越大，但系统软件、应用软件在功能及其所需存储空间等方面都在急剧膨胀，如何对存储器实施有效的管理，不仅直接影响到存储器的利用率，而且还对系统性能有很大的影响。存储器管理的主要功能包括主存空间的分配和回收、提高主存的利用率、扩充主存、对主存信息实现有效保护。<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="软件设计师教程（第五版）. (2018).">[1]</span></a></sup></p></blockquote><h4 id="前置知识：局部性原理">前置知识：局部性原理</h4><p>局部性原理是计算机系统的一个重要行为特征，它描述了程序在执行过程中对内存访问的规律性，即程序更倾向于在短时间内集中访问某些特定的内存区域，而不是均匀地访问整个地址空间：</p><ul><li>时间局部性：如果一个数据或指令被访问过，那么它在不久的将来很可能再次被访问。</li><li>空间局部性：如果一个数据被访问，那么它附近的数据（如相邻的内存地址）也可能很快被访问。</li></ul><h3 id="Ⅰ-分页存储管理">Ⅰ 分页存储管理</h3><p>进行分页管理的原理即为将一个进程的地址空间划分成若干个大小相等的区域，称为页，同时将主存空间划分成与页相等大小的若干个物理块，称为块。在实际运行时会将若干个页分别装入多个不相邻接的块中。</p><div class="center"><style>.nbvyckypmmhk{}</style><img src="/2025/04/28/note33/note33_pic14.png" class="nbvyckypmmhk"></div><p>分页系统的地址结构如上图所示，由页号和偏移量（即页内地址）两部分组成。其中页号是高位部分，用于索引页表，而页内偏移是低位部分，直接对应物理页内的位置。</p><hr><div class="center"><style>.niksrfwlsikv{}</style><img src="/2025/04/28/note33/note33_pic16.png" class="niksrfwlsikv"></div><p><strong>AC</strong>，根据题意不难发现，页面0、页面2和页面4在内存当中，若需淘汰应在在三个页面当中淘汰。而根据程序的局部性原理，页面0最近被访问过，页面2、页面4既被访问过又被修改过，因此最有可能淘汰的是页面0。此外，由于页面大小为4KB，即4×2^10字节，亦即2^12字节，说明该系统中页有12位。也就是说只有当<strong>页面偏移量为12时</strong>才能覆盖所有位，如此一来便确定了页面偏移量。而题目中给出的2C25H等同于0x2C25（H用来表明该数采用十六进制表示），也就是一共有4个数，即4×4=16位。那么在后12位为页面偏移量的情况下，剩余的前4位，即第1个数就是页号了，为2。随后再根据页表内的信息将页号转换为页帧号（即物理块号），就得到了<strong>物理地址为4C25H</strong>。</p><h3 id="Ⅱ-段页式存储管理">Ⅱ 段页式存储管理</h3><p>段页式存储管理是一种对段式存储和页式存储“各取所长”的存储管理方式，它先将整个主存划分成大小相等的存储块，随后将用户程序按程序的逻辑关系分为若干个段，再将一个段划分成若干个页。据此就形成了由段号、段内页号和业内地址三部分组成的段页式管理的地址：</p><div class="center"><style>.vbifocrxousa{}</style><img src="/2025/04/28/note33/note33_pic17.png" class="vbifocrxousa"></div><hr><div class="center"><style>.vvqsfbjrjhvf{}</style><img src="/2025/04/28/note33/note33_pic18.png" class="vvqsfbjrjhvf"></div><p><strong>B</strong>，简单的分段计算，唯一需要注意的是页号所在段的长度描述的是每个段<strong>最大允许</strong>有多少多少个页。</p><h2 id="三、设备管理">三、设备管理</h2><h3 id="Ⅰ-缓冲技术">Ⅰ 缓冲技术</h3><p>缓冲技术是一种通过临时存储数据来协调不同速度设备或组件之间数据传输的方法，旨在解决速度不匹配问题，提高系统效率和性能。其核心原理是在数据生产者（如CPU、磁盘）与消费者（如打印机、网络）之间设立一个中间存储区（缓冲区），允许两者以各自最佳速率运行，减少等待时间。此外，亦有单缓冲区和双缓冲区的差别：</p><div class="center"><table><thead><tr><th><strong>特性</strong></th><th><strong>单缓冲区</strong></th><th><strong>双缓冲区</strong></th></tr></thead><tbody><tr><td><strong>结构</strong></td><td>仅一个缓冲区</td><td>两个缓冲区交替使用（Buffer A/B）</td></tr><tr><td><strong>工作流程</strong></td><td>生产者填满→消费者读取→生产者等待</td><td>生产者填满A时，可立即填充B，消费者同时读取A</td></tr><tr><td><strong>阻塞情况</strong></td><td>生产/消费过程可能相互阻塞</td><td>生产与消费可并行，减少阻塞</td></tr><tr><td><strong>效率</strong></td><td>较低</td><td>较高</td></tr><tr><td><strong>适用场景</strong></td><td>低速或非实时场景</td><td>高速或实时需求</td></tr></tbody></table></div><hr><div class="center"><style>.rghwgwvnvgjr{}</style><img src="/2025/04/28/note33/note33_pic19.png" class="rghwgwvnvgjr"></div><p><strong>CB</strong>，</p><p>单缓冲工作的过程图和并行工作的示意图如下图所示：</p><div class="center"><style>.zjbpqynjghcp{}</style><img src="/2025/04/28/note33/note33_pic20.png" class="zjbpqynjghcp"></div><p>不难发现当单缓冲区并行工作时，上一个任务的处理过程和下一个任务的输入过程是并行的，因此每个任务的实际工作时长可以看作10+5=15μs，再加上最后一个任务多余的处理时间，总时间即为15×10+2=152μs。</p><p>双缓冲工作的过程图和并行工作的示意图如下图所示：</p><div class="center"><style>.vqhkhddoylvc{}</style><img src="/2025/04/28/note33/note33_pic21.png" class="vqhkhddoylvc"></div><p>双缓冲区和单缓冲区的不同就在于其输入过程是持续不断的，因此只需要计算10次输入过程的时长，并再加上最后一个任务的传送以及处理时间即可，答案为107μs。</p><h3 id="Ⅱ-磁盘调度">Ⅱ 磁盘调度</h3><p>计算机从一个磁盘中读取数据的基本过程为：读/写头移动到目标柱面上，这一过程称之为寻道时间；而存储数据的目标扇区会一刻不停旋转，想要读取数据就需要等待扇区旋转到读/写头的位置，这一过程称之为旋转延迟。</p><div class="center"><style>.aiddhfzqtmnb{}</style><img src="/2025/04/28/note33/note33_pic23.png" class="aiddhfzqtmnb"></div><p>而磁盘调度算法分为移臂调度和旋转调度两类，并且是先进行移臂调度，然后进行旋转调度。需要注意的是，在访问磁盘的过程中最耗时的是寻道时间。</p><h4 id="1-移臂调度算法">1. 移臂调度算法</h4><h5 id="1）-先来先服务算法（FCFS）">1） 先来先服务算法（FCFS）</h5><h5 id="2）-最短寻道时间优先算法（SSTF）">2） 最短寻道时间优先算法（SSTF）</h5><p>这种算法要求访问的磁道与当前磁头所在的磁道距离最近。</p><h5 id="3）-扫描算法（SCAN）">3） 扫描算法（SCAN）</h5><p>SCAN算法较于SSTF算法的区别在于其只考虑当前移动方向内的距离最近的磁道，在当前移动方向上没有磁道需要访问了磁头才会转向。</p><h5 id="4）-单向扫描调度算法（CSCAN）">4） 单向扫描调度算法（CSCAN）</h5><p>CSCAN算法和SCAN算法的区别在于前者是一种单向扫描算法，这意味着该算法在折返过程中不会停留，将保持循环往复保持同一起点进行单向扫描。</p><h4 id="2-旋转调度算法">2. 旋转调度算法</h4><p>当读写头到达指定位置之后，会有多个进程等待访问该柱面，那么该如何决定这些进程的访问顺序？就需要考虑以下几种情况：</p><ul><li>进程请求访问的是同一磁道上不同编号的扇区</li><li>进程请求访问的是不同磁道上不同编号的扇区</li><li>进程请求访问的是不同磁道上相同编号的扇区</li></ul><p>对于前两种情况，旋转调度总是让首先到达读/写头位置的扇区进行操作，而后一种情况下则是任选一个扇区进行传送操作。</p><p>旋转调度算法中常常涉及到在磁盘中对信息存储进行优化分布，鉴于在这里不便展开，详情请参见<a href="https://www.bilibili.com/video/BV1AY411E7GC?vd_source=d2a4fcb87f01b1e635c2de07e4f9fb34&amp;spm_id_from=333.788.videopod.episodes&amp;p=79">2010年上半年第27、28题</a>。</p><h2 id="四、文件管理">四、文件管理</h2><h3 id="Ⅰ-文件目录">Ⅰ 文件目录</h3><p>为了实现文件的“按名存取”，操作系统中势必存在一种来管理文件的数据结构，我们称其为文件控制块（FCB），而FCB的有序集合就是文件目录，故而文件控制块也可以被称作目录项。</p><h4 id="1-文件控制块">1. 文件控制块</h4><p>FCB中包含以下三类信息：</p><ul><li>基本信息类：存储文件名、文件的物理地址、文件长度等。</li><li>存取控制信息类：存储文件的存取权限。</li><li>使用信息类：存储文件建立日期、最后一次修改日期、当前使用的信息等。</li></ul><h4 id="2-目录结构">2. 目录结构</h4><p>如何组织目录结构显然是一个重要的议题，它将直接影响文件的存取速度。常见的目录结构有以下三种:</p><ul><li>一级目录结构：整个目录结构是一个线性结构，即在整个系统中只需要建立一张目录表，系统为每一个文件分配一个目录项。</li><li>二级目录结构：一级目录结构的一个缺点就是不同用户的文件容易重名且缺乏隔离性，因此我们可以引入二级目录结构的概念。二级目录结构由用户目录和主目录组成，主目录是系统唯一的顶层目录，包含所有用户的子目录，而用户目录则用来管理用户自己的独立文件。</li><li>多级目录结构：但是二级目录结构过强的隔离性又影响了多个用户之间的协作，比如一个用户难以直接访问另一个用户的文件，因此我们又引入了多级目录结构。多级目录结构类似于一棵树，从树根向下，每一个结点是一个目录，叶子节点即为文件，现代操作系统一般都采用了这种目录结构。</li></ul><div class="center"><table><thead><tr><th><strong>特性</strong></th><th>单级目录</th><th>二级目录</th><th><strong>多级目录</strong></th></tr></thead><tbody><tr><td><strong>结构复杂度</strong></td><td>最简单（所有文件同级存储）</td><td>中等（用户目录+主目录）</td><td>最复杂（树形嵌套，但灵活性最高）</td></tr><tr><td><strong>命名冲突</strong></td><td>极易发生（文件名必须唯一）</td><td>用户间隔离（同用户仍冲突）</td><td>路径唯一性彻底解决（如<code>/a/1.txt</code>和<code>/b/1.txt</code>可共存）</td></tr><tr><td><strong>扩展性</strong></td><td>无法扩展</td><td>有限扩展（仅两级）</td><td>无限嵌套子目录（如<code>/a/b/c/...</code>）</td></tr><tr><td><strong>权限控制</strong></td><td>全局统一权限</td><td>用户目录独立权限</td><td>每个目录可单独设权限（<code>chmod</code>）</td></tr><tr><td><strong>典型系统</strong></td><td>早期DOS</td><td>早期Unix</td><td>现代Linux/Windows/macOS</td></tr><tr><td><strong>路径示例</strong></td><td><code>file.txt</code></td><td><code>/home/user1/file.txt</code></td><td><code>/home/user1/docs/project1.txt</code></td></tr></tbody></table></div><h3 id="Ⅱ-存储空间的管理">Ⅱ 存储空间的管理</h3><h4 id="位示图">位示图</h4><p>位示图是一种常见的空闲空间的管理方法，它通过在外存上建立一张位示图来记录文件存储器的使用情况。</p><div class="center"><style>.lwsongmswgms{}</style><img src="/2025/04/28/note33/note33_pic26.png" class="lwsongmswgms"></div><p>其中，每一个<strong>字</strong>对应的是文件存储器中的连续的物理块。假如当前的计算机系统的字长为32位，那么第0字就代表了0~31号物理块，第1字就代表了32~63号物理块，以此类推。而物理块上填写的0、1即为其空闲与否的状态。</p><hr><div class="center"><style>.blcpbcmrmrbo{}</style><img src="/2025/04/28/note33/note33_pic27.png" class="blcpbcmrmrbo"></div><p><strong>B</strong>，简单计算，不再赘述。</p><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>软件设计师教程（第五版）. (2018).<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <summary type="html">软考中级备考笔记</summary>
    
    
    
    <category term="软考" scheme="http://example.com/categories/%E8%BD%AF%E8%80%83/"/>
    
    <category term="软件设计师" scheme="http://example.com/categories/%E8%BD%AF%E8%80%83/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/"/>
    
    <category term="上午题" scheme="http://example.com/categories/%E8%BD%AF%E8%80%83/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/%E4%B8%8A%E5%8D%88%E9%A2%98/"/>
    
    
    <category term="软考" scheme="http://example.com/tags/%E8%BD%AF%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>软件设计师 上午题 设计模式</title>
    <link href="http://example.com/2025/04/27/note32/"/>
    <id>http://example.com/2025/04/27/note32/</id>
    <published>2025-04-27T11:32:14.000Z</published>
    <updated>2025-05-08T08:27:09.560Z</updated>
    
    <content type="html"><![CDATA[<style>.center {  width: auto;  display: table;  margin-left: auto;  margin-right: auto;}</style><h1>软件设计师 上午题 设计模式</h1><blockquote><p>每一个模式描述了一个在我们周围不断重复发生的问题，以及该问题的解决方案的核心。这样，你就能一次又一次地使用该方案而不必做重复劳动。<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="软件设计师教程（第五版）. (2018).">[1]</span></a></sup></p></blockquote><p>设计模式提供了相关问题的解决方案，使得人们可以更加简单方便地复用成功的设计和体系结构，其中一般有以下4个基本要素：</p><ol><li>模式名称：一个助记名，用一两个词来描述模式的问题、解决方案和效果。</li><li>问题：问题描述了应该在何时使用模式。</li><li>解决方案：解决方案描述了设计的组成成分、它们之间的相互关系以及各自的职责和协作方式。</li><li>效果：效果描述了模式应用的效果以及使用模式应权衡的问题。</li></ol><p>而总的来说，设计模式部分的内容可以按着下面这个表格梳理：</p><div class="center"><style>.onemtbdrodvj{}</style><img src="/2025/04/27/note32/note32_pic01.png" class="onemtbdrodvj"></div><h2 id="一、创建型设计模式">一、创建型设计模式</h2><p>创建型设计模式的侧重点为对象创建机制，也就是说通过控制对象的创建方式来提升代码的灵活性和可复用性。</p><blockquote><p>因此，创建型模式在什么被创建，谁创建它，它是怎样被创建的，以及何时创建这些方面给予了很大的灵活性。它们允许用结构和功能差别很大的“产品”对象配置一个系统。配置可以是静态的(即在编译时指定)，也可以是动态的(在运行时)。<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="软件设计师教程（第五版）. (2018).">[1]</span></a></sup></p></blockquote><p>一般来说，创建型设计模式有以下几种具体的实现方式：</p><h3 id="Ⅰ-工厂模式">Ⅰ 工厂模式</h3><p>工厂模式是最常见的设计模式之一，它提供了一种使得创建对象的过程与使用对象的过程分离的方式，使得用户在创建对象时无需指定要创建的具体类。就如同如果朱博宁去买高铁，它只需要去提车即可，不需要关心高铁是如何制造出来的。工厂模式具体有以下几种：</p><h4 id="1-简单工厂模式">1. 简单工厂模式</h4><p>简单工厂模式不属于GoF 23种设计模式，但它是工厂方法模式实现的基础。简单工厂模式提供一个静态工厂方法，可以根据传入的参数决定创建哪种具体产品类的实例。但这显然违背了开闭原则(Open for extension, closed for modification)，如果要新增产品就要修改工厂逻辑。</p><h4 id="2-工厂方法模式">2. 工厂方法模式</h4><p>和简单工厂模式不同的是，工厂方法模式中定义了一个创建对象的接口，这样一来就满足了开闭原则。</p><div class="center"><style>.wflvkmkvjtqn{}</style><img src="/2025/04/27/note32/note32_pic02.png" class="wflvkmkvjtqn"></div><p>在工厂方法模式当中，父类（抽象工厂）只声明创建方法（比如上图中的<code>createProduct()</code>）而不关心具体实现，子类（具体工厂）负责实现父类的创建方法并返回具体的产品实例。</p><h4 id="3-抽象工厂模式">3. 抽象工厂模式</h4><p>和工厂方法模式当中创建单一产品不同的是，抽象工厂模式当中创建了一个产品家族，即一系列相关或相互依赖的的对象。</p><div class="center"><style>.pfvvrfncfjbb{}</style><img src="/2025/04/27/note32/note32_pic03.png" class="pfvvrfncfjbb"></div><h3 id="Ⅱ-生成器模式">Ⅱ 生成器模式</h3><p>生成器模式的特点是将对象的构造过程与其表示分离，使得同样的构建过程可以创建不同的表示，主要用于分步骤构建复杂对象，其结构如下所示：</p><div class="center"><style>.rfnngxohyttk{}</style><img src="/2025/04/27/note32/note32_pic05.png" class="rfnngxohyttk"></div><h3 id="Ⅲ-原型模式">Ⅲ 原型模式</h3><p>原型模式的核心思想是通过复制现有对象（原型）来创建新对象，而不是通过<code>new</code>实例化。因此原型模式可以基于克隆快速生成对象，避免重复执行耗时的初始化操作。其结构如下所示：</p><div class="center"><style>.tmnvtztjxsnx{}</style><img src="/2025/04/27/note32/note32_pic07.png" class="tmnvtztjxsnx"></div><h3 id="Ⅳ-单例模式">Ⅳ 单例模式</h3><p>单例模式确保一个类中只有一个实例，并提供一个全局访问点。它通过控制实例化过程，避免重复创建对象，节省资源。其结构如下所示：</p><div class="center"><style>.gnkhgyodtcpr{}</style><img src="/2025/04/27/note32/note32_pic08.png" class="gnkhgyodtcpr"></div><h3 id="Ⅴ-真题赏析">Ⅴ 真题赏析</h3><div class="center"><style>.hreeljmkmwjq{}</style><img src="/2025/04/27/note32/note32_pic06.png" class="hreeljmkmwjq"></div><p><strong>ACAD</strong>，对于（45）而言，所谓的<code>构造一个使用Builder接口的对象</code>指的就是控制整个流程的类，是<strong>Director(指挥者)</strong>，那么对于本题而言就是Waiter。此外，对于（47）而言，Builder模式适用于：1）创建复杂对象的算法应该独立于该对象的组成部分以及装配方式时；2）当构造过程必须允许被构造对象有不同的表示时。</p><h2 id="二、结构型设计模式">二、结构型设计模式</h2><p>结构型设计模式是一类用于处理对象组合和关系的设计模式，其重点解决：1）如何组合类和对象以形成更大的结构；2）如何简化对象间的依赖关系，提升灵活性和可扩展性。<br>结构型设计模式有以下七种经典模式：</p><h3 id="Ⅰ-适配器模式">Ⅰ 适配器模式</h3><p>适配器模式的核心思想是通过一个中间层（适配器）来解决接口不匹配的问题，类似于电源插头转换器的角色。它用于将不兼容的接口转换为客户端期望的接口，使原本无法协同工作的类能够一同工作。适配器模式的结构如下所示：</p><div class="center"><style>.oupiiiiqkcrl{}</style><img src="/2025/04/27/note32/note32_pic09.png" class="oupiiiiqkcrl"></div><h3 id="Ⅱ-桥接模式">Ⅱ 桥接模式</h3><p>桥接模式的核心思想是通过组合代替继承，解决多层继承带来的类爆炸问题，提升系统的灵活性和可扩展性。这使得桥接模式可以将抽象部分和实现部分分离，使得它们可以独立变化。桥接模式的结构如下所示：</p><div class="center"><style>.mythtcjdxevm{}</style><img src="/2025/04/27/note32/note32_pic10.png" class="mythtcjdxevm"></div><p>其中，抽象是系统的高级控制逻辑，定义客户端直接使用的接口和行为。抽象并不关心具体实现细节，而是通过组合持有一个实现的引用。而实现则是系统的底层核心操作，独立于抽象，可以自由变化或者替换。</p><h3 id="Ⅲ-组合模式">Ⅲ 组合模式</h3><p>假如现在有这么一个公司组织结构：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs txt">CEO<br>├── 技术部<br>│   ├── 开发组<br>│   │   ├── 程序员A（叶子）<br>│   │   └── 程序员B（叶子）<br>│   └── 测试组<br>│       └── 测试员X（叶子）<br>└── 财务部<br>    └── 会计Y（叶子）<br></code></pre></td></tr></table></figure><p>在组合模式当中，无论是部门（容器节点）还是员工（叶子结点），都可以被统一看作“公司成员”。它们之间的区别是叶子结点直接实现基础行为，而容器节点除了自身行为之外还可以递归调用子节点的方法。例如在计算全公司人数时，只需要让每个“公司成员”返回自己的人数并进行递归累加即可，无需区分部门还是员工。<br>这就是组合模式，它会将对象组合成树形结构以表示“部分-整体”的层次关系，使得用户对单个对象和组合对象的使用具有一致性。其结构如下图所示：</p><div class="center"><style>.jstyrybefdgy{}</style><img src="/2025/04/27/note32/note32_pic12.png" class="jstyrybefdgy"></div><h3 id="Ⅳ-装饰器">Ⅳ 装饰器</h3><p>装饰器的核心思想是通过嵌套包装对象来扩展功能，而非通过子类继承。因此，装饰器模式可以用于动态地为对象添加额外职责。其结构如下所示：</p><div class="center"><style>.pjuepmdttlus{}</style><img src="/2025/04/27/note32/note32_pic14.png" class="pjuepmdttlus"></div><h3 id="Ⅴ-外观模式">Ⅴ 外观模式</h3><p>外观模式的核心思想是用一个高层接口包装一组接口，让客户端只需调用一个简单方法就能完成复杂功能。这样一来就可以为复杂的子系统提供一个统一的简化接口，隐藏内部细节，降低客户端与子系统的耦合度。外观模式的结构如下图所示：</p><div class="center"><style>.xqhitxvgbyjl{}</style><img src="/2025/04/27/note32/note32_pic15.png" class="xqhitxvgbyjl"></div><p>其中，Facade知道哪些子系统类复制处理请求，会将客户的请求代理给适当的子系统对象。</p><h3 id="Ⅵ-享元模式">Ⅵ 享元模式</h3><p>享元模式的核心思想是分离对象的固有状态（共享）和外部状态（非共享），从而通过共享技术高效地支持大量细粒度对象的复用，进而减少内存占用和对象创建开销。享元模式的结构如下图所示：</p><div class="center"><style>.kzcmwxtpisih{}</style><img src="/2025/04/27/note32/note32_pic17.png" class="kzcmwxtpisih"></div><p>例如在一款射击游戏当中需要渲染大量子弹，对于每颗子弹而言有以下属性：</p><ul><li>固有状态（共享）：纹理图片、颜色、伤害值等（所有子弹相同）。</li><li>外部状态（非共享）：位置坐标、飞行角度等（每颗子弹不同）。</li></ul><p>享元模式就是共享相同纹理的子弹对象来解决内存消耗过大的问题。</p><h3 id="Ⅶ-代理模式">Ⅶ 代理模式</h3><p>代理模式通过创建一个代理对象来控制对原始对象的访问，在不改变原始类的情况下增强功能。代理模式的核心思想是由“代理”充当中间人，在客户端和目标对象之间插入一层，用于添加额外逻辑。其结构如下图所示：</p><div class="center"><style>.ubbugqxwszvu{}</style><img src="/2025/04/27/note32/note32_pic18.png" class="ubbugqxwszvu"></div><h3 id="Ⅷ-真题赏析">Ⅷ 真题赏析</h3><div class="center"><style>.imbfhovydsxw{}</style><img src="/2025/04/27/note32/note32_pic11.png" class="imbfhovydsxw"></div><p><strong>CDAB</strong>，桥接模式适用于：</p><ol><li>不希望在抽象和它的实现部分之间有一个固定的绑定关系。</li><li>类的抽象以及它的实现都应该可以通过生成子类的方法加以扩充。</li><li>对一个抽象的实现部分的修改应对客户不产生影响，即客户代码不必重新编译。</li><li>(C++)想对客户完全隐藏抽象的实现部分。</li><li>有许多类要生成的类层次结构。</li><li>想在多个对象间共享实现(可能使用引用计数)，但同时要求客户并不知道这一点。</li></ol><hr><div class="center"><style>.ipydwvppbgyj{}</style><img src="/2025/04/27/note32/note32_pic16.png" class="ipydwvppbgyj"></div><p><strong>CD</strong>，对于（45）题的A选项而言，这是<strong>责任链模式</strong>的适用情况。</p><h2 id="三、行为型设计模式">三、行为型设计模式</h2><p>行为型设计模式是设计模式当中的最后一大类，和先前介绍的注重于对象创建机制的创建型设计模式、注重于对象组合和关系的结构型设计模式不同的是，行为型设计模式专注于对象之间的交互方式和算法的封装。这类设计模式不关注对象如何创建或者组合，而是<strong>定义对象如何协作完成任务</strong>。</p><p>常见的行为型设计模式有以下11种（死…）：</p><h3 id="Ⅰ-责任链模式">Ⅰ 责任链模式</h3><p>责任链使得多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。它允许用户将请求沿着处理链传递，直到有一个处理者能够处理它。其结构如下图所示：</p><div class="center"><style>.orjywrbtlkii{}</style><img src="/2025/04/27/note32/note32_pic19.png" class="orjywrbtlkii"></div><h3 id="Ⅱ-命令模式">Ⅱ 命令模式</h3><p>命令模式将请求封装为独立的对象（命令），允许用户参数化客户端（调用者）与接收者（执行者），从而支持请求的排队、撤销、日志记录等操作。其结构如下图所示：</p><div class="center"><style>.skqlhqsuclwx{}</style><img src="/2025/04/27/note32/note32_pic20.png" class="skqlhqsuclwx"></div><h3 id="Ⅲ-解释器模式">Ⅲ 解释器模式</h3><p>解释器模式的核心思想是“将语言种的每个语法规则表示为一个类，通过组合这些类来构建语法树，最终解释执行”。因此这种设计模式可以用于定义一种语言的语法规则，并提供一个解释器来解释该语言中的表达式。其结构如下图所示：</p><div class="center"><style>.tsnqkhqnyflp{}</style><img src="/2025/04/27/note32/note32_pic21.png" class="tsnqkhqnyflp"></div><h3 id="Ⅳ-迭代器模式">Ⅳ 迭代器模式</h3><p>迭代器模式提供一种方法顺序访问聚合对象（列表、树等）中的元素，而不需要暴露该对象的内部表示，这实际上是将遍历逻辑从聚合对象中分离出来了。这种设计模式的结构如下所示：</p><div class="center"><style>.wtgivtbypojq{}</style><img src="/2025/04/27/note32/note32_pic22.png" class="wtgivtbypojq"></div><h3 id="Ⅴ-中介者模式">Ⅴ 中介者模式</h3><p>中介者模式的核心思想是“使用一个中介者来封装一系列对象之间的交互，使各个对象不需要显式地相互引用”，即通过引入中介对象来集中管理多个对象之间的交互，从而减少对象间的直接耦合，使系统更易于维护和扩展。这种设计模式的结构如下图所示：</p><div class="center"><style>.slqtneewnoys{}</style><img src="/2025/04/27/note32/note32_pic23.png" class="slqtneewnoys"></div><h3 id="Ⅵ-备忘录模式">Ⅵ 备忘录模式</h3><p>备忘录模式的核心思想是“在不暴露对象实现细节的情况下，保存和恢复其内部状态”，它允许在不破坏封装性的前提下捕获并外部化对象的内部状态，以便后续可以恢复到该状态。其结构如下图所示：</p><div class="center"><style>.wwqjprlynvam{}</style><img src="/2025/04/27/note32/note32_pic24.png" class="wwqjprlynvam"></div><h3 id="Ⅶ-观察者模式">Ⅶ 观察者模式</h3><p>在观察者模式当中定义了对象间的一对多依赖关系，当一个对象（主题）状态改变时，所有依赖它的对象（观察者）都会自动收到通知并更新。其结构如下图所示：</p><div class="center"><style>.hcihjhenhhah{}</style><img src="/2025/04/27/note32/note32_pic25.png" class="hcihjhenhhah"></div><h3 id="Ⅷ-状态模式">Ⅷ 状态模式</h3><p>状态模式的核心为：同一个动作在不同状态下有不同的表现。例如日常用的台灯，正常状态下按开关出现的是白光，护眼模式下同样按开关出现的却是黄光。</p><blockquote><p>（状态模式）允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它的类。<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="软件设计师教程（第五版）. (2018).">[1]</span></a></sup></p></blockquote><p>状态模式的结构如下图所示：</p><div class="center"><style>.yfvtmlvizbis{}</style><img src="/2025/04/27/note32/note32_pic26.png" class="yfvtmlvizbis"></div><h3 id="Ⅸ-策略模式">Ⅸ 策略模式</h3><p>策略模式是一种将算法抽离出来的设计模式，它定义一系列算法（策略）​​，并将每个算法封装成独立类，使它们可以​​互相替换​​，且算法的变化不影响使用它的客户端。该模式的结构如下图所示：</p><div class="center"><style>.cjgrxvrbutqh{}</style><img src="/2025/04/27/note32/note32_pic27.png" class="cjgrxvrbutqh"></div><h3 id="Ⅹ-模板方法">Ⅹ 模板方法</h3><p>模板方法模式的核心思想为：“在不改变算法结构的情况下，允许子类重写算法的特定步骤”，这就类似于我们在按照食谱做一道菜的时候，大致的步骤是固定的，但其中诸如撒盐多少的细节就可以根据个人喜好进行调整。也就是说，模板方法模式在父类当中定义算法的骨架，而将某些步骤的具体实现延迟到子类当中完成，其结构如下图所示：</p><div class="center"><style>.umgvdfqzllvx{}</style><img src="/2025/04/27/note32/note32_pic28.png" class="umgvdfqzllvx"></div><h3 id="XI-访问者模式">XI 访问者模式</h3><p><em><s>最后一个！！！</s></em></p><p>访问者模式适用于对象结构稳定但需要频繁新增操作的场景，它可以将数据结构和数据操作分离，允许在不修改对象类的前提下，让新增操作像“访问者”一样灵活接入。这种设计模式的结构如下图所示：</p><div class="center"><style>.bhglqaosnzwn{}</style><img src="/2025/04/27/note32/note32_pic29.png" class="bhglqaosnzwn"></div><h2 id="三、真题赏析">三、真题赏析</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>软件设计师教程（第五版）. (2018).<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <summary type="html">软考中级备考笔记</summary>
    
    
    
    <category term="软考" scheme="http://example.com/categories/%E8%BD%AF%E8%80%83/"/>
    
    <category term="软件设计师" scheme="http://example.com/categories/%E8%BD%AF%E8%80%83/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/"/>
    
    <category term="上午题" scheme="http://example.com/categories/%E8%BD%AF%E8%80%83/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/%E4%B8%8A%E5%8D%88%E9%A2%98/"/>
    
    
    <category term="软考" scheme="http://example.com/tags/%E8%BD%AF%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>软件设计师 下午题 试题三 UML分析与设计</title>
    <link href="http://example.com/2025/04/26/note31/"/>
    <id>http://example.com/2025/04/26/note31/</id>
    <published>2025-04-26T15:21:03.000Z</published>
    <updated>2025-05-08T08:27:06.869Z</updated>
    
    <content type="html"><![CDATA[<style>.center {  width: auto;  display: table;  margin-left: auto;  margin-right: auto;}</style><h1>软件设计师 下午题 试题三 UML分析与设计</h1><p>试题三考察的内容依旧是UML，没有什么新的知识点的引入，在下午题的学习当中就以做题的形式简单熟悉一下。</p><h3 id="1-2016年上半年">1. 2016年上半年</h3><div class="center"><style>.ffwbhnehiynd{}</style><img src="/2025/04/26/note31/note31_pic01.jpg" class="ffwbhnehiynd"></div><ul><li>【问题1】<strong>U1/U2: Run, Step; U3: Write; U4/U5/U6: Move, Left, Read</strong>。</li><li>【问题2】<strong>U1, U2和Run Program有泛化关系; U3, U4, U5, U6和Select Robot有扩展关系</strong>。首先需要注意的是，图3-2是一张用例图，而在用例图当中，只有包含、扩展和泛化三种关系。而用例U1和U2是用例Run Program的继承且表现出更特别的行为，所以它们之间是泛化关系；用例U3~U6是用例Select Robot中独立且可选的行为，是扩展关系。</li><li>【问题3】<strong>C1：文件；C2：机器人在虚拟世界中的行为；C3：Instruction；C4：Instruction Set；C5：仿真系统</strong>。</li></ul><h3 id="2-2015年上半年">2. 2015年上半年</h3><div class="center"><style>.moydivdceqzi{}</style><img src="/2025/04/26/note31/note31_pic02.jpg" class="moydivdceqzi"></div><ul><li>【问题1】<strong>(1) C5; (2) C9; (3) C7; (4) C6; (5)(6) C8, C10; (7) C2</strong>。需要注意的是，C7和C9并不能交换位置。C7和C9都有指向C5的泛化关系不难理解，但是C9和C5之间应该还会有一层聚合关系，也就是说C5可以包含多个C9，这与题干中的“多个团体可以组成一个新的团体”的题意是相符的。</li><li>【问题2】<strong>M1: C5; M2: C2; M3: C3; M4: C3; M5: C3; M6: C8; M7: C10; M8: C10; M9: C12; M10: C1</strong>。</li><li>【问题3】<strong>组合模式，在本题中由于拍卖者分为个人拍卖者和团体拍卖者两种，而团体也可以组成新的团体参与拍卖活动。这样的整体-部分关系，适合于使用组合模式表达</strong>。</li></ul><h3 id="3-2014年下半年">3. 2014年下半年</h3><div class="center"><style>.gnoejzqlminp{}</style><img src="/2025/04/26/note31/note31_pic03.jpg" class="gnoejzqlminp"></div><ul><li>【问题1】<strong>C1: Address; C2: Riding; C3: Ineligible; C4: Eligible</strong>。</li><li>【问题2】<strong>M1: 1; M2: *; M3: *; M4: 1; M5: *; M6: 1</strong>。</li><li>【问题3】<strong>将M1和M4修改为1…</strong>*。</li></ul>]]></content>
    
    
    <summary type="html">软考中级备考笔记</summary>
    
    
    
    <category term="软考" scheme="http://example.com/categories/%E8%BD%AF%E8%80%83/"/>
    
    <category term="软件设计师" scheme="http://example.com/categories/%E8%BD%AF%E8%80%83/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/"/>
    
    <category term="下午题" scheme="http://example.com/categories/%E8%BD%AF%E8%80%83/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/%E4%B8%8B%E5%8D%88%E9%A2%98/"/>
    
    
    <category term="软考" scheme="http://example.com/tags/%E8%BD%AF%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>Git “bad config line 1 in file .git/config”报错的解决方案</title>
    <link href="http://example.com/2025/04/24/md02/"/>
    <id>http://example.com/2025/04/24/md02/</id>
    <published>2025-04-24T05:43:19.000Z</published>
    <updated>2025-05-06T11:46:48.829Z</updated>
    
    <content type="html"><![CDATA[<style>.center {  width: auto;  display: table;  margin-left: auto;  margin-right: auto;}</style><h1>Git “bad config line 1 in file .git/config”报错的解决方案</h1><p>昨天晚上下了自习之后准备把笔记到Hexo上然后回寝室睡大觉，结果出现了以下报错：</p><div class="center"><style>.ctfvfiwpcpyl{}</style><img src="/2025/04/24/md02/md02_pic01.png" class="ctfvfiwpcpyl"></div><p>其实之前也出现过一次这样的情况，但是当时什么动作也没做重新第二遍尝试<code>hexo d</code>就提交成功了，加上搜了一些技术文档看到有人说只是网络问题所以就没放在心上继续回去睡大觉了。<br><br>但是今天早上起来再尝试deploy的时候依旧出现同样的报错，这下开始发现应该是哪个配置文件出现了问题，下面是花两节课摸索出来的解决方案：</p><h3 id="1-删除-hexo-deploy-git">1. 删除/hexo/.deploy_git</h3><div class="center"><style>.bovtyjbfdbwc{}</style><img src="/2025/04/24/md02/md02_pic02.png" class="bovtyjbfdbwc"></div><p>我的本地代码库如上图所示，我最开始找<code>config</code>文件时一直找的就是<code>/.git</code>文件夹中的<code>config</code>文件。但是不论我用记事本打开这个文件还是用<code>$ vi .git/config</code>检查这个文件其中的内容都一切正常。<br><br>后来也反复尝试过删除<code>/.git/config</code>文件，再使用<code>$ git init</code>命令恢复它也无济于事。<br><br>直到我突然发现<code>.deploy_git</code>文件夹中也有一个<code>.git</code>文件夹，并且其中也有一个<code>config</code>文件，并且打开之后其内容是一片空白！<br><br>那么也许这就是问题所在了，于是我尝试删除了<code>/hexo/.deploy_git</code>。</p><h3 id="2-使用管理员模式运行Git-Bash">2. 使用管理员模式运行Git Bash</h3><p>在删除目标文件夹之后我重新尝试了<code>$ hexo d</code>命令，但是提示错误信息为没有足够的权限：</p><div class="center"><style>.xktmieytwcyc{}</style><img src="/2025/04/24/md02/md02_pic05.png" class="xktmieytwcyc"></div><br><p>那么就需要使用管理员模式运行<code>Git Bash</code>了，按下图图示操作即可：<br></p><br><div class="center"><style>.rlcjzwxnckfm{}</style><img src="/2025/04/24/md02/md02_pic03.png" class="rlcjzwxnckfm"></div><br><p>随后就能正常递交文档了：</p><br><div class="center"><style>.utrznfgadwkc{}</style><img src="/2025/04/24/md02/md02_pic04.png" class="utrznfgadwkc"></div>]]></content>
    
    
    <summary type="html">hexo无法成功提交的解决方案</summary>
    
    
    
    <category term="疑难杂症解决方案" scheme="http://example.com/categories/%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    
    
  </entry>
  
  <entry>
    <title>软件设计师 上午题 UML</title>
    <link href="http://example.com/2025/04/24/note30/"/>
    <id>http://example.com/2025/04/24/note30/</id>
    <published>2025-04-24T05:30:30.000Z</published>
    <updated>2025-05-08T08:27:03.183Z</updated>
    
    <content type="html"><![CDATA[<style>.center {  width: auto;  display: table;  margin-left: auto;  margin-right: auto;}</style><h1>软件设计师 上午题 UML</h1><p>统一建模语言(Unified Modeling Language, UNL)是一种面向对象软件的标准化建模语言，其简单、统一且富有表达力，目前已经成为可视化建模语言事实上的工业标准。<br>UML的词汇表中包含了3种构造块：事物、关系和图。事物是对模型种最具有代表性的成分的抽象；关系将事物联系在了一起；图则聚集了相关的事物。下面我们将逐一了解这些构造块：</p><h2 id="一、事物">一、事物</h2><p>UML中有四种事物：结构事物、行为事物、分组事物和注释事物：</p><h4 id="1-结构事物">1. 结构事物</h4><p>结构事物通常是模型中的静态部分，用来描述概念或者物理元素，各种结构事物的图形化表示如下图所示：</p><div class="center"><style>.nqvltmuwgppe{}</style><img src="/2025/04/24/note30/note30_pic01.png" class="nqvltmuwgppe"></div><h4 id="2-行为事物">2. 行为事物</h4><p>行为事物通常是模型中的动态部分，用来描述跨越时间和空间的行为，其图形化表示如下图所示：</p><div class="center"><style>.februbwkmbjj{}</style><img src="/2025/04/24/note30/note30_pic02.png" class="februbwkmbjj"></div><h4 id="3-分组事物">3. 分组事物</h4><p>分组事物是UML模型中的组织部分，是一些由模型分解成的“盒子”。在应用中最主要的分组事物是包(Package)，它能够将元素组织起来，绝大分事物都可以放进包内。包的图形化表示如下图所示：</p><div class="center"><style>.dwxthknmlyds{}</style><img src="/2025/04/24/note30/note30_pic03.png" class="dwxthknmlyds"></div><h4 id="4-注释事物">4. 注释事物</h4><p>这种事物的概念不难理解，而注解(Note)是其中比较重要的一种注释事物，其图形化表示如下图所示：</p><div class="center"><style>.zjebmbphizey{}</style><img src="/2025/04/24/note30/note30_pic04.png" class="zjebmbphizey"></div><h2 id="二、关系">二、关系</h2><p>UML当中有四种关系：依赖、关联、泛化和实现。</p><h3 id="Ⅰ-概念了解">Ⅰ 概念了解</h3><h4 id="1-依赖">1. 依赖</h4><p>在依赖关系中，一个事物（独立事物）发生变化会影响另一个事物（依赖事物）的语义，其图形化表示如下图所示：</p><div class="center"><style>.udqeizyoisud{}</style><img src="/2025/04/24/note30/note30_pic05.png" class="udqeizyoisud"></div><p>当出现<code>A --------&gt; B</code>时，A是<code>依赖事物</code>，B是<code>独立事物</code>。<br>需要注意的是，依赖关系是单向的且是临时的，仅表示依赖事物需要独立事物，反之不成立。依赖可以体现在代码中的参数传递、局部变量、静态方法调用等场景。</p><h4 id="2-关联">2. 关联</h4><p>当两个对象之间被连接起来，它们就构成了关联关系，如下图所示：</p><div class="center"><style>.hkkcglylgaml{}</style><img src="/2025/04/24/note30/note30_pic06.png" class="hkkcglylgaml"></div><p>不难发现，在关联上还可以标注重复度(Multiplicity)和角色(Role)，其中重复度指的就是参与关联的对象数量关系。<br><br>此外，还有两种特殊的关联，即聚集和组合，它们都描述的是整体和部分之间的结构关系，但是也略有不同：<br>i.  聚集：部分和整体的生命周期不一致，整体消失了，部分仍然存在。例如员工和公司。<br>ii. 组合：部分和整体的生命周期一致，整体消失了，部分也就消失了。例如部门和公司。</p><div class="center"><style>.sdwtxfnfrqlb{}</style><img src="/2025/04/24/note30/note30_pic07.png" class="sdwtxfnfrqlb"></div><p>此外还有一种单向关联的情况，类似于<code>A ——&gt; B</code>，它和依赖关系<code>A ---&gt; B</code>的区别就在于前者不是临时的但后者是临时的。例如<code>人 ——&gt; 氧气</code>和<code>人 ---&gt; 食物</code>。</p><h4 id="3-泛化">3. 泛化</h4><p>即继承，它由特殊元素（子元素）指向一般元素（父元素）。用这种方法，子元素就可以共享父元素的结构和行为。例如猫泛化动物、狗泛化动物等。</p><div class="center"><style>.bwsdcmcxtwqg{}</style><img src="/2025/04/24/note30/note30_pic08.png" class="bwsdcmcxtwqg"></div><h4 id="4-实现">4. 实现</h4><p>实现是类元之间的语义关系，其中一个类元指定了另一个类元保证执行的契约。</p><div class="center"><style>.enfbgovetgae{}</style><img src="/2025/04/24/note30/note30_pic09.png" class="enfbgovetgae"></div><h3 id="Ⅱ-真题赏析">Ⅱ 真题赏析</h3><div class="center"><style>.fywisonwulhi{}</style><img src="/2025/04/24/note30/note30_pic10.png" class="fywisonwulhi"></div><p><strong>A</strong>，关联关系和泛化关系的区别在于，虽然它们都是特殊和一般之间的关系，但是关联关系是对象之间的关系，但是泛化是类之间的关系。</p><hr><div class="center"><style>.fmhwogpoxvzl{}</style><img src="/2025/04/24/note30/note30_pic11.png" class="fmhwogpoxvzl"></div><p><strong>D</strong>，两个类之间的关联关系可以有多个，但不能有无限多个，都必须有对应的角色进行标识（如下图所示）。多个关联不必强行聚合成一个，聚合仅是一种特殊的关联。</p><div class="center"><style>.ukjjmpxlactj{}</style><img src="/2025/04/24/note30/note30_pic12.png" class="ukjjmpxlactj"></div><h2 id="三、图">三、图</h2><p>在UML当中，图是一组元素的图形表示，我们一般情况下会将图画成事物和弧的连通图，而常见的图有以下几类：<br></p><p><em>注：由于这个板块的知识点比较零碎，不再单独设置<strong>真题赏析</strong>模块，真题将直接附在每个子模块后边。</em></p><h3 id="Ⅰ-类图">Ⅰ 类图</h3><p>类图是面向对象系统的建模中所建立的最常见的图，一般来说，一个类图中的内容即为类和类之间的依赖、泛化和关联关系。</p><div class="center"><style>.rxhziyytpwwj{}</style><img src="/2025/04/24/note30/note30_pic13.png" class="rxhziyytpwwj"></div><hr><ol><li>2015年下半年：</li></ol><div class="center"><style>.crkbhwucyhqx{}</style><img src="/2025/04/24/note30/note30_pic14.png" class="crkbhwucyhqx"></div><p><strong>B</strong>，继承和覆盖的区别在于前者是一种复用，而后者则是一种重新实现。在本题当中，显然在<code>Car</code>类和<code>Boat</code>类当中的<code>+move()</code>函数并不是同一种函数，也就是说它们不可能都是对<code>Transport</code>类中<code>+move()</code>函数的继承，那么只能是为了实现多态而重新实现该函数了。</p><hr><ol start="2"><li>2020年下半年：</li></ol><div class="center"><style>.wjlhcgdtyvlv{}</style><img src="/2025/04/24/note30/note30_pic15.png" class="wjlhcgdtyvlv"></div><p><strong>D</strong>，我们首先需要搞清楚什么是直接对象什么是非直接对象，直接对象是指直接从某个类中实例化的对象，而非直接对象则是指通过继承或者关联关系间接属于某个类的对象。对于本题中的A类，它是一个抽象类，抽象类是无法进行实例化的，也就是说A1和A2是A类的非直接对象。那么D选项中所谓的“A的直接对象”根本就不存在，错误。</p><h3 id="Ⅱ-对象图">Ⅱ 对象图</h3><p>对象图展现的是某一时刻的一组对象以及它们之间的关系，描述了在类图中所建立的事物的实例的静态快照，其中一般包括的有对象和链。</p><div class="center"><style>.ywmlccgpctvf{}</style><img src="/2025/04/24/note30/note30_pic16.png" class="ywmlccgpctvf"></div><h3 id="Ⅲ-用例图">Ⅲ 用例图</h3><p>用例图是UML当中用于描述系统功能需求和用户交互的静态视图，其核心关注点在于参与者和系统功能之间的关系。</p><div class="center"><style>.sybozwndjcul{}</style><img src="/2025/04/24/note30/note30_pic17.png" class="sybozwndjcul"></div><p>可以注意到的是，在用例图当中还包含了三种关系，这三种关系是用来描述用例和用例之间的交互逻辑的：</p><ul><li>包含关系：表示一个用例必须调用另一个用例的功能，属于强依赖关系。</li><li>扩展关系：表示一个用例在特定条件下扩展另一个用例的功能，属于可选依赖。</li><li>泛化关系：表示用例之间的继承关系，子用例继承父用例的行为并扩展。</li></ul><p>需要注意的是，包含关系和扩展关系再用例图当中的线条是一样的，区分它们的依据是虚线旁边的<code>&lt;&lt;extend&gt;&gt;</code>或者<code>&lt;&lt;include&gt;&gt;</code>。</p><h3 id="Ⅳ-交互图">Ⅳ 交互图</h3><p>交互图是UML中用于描述​​对象间动态交互行为​​的图表，根据不同的目的又可划分为序列图和通信图。</p><h4 id="1-序列图">1. 序列图</h4><p>序列图是场景(Scenario)的图形化表示，描述了以时间顺序组织的对象之间的交互活动，如下图所示。</p><div class="center"><style>.onoitbhitiwb{}</style><img src="/2025/04/24/note30/note30_pic18.png" class="onoitbhitiwb"></div><p>在序列图当中，我们一般把参加交互的对象放在图的上方（发起交互的对象在左，下级对象在右），然后把这些对象发送和接收的消息沿垂直方向按时间顺序从上到下放置。这样一来我们就得到了控制流随时间的可视化轨迹。<br>序列图当中还有两个特征：</p><ul><li>对象生命线：在序列图当中用一根垂直的虚线来表示一个对象在一段时间内的存在。</li><li>控制焦点：在序列图当中用一个瘦高的矩形来表示一个对象执行一个动作所经历的时间段。</li></ul><hr><ol><li>2013年下半年：</li></ol><div class="center"><style>.kmzaojivcyzg{}</style><img src="/2025/04/24/note30/note30_pic19.png" class="kmzaojivcyzg"></div><p><strong>CB</strong>，首先要注意的是，在此题当中除了用虚线表示的<code>evaluation()</code>函数是返回消息之外，其余的四种函数都是同步消息。而一条从A指向B的同步消息的本质是A要求B执行一个明确的操作，也就意味着如果对象A向对象B发送一条同步消息则对象B必须实现该方法。根据此原则不难发现，除了<code>check()</code>函数需要<code>Person</code>类来实现之外，其余的几种函数都需要<code>Account</code>类来实现。</p><h4 id="2-通信图">2. 通信图</h4><p>通信图在早期的版本中也被称作协作图，强调的是参加交互的对象的组织关系，如下图所示：</p><div class="center"><style>.yjcsyevahynu{}</style><img src="/2025/04/24/note30/note30_pic20.png" class="yjcsyevahynu"></div><p>通信图中有两个特性：</p><ul><li>通信图中有路径：通信图当中用实线连接两个对象来表示对象之间存在的交互关联关系。</li><li>通信图中有顺序号：通信图中每个新消息前都有一个数字前缀，用于表示消息的时间顺序。</li></ul><p><strong>不难发现，序列图和通信图是同构的，它们之间可以互相转换。</strong></p><h3 id="Ⅴ-状态图">Ⅴ 状态图</h3><p>状态图展现了一个状态机，用来描述对象生命周期内状态变化，专注于展示对象如何响应事件并在不同状态间转换，如下图所示：</p><div class="center"><style>.rewwsbamtcsf{}</style><img src="/2025/04/24/note30/note30_pic21.png" class="rewwsbamtcsf"></div><p>状态图当中包含了以下四个比较重要的概念：</p><ol><li>状态：状态指的是对象在生命周期中的稳定条件，在特定时间段内保持属性值和行为不变。其中，●表示开始，⚪表示结束。如果一个状态当中还包含一个子状态，那么我们称这个状态为组合状态，或者为超状态。</li><li>活动：活动指的是对象在特定状态中持续执行的行为。<ol><li>入口活动(entry)：进入状态，立即执行。</li><li>执行活动(do)：占有有限时间，可以中断。</li><li>出口活动(exit)：退出状态，立即执行。</li></ol></li><li>转换：转换指的是状态间的有向跳转，由事件触发并可能伴随条件和动作。此外，在转移过程中存在一个被称为“监护条件”的布尔值，用<code>[]</code>表示，如果存在监护条件，只有其为真值时才能触发转换。</li><li>事件：事件指的是触发状态转换的离散发生的事宜。</li></ol><hr><ol><li>2013年上半年：</li></ol><div class="center"><style>.vesllkszflat{}</style><img src="/2025/04/24/note30/note30_pic22.png" class="vesllkszflat"></div><p><strong>C</strong>，这道题的难点在于如何区分选项C和选项D。我们首先需要明白的是，当对象处于某种状态时，这个状态被称之为激活状态，只有从激活状态出发才能进行转换。对于C选项，事件e2的激活状态只有状态B中嵌套的子状态B2，会发生转换的情况应该如选项B描述的那样；而对于D选项，事件e1的激活状态是整个状态B，也就是说不论是B1、B2、B3抑或是B4都是激活状态，事件e1一发生就能触发状态转换。</p><hr><ol start="2"><li>2019年下半年</li></ol><div class="center"><style>.vkbqrjywrgub{}</style><img src="/2025/04/24/note30/note30_pic23.png" class="vkbqrjywrgub"></div><p><strong>C</strong>，迁移要包含两个状态。</p><h3 id="Ⅵ-活动图">Ⅵ 活动图</h3><p>活动图是一种特殊的状态图，它展现了在系统内从一个活动到另一个活动的流程，其中一般包括活动状态和动作状态、转换和对象，如下图所示：</p><div class="center"><style>.pcxokndeogfo{}</style><img src="/2025/04/24/note30/note30_pic24.png" class="pcxokndeogfo"></div><hr><ol><li>2013年下半年：</li></ol><div class="center"><style>.kddnlbvghjhj{}</style><img src="/2025/04/24/note30/note30_pic25.png" class="kddnlbvghjhj"></div><p><strong>C</strong>，这里需要弄清除的是UML活动图当中各个符号的含义。1）菱形表示的是流程当中的条件分支，将根据监护条件决定下一步执行的路径。2）黑色粗长条表示的是分叉/汇合结点，其作用是将单一流程拆分为多个<strong>并行执行</strong>的子流程/将子流程合并为单一流程继续执行。</p><h3 id="Ⅶ-构件图">Ⅶ 构件图</h3><p>构件图展现了一组构件之间的组织和依赖关系，它与类图相关，通常把构件映射为一个或多个类、接口或者协作，如下图所示：</p><div class="center"><style>.rpeqkesulvzm{}</style><img src="/2025/04/24/note30/note30_pic26.png" class="rpeqkesulvzm"></div><hr><ol><li>2009年上半年：</li></ol><div class="center"><style>.frqcsyfprozo{}</style><img src="/2025/04/24/note30/note30_pic27.png" class="frqcsyfprozo"></div><p><strong>AB</strong>，在UML组件图当中，供接口和需接口之间的关系就是调用和被调用之间的关系。</p><h3 id="Ⅷ-部署图">Ⅷ 部署图</h3><p>部署图是UML中用于描述​​系统物理架构​​的静态结构图，展示软件组件如何部署到硬件节点（如服务器、设备）上，以及节点间的通信关系，常在<strong>实施阶段</strong>使用，如下图所示：</p><div class="center"><style>.yhaxgpilqqku{}</style><img src="/2025/04/24/note30/note30_pic28.png" class="yhaxgpilqqku"></div><h3 id="Ⅸ-总结">Ⅸ 总结</h3><div class="center"><h1>表3-1 UML各种视图及其主要概念</h1><table><thead><tr><th style="text-align:center">主要的域</th><th style="text-align:center">视图</th><th style="text-align:center">图</th><th style="text-align:center">主要概念</th></tr></thead><tbody><tr><td style="text-align:center"><strong>结构</strong></td><td style="text-align:center">静态视图</td><td style="text-align:center">类图</td><td style="text-align:center">类、关联、泛化、依赖关系、实现、接口</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">用例视图</td><td style="text-align:center">用例图</td><td style="text-align:center">用例、参与者、关联、扩展、包括、用例泛化</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">实现视图</td><td style="text-align:center">构件图</td><td style="text-align:center">构件、接口、依赖关系、实现</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">部署视图</td><td style="text-align:center">部署图</td><td style="text-align:center">节点、构件、依赖关系、实现</td></tr><tr><td style="text-align:center"><strong>动态</strong></td><td style="text-align:center">状态机视图</td><td style="text-align:center">状态图</td><td style="text-align:center">状态、事件、转换、动作</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">活动视图</td><td style="text-align:center">活动图</td><td style="text-align:center">状态、活动、完成转换、分叉、结合</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">交互视图</td><td style="text-align:center">顺序图</td><td style="text-align:center">交互、对象、消息、激活</td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">协作图</td><td style="text-align:center">协作、交互、协作角色、消息</td></tr><tr><td style="text-align:center"><strong>模型管理</strong></td><td style="text-align:center">模型管理视图</td><td style="text-align:center">类图</td><td style="text-align:center">包、子系统、模型</td></tr><tr><td style="text-align:center"><strong>可扩展性</strong></td><td style="text-align:center">所有</td><td style="text-align:center">所有</td><td style="text-align:center">约束、构造型、标记值</td></tr></tbody></table></div>]]></content>
    
    
    <summary type="html">软考中级备考笔记</summary>
    
    
    
    <category term="软考" scheme="http://example.com/categories/%E8%BD%AF%E8%80%83/"/>
    
    <category term="软件设计师" scheme="http://example.com/categories/%E8%BD%AF%E8%80%83/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/"/>
    
    <category term="上午题" scheme="http://example.com/categories/%E8%BD%AF%E8%80%83/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/%E4%B8%8A%E5%8D%88%E9%A2%98/"/>
    
    
    <category term="软考" scheme="http://example.com/tags/%E8%BD%AF%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>软件设计师 下午题 试题二 数据库设计</title>
    <link href="http://example.com/2025/04/23/note29/"/>
    <id>http://example.com/2025/04/23/note29/</id>
    <published>2025-04-23T13:01:43.000Z</published>
    <updated>2025-05-08T08:26:59.063Z</updated>
    
    <content type="html"><![CDATA[<style>.center {  width: auto;  display: table;  margin-left: auto;  margin-right: auto;}</style><h1>软件设计师 下午题 试题二 数据库设计</h1><h2 id="一、问题一">一、问题一</h2><p>问题一一般考察的内容就是ER图中缺失的联系，如下图所示：</p><div class="center"><style>.ykiiwelqcvmn{}</style><img src="/2025/04/23/note29/note29_pic01.png" class="ykiiwelqcvmn"></div><p>以《软件设计师考试同步辅导（下午科目）》中的例题为例：</p><div class="center"><style>.qdljgfcytelm{}</style><img src="/2025/04/23/note29/note29_pic02.png" class="qdljgfcytelm"></div><p>答：<strong>配送员-配送-地点，多对多联系</strong>。</p><h2 id="二、问题二">二、问题二</h2><p>问题二一般考察的是补充关系模式中缺失的属性，依旧以例1为例：</p><div class="center"><style>.oumuiisevckh{}</style><img src="/2025/04/23/note29/note29_pic03.png" class="oumuiisevckh"></div><p>答：<br>（a）<strong>商品数量，仓库信息</strong>；<br>（b）<strong>支付凭证号码</strong>；<br>（c）<strong>商品条码，订单ID</strong>；<br><br><br>作答此题时不能仅仅看ER图进行回答，还要通读题干中的【需求描述】，否则很容易遗失属性信息。此外每一空中不一定只缺失一个属性，需要将所有缺失的属性都补充完整。例如<code>仓库信息</code>的出处就是（5）中的<code>商品所在的仓库信息</code>。</p><h2 id="三、问题三">三、问题三</h2><p>问题三的考察内容不固定，但是一般需要掌握以下知识点，以应对除了修改ER图之外的考点：</p><ol><li>弱实体：弱实体是不能单独存在，必须依赖于其它实体才能存在的实体。弱实体用双线矩形框表示，其与实体的关系用双线菱形表示。</li><li>简单属性：简单属性是指​​不能再分解​​为更小组成部分的属性，它是数据库中最基本的数据单元。简单属性也称为​​原子属性​​，表示一个实体的单一特征。</li><li>规范性问题：按第一范式到第三范式的标准逐一检查是否符合规范，下面来复习一下各个范式的要求：<ol><li>第一范式：表中所有属性都应该是简单属性。</li><li>第二范式：表中不允许存在部分依赖，即非主属性不能依赖于组合主键的一部分。</li><li>第三范式：表中不允许存在传递依赖，即一个非主属性不能依赖于另一个非主属性。</li></ol></li></ol><p>除此之外，最主要的考察内容就是对ER图进行补充和修改，具体情况具体分析即可。</p>]]></content>
    
    
    <summary type="html">软考中级备考笔记</summary>
    
    
    
    <category term="软考" scheme="http://example.com/categories/%E8%BD%AF%E8%80%83/"/>
    
    <category term="软件设计师" scheme="http://example.com/categories/%E8%BD%AF%E8%80%83/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/"/>
    
    <category term="下午题" scheme="http://example.com/categories/%E8%BD%AF%E8%80%83/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/%E4%B8%8B%E5%8D%88%E9%A2%98/"/>
    
    
    <category term="软考" scheme="http://example.com/tags/%E8%BD%AF%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>软件设计师 下午题 试题一 数据流图设计</title>
    <link href="http://example.com/2025/04/23/note28/"/>
    <id>http://example.com/2025/04/23/note28/</id>
    <published>2025-04-23T11:32:38.000Z</published>
    <updated>2025-05-08T08:26:55.535Z</updated>
    
    <content type="html"><![CDATA[<style>.center {  width: auto;  display: table;  margin-left: auto;  margin-right: auto;}</style><h1>软件设计师 下午题 试题一 数据流图设计</h1><p>数据流图也称数据流程图（Data Flow Diagram, DFD），其中基本的图形元素有数据流、加工、数据存储和外部实体。</p><div class="center"><style>.frijgabiewbm{}</style><img src="/2025/04/23/note28/note28_pic01.png" class="frijgabiewbm"></div><ol><li>外部实体(External Agent)：存在于当前软件系统之外的人、物或者外部系统：<ol><li>人：学生、老师、员工…</li><li>物：传感器、控制器、车辆、部门…</li><li>外部系统：支付系统、库存管理系统…</li></ol></li><li>加工(Process)：加工描述了输入数据流到输出数据流之间的变换，每个加工都有一个名字和编号。一个加工至少有一个输入数据流和一个输出数据流。<ol><li>只有输入没有输出的加工称之为黑洞。</li><li>只有输出没有输入的加工称之为白洞。</li><li>加工的数据不足以产生输出数据，称其为灰洞。</li></ol></li><li>数据存储(Data Store)：用来表示存储的数据，每个数据存储都有一个名字。它可以存储加工的输出数据也可以提供加工的输入数据。</li><li>数据流(Data Flow)：用来表示数据的流向。<strong>数据流的起点或者终点必须有一个是加工</strong>。</li></ol><h2 id="一、问题一">一、问题一</h2><p>问题一考察的内容一般是要求写出3到5个实体的名称。</p><p>以《软件设计师考试同步辅导（下午试题）》中的例题为例：</p><div class="center"><style>.tnfoqptiovpy{}</style><img src="/2025/04/23/note28/note28_pic02.jpg" class="tnfoqptiovpy"></div><p>E1: <strong>学生</strong>，E2: <strong>讲师</strong>，E3: <strong>教务人员</strong></p><h2 id="二、问题二">二、问题二</h2><p>问题二考察的内容一般是要求写出3到5个数据存储的名称。</p><p>依旧以例2为例：</p><div class="center"><style>.dicjguewxypq{}</style><img src="/2025/04/23/note28/note28_pic03.jpg" class="dicjguewxypq"></div><p>D1：<strong>作业（表）</strong>，D2：<strong>学生表</strong>，D3：<strong>讲师表</strong>，D4：<strong>批改后的作业（表）</strong>。<br><br>此外，关于图1-4所表示的上下文数据流图和图1-5所表示的0层数据流图的区别如下表所示：</p><div class="center"><table><thead><tr><th><strong>特性</strong></th><th><strong>上下文DFD</strong></th><th><strong>0层DFD</strong></th></tr></thead><tbody><tr><td><strong>处理过程数量</strong></td><td>1个（整个系统）</td><td>多个（主要子过程）</td></tr><tr><td><strong>数据存储</strong></td><td>不显示</td><td>首次引入</td></tr><tr><td><strong>详细程度</strong></td><td>仅系统与外部交互</td><td>系统内部关键流程</td></tr><tr><td><strong>用途</strong></td><td>定义系统边界</td><td>初步设计内部逻辑</td></tr></tbody></table></div><h2 id="三、问题三">三、问题三</h2><p>问题三一般会考察缺失的数据流的情况，需要根据题意分析缺失了哪些数据流并将其补充完整。</p><p>解决问题三一般有以下几种方法：</p><ol><li>父图子图平衡：父图即为上下文数据流图，子图即为0层数据流图。父图显然一定正确，于是就可以根据父图的正确信息逐一排除子图中的数据流是否有缺失。</li><li>加工既有输入数据流也有输出数据流。</li></ol><p>依旧以例2为例：</p><div class="center"><style>.onmvgtmvcmxd{}</style><img src="/2025/04/23/note28/note28_pic03.jpg" class="onmvgtmvcmxd"></div><p>答：</p><ol><li>数据流名称：通知；起点：提交作业；终点：E1。</li><li>数据流名称：抽检报告；起点：作业抽检；终点：E2。</li><li>数据流名称：分数和评价；起点：记录分数和评价；终点：D2。</li><li>数据流名称：通知；起点：记录分数和评价；终点：E1。</li></ol>]]></content>
    
    
    <summary type="html">软考中级备考笔记</summary>
    
    
    
    <category term="软考" scheme="http://example.com/categories/%E8%BD%AF%E8%80%83/"/>
    
    <category term="软件设计师" scheme="http://example.com/categories/%E8%BD%AF%E8%80%83/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/"/>
    
    <category term="下午题" scheme="http://example.com/categories/%E8%BD%AF%E8%80%83/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/%E4%B8%8B%E5%8D%88%E9%A2%98/"/>
    
    
    <category term="软考" scheme="http://example.com/tags/%E8%BD%AF%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>软件设计师 上午题 数据库</title>
    <link href="http://example.com/2025/04/23/note27/"/>
    <id>http://example.com/2025/04/23/note27/</id>
    <published>2025-04-23T02:28:49.000Z</published>
    <updated>2025-05-08T08:26:51.586Z</updated>
    
    <content type="html"><![CDATA[<style>.center {  width: auto;  display: table;  margin-left: auto;  margin-right: auto;}</style><h1>软件设计师 上午题 数据库</h1><h2 id="一、数据库的三级模式结构">一、数据库的三级模式结构</h2><p>尽管数据库的产品很多，但其体系结构基本上都具有相同的特征，都采用“三级模式和两级映像”。</p><div class="center"><style>.mlhnybkhprjx{}</style><img src="/2025/04/23/note27/note27_pic01.png" class="mlhnybkhprjx"></div><p>数据按外模式的描述提供给用户，按内模式的描述存储在磁盘上，而概念模式提供了连接这两级模式的相对稳定的中间层，并使得两级中任意一级的改变都不受另一级影响。</p><h3 id="Ⅰ-概念模式">Ⅰ 概念模式</h3><p>概念模式也称模式，是在逻辑层上对数据进行抽象，是数据库中全部数据的逻辑结构和特征的描述。起到了基本表的作用（基本表是实际存在的表，是实际存储数据的逻辑表示）。</p><h3 id="Ⅱ-外模式">Ⅱ 外模式</h3><p>外模式也称用户模式或者子模式，是在视图层上对数据进行抽象。它可以作用户与数据库系统的接口，起到了视图的作用。</p><h3 id="Ⅲ-内模式">Ⅲ 内模式</h3><p>内模式也称存储模式，是在物理层上对数据进行抽象。它起到了存储文件的作用。</p><h3 id="Ⅳ-两级映像">Ⅳ 两级映像</h3><p>数据库系统在三级模式之间提供了两级映像：模式/内模式映像，外模式/模式映像。两级映像的确立使得数据具有了独立性：</p><ol><li>数据的物理独立性：内模式发生改变时数据库的逻辑模式不需改变，只需修改模式/内模式映像即可。</li><li>数据的逻辑独立性：用户的应用程序和数据库的逻辑结构是相互独立的，只需修改模式/外模式映像即可。</li></ol><h2 id="二、关系代数">二、关系代数</h2><h3 id="Ⅰ-完整性约束">Ⅰ 完整性约束</h3><p>完整性规则提供了一种手段来保证用户对数据库做修改时不会破坏数据的一致性，关系的完整性一共分为三类：</p><ol><li>实体完整性：关系中主键的值不能为空或部分为空。</li><li>参照完整性：如果关系R2的外键X与关系R1的主键相对应，则外键X的每个值必须在关系R1中主键的值中找到，或者为空值。</li><li>用户定义完整性：针对某一具体的关系数据库的约束条件，由应用的环境决定。例如人的年龄规定必须大于等于0，小于等于200。</li></ol><h3 id="Ⅱ-关系运算">Ⅱ 关系运算</h3><div class="center"><style>.qyxivsggzggk{}</style><img src="/2025/04/23/note27/note27_pic02.png" class="qyxivsggzggk"></div><p>以关系R和关系S为例：</p><div class="center"><style>.rcudovfopexk{}</style><img src="/2025/04/23/note27/note27_pic03.png" class="rcudovfopexk"></div><h4 id="1-笛卡尔积">1. 笛卡尔积</h4><p>两个关系R（m个属性n个元组）和S（k个属性p个元组）的笛卡尔积记为R×S，结果是一个新关系：</p><ul><li>包含m+k个属性（先R的所有数据，后S的所有属性）</li><li>包含n×p个元组（每个R的元组与每个S的元组组合一次）</li></ul><div class="center"><style>.ojrofuritcxi{}</style><img src="/2025/04/23/note27/note27_pic04.png" class="ojrofuritcxi"></div><h4 id="2-投影">2. 投影</h4><p>投影是从关系的垂直方向进行运算，在关系R中选出若干属性列<em>A</em>组成新的关系，记作$\pi _A\left( R \right) $。</p><div class="center"><style>.cizgkfmftrtt{}</style><img src="/2025/04/23/note27/note27_pic05.png" class="cizgkfmftrtt"></div><h4 id="3-选择">3. 选择</h4><p>选择是从关系的水平方向进行运算，在关系R中选择满足给定条件的诸元组，记作$\sigma _F\left( R \right) <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>。例如，</mtext></mrow><annotation encoding="application/x-tex">。例如，</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">。例如，</span></span></span></span>\sigma _{1\ge 6}\left( R \right) $表示选取R关系中第1个属性值大于等于第6个属性值的元组。</p><div class="center"><style>.baquckcgbvmd{}</style><img src="/2025/04/23/note27/note27_pic06.png" class="baquckcgbvmd"></div><h4 id="4-连接">4. 连接</h4><p>连接运算是从两个关系R和S的笛卡尔积中选取满足条件的元组。因此，可以认为笛卡尔积是无条件连接，其它连接认为是有条件连接。</p><h5 id="i-theta-连接">i. $\theta $连接</h5><p>$\theta $连接是从R×S中选取属性间满足一定条件的元组。</p><div class="center"><style>.jujwsvuwrchl{}</style><img src="/2025/04/23/note27/note27_pic07.png" class="jujwsvuwrchl"></div><h5 id="ii-等值连接">ii. 等值连接</h5><p>等值连接是特殊的$\theta $连接，其中的比较符号只能为&quot;=&quot;。</p><h5 id="iii-自然连接">iii. 自然连接</h5><p>自然连接是一种特殊的等值连接，它要求两个关系中进行比较的分量必须是相同的属性组，并在结果集中将重复属性列去掉。<br>自然连接可以记为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo>⋈</mo><mi>S</mi></mrow><annotation encoding="application/x-tex">R\Join S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6883em;vertical-align:-0.005em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⋈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span>。</p><div class="center"><style>.hyqhmdajmeub{}</style><img src="/2025/04/23/note27/note27_pic08.jpg" class="hyqhmdajmeub"></div><p>需要注意的是，自然连接不仅要在垂直方向上运算，也要在水平方向上运算。</p><hr><div class="center"><table><thead><tr><th>连接类型</th><th>条件</th><th>结果属性</th><th>重复列</th></tr></thead><tbody><tr><td>θ连接</td><td>任意比较条件</td><td>全部保留</td><td>保留</td></tr><tr><td>等值连接</td><td>等号条件</td><td>全部保留</td><td>保留</td></tr><tr><td>自然连接</td><td>同名属性自动匹配</td><td>去重</td><td>不保留</td></tr></tbody></table></div><h4 id="5-外连接">5. 外连接</h4><p>外连接是连接运算的扩展，可以处理由于连接运算而丢失的信息。</p><div class="center"><style>.fozubjvaxtbn{}</style><img src="/2025/04/23/note27/note27_pic09.jpg" class="fozubjvaxtbn"></div><p>如上图所示，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo>⋈</mo><mi>S</mi><mi>C</mi></mrow><annotation encoding="application/x-tex">S\Join SC</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6883em;vertical-align:-0.005em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⋈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">SC</span></span></span></span>中就丢失黎明、赵国庆等人的信息，而外连接就可以用来处理这种情况。</p><h5 id="i-左外连接">i. 左外连接</h5><p>左外连接是取出左侧关系中所有与右侧关系中任一元组都不匹配的元组，用空值null来填充所有来自右侧关系的属性，并构成新的元组。</p><div class="center"><style>.qgfrqwpilxtp{}</style><img src="/2025/04/23/note27/note27_pic10.png" class="qgfrqwpilxtp"></div><h5 id="ii-右外连接">ii. 右外连接</h5><p>右外连接和左外连接正相反，它是取出右侧关系中所有与左侧关系中任一元组都不匹配的元组，并用null替代后组成新的元组。</p><div class="center"><style>.ipjlwbscsxwp{}</style><img src="/2025/04/23/note27/note27_pic11.png" class="ipjlwbscsxwp"></div><h5 id="iii-全外连接">iii. 全外连接</h5><p>可以理解为在进行完一次左外连接之后再进行一次右外连接。</p><div class="center"><style>.hbrgrymykbum{}</style><img src="/2025/04/23/note27/note27_pic12.png" class="hbrgrymykbum"></div><h3 id="Ⅲ-真题赏析">Ⅲ 真题赏析</h3><div class="center"><style>.uruouhqclcyk{}</style><img src="/2025/04/23/note27/note27_pic13.png" class="uruouhqclcyk"></div><p><strong>D</strong>，应该优先执行选择运算，这样一来可以大幅缩减笛卡尔积得到的结果，增加查询效率。</p><hr><div class="center"><style>.dfjdktmftzut{}</style><img src="/2025/04/23/note27/note27_pic14.png" class="dfjdktmftzut"></div><ol start="54"><li><strong>C</strong>，由题意可得投影中的第一列为员工工号，第二列为姓名，也就是说第一张表的第一二列分别为员工工号、姓名，因此第一张表为E。此外，中文需要使用单引号包括。</li><li><strong>B</strong>。同理，第二张表为C。虽然最后不用查询商品号，但为了使用商品号属性和EC连接，在投影时还需要先包括这一列。</li><li><strong>C</strong>。同理，第三张表为EC。</li></ol><h3 id="后续内容大部分笔者都已经在专业课上学过了，就不再赘述了，留个尾巴以后刷题的时候在这里放错题集。">后续内容大部分笔者都已经在专业课上学过了，就不再赘述了，留个尾巴以后刷题的时候在这里放错题集。</h3>]]></content>
    
    
    <summary type="html">软考中级备考笔记</summary>
    
    
    
    <category term="软考" scheme="http://example.com/categories/%E8%BD%AF%E8%80%83/"/>
    
    <category term="软件设计师" scheme="http://example.com/categories/%E8%BD%AF%E8%80%83/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/"/>
    
    <category term="上午题" scheme="http://example.com/categories/%E8%BD%AF%E8%80%83/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/%E4%B8%8A%E5%8D%88%E9%A2%98/"/>
    
    
    <category term="软考" scheme="http://example.com/tags/%E8%BD%AF%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>软件设计师 上午题 知识产权</title>
    <link href="http://example.com/2025/04/23/note26/"/>
    <id>http://example.com/2025/04/23/note26/</id>
    <published>2025-04-23T02:26:17.000Z</published>
    <updated>2025-05-08T08:26:48.093Z</updated>
    
    <content type="html"><![CDATA[<style>.center {  width: auto;  display: table;  margin-left: auto;  margin-right: auto;}</style><h1>软件设计师 上午题 知识产权</h1><p>这一部分的知识技术性弱记忆性强，比较枯燥，主要涉及的知识点将直接按点陈列：</p><ol><li><p>著作权当中，只有发表权受时间限制（我国公民的作品发表权的保护期为作者终生及其死亡后50年），其它诸如署名权、修改权和保护作品完整权等权利均不受时间限制。</p></li><li><p>知识产权具有严格的地域性特点，即各国主管机关授予的知识产权只在本国领域内受法律保护，其它国家则不予保护。</p></li><li><p>软件著作权：</p><ol><li>软件著作权产生的时间为自作品完成创作之日。</li><li>软件著作权的客体，即受保护对象，有1）计算机程序，2）计算机软件的文档。</li><li>《中华人民共和国著作权法》和《计算机软件保护条例》是构成我国保护计算机软件著作权的两个法律文件。</li></ol></li><li><p>职务作品：职务作品即为公民在任职期间为工作单位开发的作品。</p><ol><li>如果雇员开发的软件属于本质工作的结果，或者主要使用了单位的设备进行开发，则软件著作权不属于个人。</li></ol><blockquote><p>如果是执行本职工作的结果，即针对本职工作中明确指定的开发目标所开发的，或者是从事本职工作活动所预见的结果或自然的结果;则该软件的著作权属于该单位。</p></blockquote><ol start="2"><li>公民仅享有职务作品的署名权。</li></ol></li><li><p>委托开发：</p><ol><li>若委托方与受托方以合同形式约定了软件著作权的归属关系，则软件著作权的归属应按根据此合同来确定。</li><li>若委托方与受托方没有签订合同，或没有在合同中明确规定了软件著作权的归属，则软件著作权属于受托方。</li></ol></li><li><p>利用商业秘密权可以对软件的技术信息、经营信息提供保护。</p></li></ol><blockquote><p>《反不正当竞争法》中商业秘密定义为“指不为公众所知悉的、能为权利人带来经济利益、具有实用性并经权利人采取保密措施的技术信息和经营信息”。</p></blockquote><ol start="7"><li>若甲、乙<strong>同一天</strong>向专利局申请发明专利，则专利权申请人需要由甲、乙公司协商确定。但是不可能向甲、乙都授予专利权。</li><li>我国商标权的保护期限自核准注册之日起10年内有效，但可以根据其所有人的需要无限地延长权利期限。</li><li>若甲、乙<strong>同一天</strong>进行商标注册且都不愿意放弃注册，则需要由甲、乙抽签决定谁能进行注册。</li><li>根据我国商标法，烟草制品必须使用注册商标。</li></ol>]]></content>
    
    
    <summary type="html">软考中级备考笔记</summary>
    
    
    
    <category term="软考" scheme="http://example.com/categories/%E8%BD%AF%E8%80%83/"/>
    
    <category term="软件设计师" scheme="http://example.com/categories/%E8%BD%AF%E8%80%83/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/"/>
    
    <category term="上午题" scheme="http://example.com/categories/%E8%BD%AF%E8%80%83/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/%E4%B8%8A%E5%8D%88%E9%A2%98/"/>
    
    
    <category term="软考" scheme="http://example.com/tags/%E8%BD%AF%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>软件设计师 上午题 程序设计语言</title>
    <link href="http://example.com/2025/04/22/note25/"/>
    <id>http://example.com/2025/04/22/note25/</id>
    <published>2025-04-22T07:00:53.000Z</published>
    <updated>2025-05-08T08:26:44.143Z</updated>
    
    <content type="html"><![CDATA[<style>.center {  width: auto;  display: table;  margin-left: auto;  margin-right: auto;}</style><h1>软件设计师 上午题 程序设计语言</h1><p>程序设计语言是为了书写计算机程序而人为设计的符号语言，本节主要介绍程序设计语言的基本概念、基本成分和一些有代表性的程序设计语言。</p><h2 id="一、程序设计语言的基本概念">一、程序设计语言的基本概念</h2><h3 id="Ⅰ-低级语言和高级语言">Ⅰ 低级语言和高级语言</h3><ol><li>低级语言：面向机器的语言，即机器语言和汇编语言。<ol><li>机器语言：机器语言是最基本的计算机语言，也就是我们在计算机系统章节中常常提起的机器指令，由01组成。使用机器语言设计的程序可读性很差，因此也难以维护。</li><li>汇编语言：人类并不能像机器一样直接读取01，因此人们就想出了一种办法：使用容易记忆的符号来代替01序列，比如用<code>ADD</code>来表示加法等。这些符号表示的指令即为汇编指令，进而可以构成汇编语言。</li></ol></li><li>高级语言：面向各类应用的程序设计语言，这类语言和人们使用的自然语言很接近，如主流的Java、Cpp和Python等。</li></ol><h3 id="Ⅱ-语言的翻译">Ⅱ 语言的翻译</h3><p>显然计算机不可能直接理解汇编语言和高级语言，因此执行这类语言时就需要翻译，基本方式有汇编、解释和编译。</p><ol><li>汇编：如果源程序是用汇编语言编写的，则需要一个汇编程序将其翻译成目标程序后才能执行。</li><li>解释和编译：如果源程序是用某种高级语言编写的，则需要对应的解释程序或者编译程序对其进行翻译：<ol><li>解释程序：边解释边执行，​​不生成独立的目标代码​​，每次运行都需要解释器实时翻译。</li><li>编译程序：将源代码​​一次性​​转换为目标机器代码（如二进制可执行文件），生成独立的可执行程序。</li></ol></li></ol><h2 id="二、语言处理程序基础">二、语言处理程序基础</h2><p>语言处理程序即为前文所述的翻译程序，它们将高级语言或汇编语言编写的程序翻译成某种机器语言程序使其可在计算机上运行。备考中我们重点要掌握的是编译程序的基本原理。</p><h3 id="Ⅰ-编译程序的基本原理">Ⅰ 编译程序的基本原理</h3><p>编译程序的功能是将某高级语言书写的源程序翻译成与之等价的目标程序（汇编语言或机器语言）。其工作过程如下图所示：</p><div class="center"><style>.rlqbbhdvnmsx{}</style><img src="/2025/04/22/note25/note25_pic01.png" class="rlqbbhdvnmsx"></div><h4 id="1-词法分析">1. 词法分析</h4><p>词法分析​是编译器的第一个阶段，其核心任务是将​​源代码的字符序列​​转换为有意义的​<strong>​词法单元</strong>（Token）序列​，也即<strong>记号流</strong>，为后续的语法分析提供结构化输入。<br>其中，每个Token常以二元组的方式输出，即<code>&lt;Token Type, Value&gt;</code>。常见的Token Type有关键字、标识符、常数、运算符和分隔符等。<br>比如有这样一串C语言代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> x = <span class="hljs-number">42</span>;<br></code></pre></td></tr></table></figure><p>那么在进行词法分析后输出的Tokens就应该为：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs txt">&lt;关键字, &quot;int&quot;&gt;<br>&lt;标识符, &quot;x&quot;&gt;<br>&lt;运算符, &quot;=&quot;&gt;<br>&lt;整常数, &quot;42&quot;&gt;<br>&lt;分隔符, &quot;;&quot;&gt;<br></code></pre></td></tr></table></figure><p>进行词法分析可以跳过空格、换行、注释等不影响程序逻辑的字符，并将连续的字符组合成有意义的单元（如变量名x、数字42），有效简化了后续的语法分析。</p><h4 id="2-语法分析">2. 语法分析</h4><p>​语法分析​​是继词法分析之后的第二个关键阶段，其核心任务是将​​词法分析生成的Token序列​​转换为​​结构化的语法树​​，以验证整个输入串是否构成一个语法上正确的程序。<br>如果源程序中没有语法错误，这一阶段就能正确地构造出一个语法树，否则就会指出源程序的语法错误并给出相应的诊断信息。<br>例如上文中的Tokens就能被构造出这样一个语法树：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs txt">     Declaration<br>     /    |    \<br>Type   Name   Value<br>(int)   (x)    (42)<br></code></pre></td></tr></table></figure><h4 id="3-语义分析">3. 语义分析</h4><p>​​语义分析是继​​词法分析​​和​​语法分析​​之后的第三个关键阶段。它的核心任务是​​检查源代码是否符合语言的语义规则​​，确保程序<strong>在逻辑上是正确的</strong>，不会出现类似于“猫吃代码”的谬误，而不仅仅是语法正确。<br>例如，整除取余运算符只能对整型进行运算，若其运算对象中有浮点数就可以认为存在类型不匹配的错误。</p><h4 id="4-中间代码生成">4. 中间代码生成</h4><p>中间代码生成​​是编译器的核心阶段之一，位于​​前端（词法/语法/语义分析）​​和​​后端（目标代码生成与优化）​​之间。它的任务是将​​语义分析后的语法树​转换为一种<strong>​​与机器无关</strong>的中间表示（IR）​​，可以将不同的高级语言转换为同一种中间代码，使其具备了跨平台的能力，为后续优化和目标代码生成提供了统一接口。<br>常见的中间代码有：后缀式、三地址码、三元式、四元式和树（图）等形式。</p><h4 id="5-目标代码生成">5. 目标代码生成</h4><p>目标代码生成是编译器工作的最后一个阶段，这一阶段的任务即为将中间代码变换为特定机器上的指令代码。由于是生成特定机器上的代码，<strong>这一阶段的工作与具体的机器密切相关</strong>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs asm">; 同一加法操作在不同架构下的代码可能完全不同<br><br>; x86<br>add eax, ebx<br><br>; ARM<br>add r0, r1, r2<br><br>; MIPS<br>add $t0, $t1, $t2<br></code></pre></td></tr></table></figure><p>编译过程中的中间代码生成和代码优化不是必须的，可省略。</p><h3 id="Ⅱ-词法分析中的模型">Ⅱ 词法分析中的模型</h3><p>正如前文所述，词法分析是一个将源程序中的字符串转换为单词符号序列的一个过程，而这个过程所依赖的模型有以下几个：</p><h4 id="1-正规式与正规集">1. 正规式与正规集</h4><div class="center"><style>.uyebrtxhnbop{}</style><img src="/2025/04/22/note25/note25_pic07.png" class="uyebrtxhnbop"></div><p>正规式是一种用于描述​​字符串模式​​的形式化表达式，用于匹配符合特定规则的字符串集合，是定义​​正规集​​的数学工具。<br>例如有一个正规式<code>a*</code>，它就定义了一个正规集<code>&#123;ε, &quot;a&quot;, &quot;aa&quot;, &quot;aaa&quot;, ...&#125;</code>；再比如正规式<code>(a|b)*</code>定义的正规集就是<code>&#123;ε, &quot;a&quot;, &quot;b&quot;, &quot;aa&quot;, &quot;ab&quot;, &quot;ba&quot;, &quot;bb&quot;, &quot;aabba&quot;, &quot;babab&quot;, ...&#125;</code>。</p><h4 id="2-有限自动机">2. 有限自动机</h4><p>有限自动机是一种用来识别正规集的抽象计算模型，又可以继续分为确定的有限自动机和不确定的有限自动机两类：</p><ul><li>确定的有限自动机（Deterministic Finite Automata, DFA）：对每一个状态来说识别字符后转移的状态是唯一的。</li></ul><div class="center"><style>.frficicdmidc{}</style><img src="/2025/04/22/note25/note25_pic09.png" class="frficicdmidc"></div><p>  有限自动机中所谓的状态转移图和状态转移矩阵的概念和在数电中学习过的状态图基本类似，只是需要注意的是双圈表示的结点是终结结点。</p><ul><li>不确定的有限自动机（Nodeterministic Finite Automata, NFA）：对每一个状态来说识别字符后转移的状态是不确定的。</li></ul><div class="center"><style>.rtxwadxhwztr{}</style><img src="/2025/04/22/note25/note25_pic10.png" class="rtxwadxhwztr"></div><p>当一个字符串被输入进有限自动机中之后，如果在最后一个字符被输入之后，自动机的状态落到了双圈的终结结点上，该自动机就会返回一个“接受”的状态，说明这个字符串满足目标语言的规则，反之就会返回一个“拒绝”的状态。<br>也就是说，在有限自动机当中，所谓的终结结点并不是说自动机在进入这一状态之后就会终止，而是在终止时据此返回结果。</p><h3 id="Ⅲ-语法分析中的模型">Ⅲ 语法分析中的模型</h3><p>语法分析中所要用到的一个重要模型是上下文无关文法，程序设计语言的绝大部分语法规则可以采用上下文无关文法进行描述。<br>一个上下文无关文法可以由以下几部分组成；</p><ul><li>非终结符：可进一步展开的表示语法结构的抽象符号，一般用大写英文字母表示。</li><li>终结符：组成语言的基本符号，一般用小写英文字母表示。</li><li>产生式规则：定义非终结符如何展开为终结符和非终结符的组合。</li><li>开始符号：语法推导的起点。</li></ul><p>比如以下这道例题：</p><div class="center"><style>.whadvptjvwpr{}</style><img src="/2025/04/22/note25/note25_pic12.png" class="whadvptjvwpr"></div><p>其中类似于<code>T -&gt; F|T*F</code>就是一条产生式规则，定义了在非终结符<code>T</code>的展开规则。</p><h3 id="Ⅳ-解释程序的基本原理">Ⅳ 解释程序的基本原理</h3><p>正如前文所述，编译程序可分为：词法分析、语法分析、语义分析、中间代码生成、代码优化和目标代码生成六个部分。而对于解释程序而言，有前三个过程即可。即编译器和解释器都不能省略词法分析、语法分析和语义分析三个阶段且顺序不可交换。</p><h3 id="Ⅴ-真题赏析">Ⅴ 真题赏析</h3><div class="center"><style>.nbquugccktvy{}</style><img src="/2025/04/22/note25/note25_pic02.png" class="nbquugccktvy"></div><p><strong>C</strong>，语义分析阶段只能发现静态错误，动态语义错误只有在程序运行时才能发现。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 静态语义错误</span><br><span class="hljs-type">int</span> x = <span class="hljs-string">&quot;hello&quot;</span>;  <span class="hljs-comment">// 错误：int 不能赋值为字符串（类型不匹配）</span><br><br><span class="hljs-built_in">printf</span>(y);        <span class="hljs-comment">// 错误：y 未声明</span><br><br><span class="hljs-comment">// -----------------------------------------------------------</span><br><br><span class="hljs-comment">// 动态语义错误</span><br><span class="hljs-type">int</span> a = <span class="hljs-number">10</span> / <span class="hljs-number">0</span>;    <span class="hljs-comment">// 运行时错误：除零</span><br><span class="hljs-type">int</span> arr[<span class="hljs-number">3</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, arr[<span class="hljs-number">5</span>]); <span class="hljs-comment">// 运行时错误：数组越界</span><br><br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span><br><span class="hljs-keyword">while</span> (i &lt; <span class="hljs-number">1</span>)<br>&#123;<br>  i--<br>&#125; <span class="hljs-comment">// 运行时错误：死循环</span><br><br></code></pre></td></tr></table></figure><hr><div class="center"><style>.wlbrlyobzeyn{}</style><img src="/2025/04/22/note25/note25_pic03.png" class="wlbrlyobzeyn"></div><p><strong>D</strong>，B选项的错误在于应该为<code>在语法分析阶段可以发现程序中的所有语法错误</code>，而非<code>所有错误</code>。</p><hr><div class="center"><style>.jemhsgdlvhxo{}</style><img src="/2025/04/22/note25/note25_pic04.png" class="jemhsgdlvhxo"></div><p><strong>D</strong>，寄存器分配是目标代码生成阶段的核心任务之一，这是由于将中间代码转换为机器码时需要分配物理寄存器。</p><hr><div class="center"><style>.eihcghnbxdts{}</style><img src="/2025/04/22/note25/note25_pic05.png" class="eihcghnbxdts"></div><p><strong>A</strong>，词法分析和语法分析的核心区别在于前者是检查字符是否符合规定而后者是检查语句是否符合规定。</p><hr><div class="center"><style>.lvdqyeebzwck{}</style><img src="/2025/04/22/note25/note25_pic06.png" class="lvdqyeebzwck"></div><p><strong>B</strong>，类型检查是​​语义分析阶段​​的核心任务之一，进行类型检查可以确保程序在逻辑上正确，避免出现对浮点数进行模运算等错误情况。</p><hr><div class="center"><style>.dnossqiusprt{}</style><img src="/2025/04/22/note25/note25_pic08.png" class="dnossqiusprt"></div><p><strong>B</strong>，对于A选项而言，0*有可能为空串，其开头和结尾也有可能是1。</p><hr><div class="center"><style>.zkwqqihttdwt{}</style><img src="/2025/04/22/note25/note25_pic11.png" class="zkwqqihttdwt"></div><p><strong>B</strong>，从题中的自动机可分析出，初态q0同时是终态，从q0到q0的弧(标记 0)表明该自动机识别零个或多个0构成的串，路径q0→q1→q0的循环表明“10”的多次重复，因此该自动机识别的字符串是“010”的无穷多次，表示为(0|10)*。</p>]]></content>
    
    
    <summary type="html">软考中级备考笔记</summary>
    
    
    
    <category term="软考" scheme="http://example.com/categories/%E8%BD%AF%E8%80%83/"/>
    
    <category term="软件设计师" scheme="http://example.com/categories/%E8%BD%AF%E8%80%83/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/"/>
    
    <category term="上午题" scheme="http://example.com/categories/%E8%BD%AF%E8%80%83/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/%E4%B8%8A%E5%8D%88%E9%A2%98/"/>
    
    
    <category term="软考" scheme="http://example.com/tags/%E8%BD%AF%E8%80%83/"/>
    
  </entry>
  
</feed>
