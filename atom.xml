<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2025-05-08T13:27:40.187Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>谢斐</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>软件设计师 上午题 软件工程</title>
    <link href="http://example.com/2025/05/08/note35/"/>
    <id>http://example.com/2025/05/08/note35/</id>
    <published>2025-05-08T08:19:45.000Z</published>
    <updated>2025-05-08T13:27:40.187Z</updated>
    
    <content type="html"><![CDATA[<style>.center {  width: auto;  display: table;  margin-left: auto;  margin-right: auto;}</style><h1>软件设计师 上午题 软件工程</h1><p>软件工程​旨在通过工程化方法（如需求分析、设计、开发、测试和维护）高效构建​​高质量、可靠、可维护​​的软件系统。其核心目标是​​解决“软件危机”​​（如成本超支、进度延迟、质量低下等问题），平衡用户需求、技术可行性和商业可持续性。</p><h2 id="一、软件过程">一、软件过程</h2><p>软件开发中所遵循的路线图被称之为“软件过程”，为了有效管理软件过程，人们开发了以下几种模型：</p><h4 id="1-能力成熟度模型（CMM）">1. 能力成熟度模型（CMM）</h4><p>一个软件组织在开发软件的过程中，其能力一定是一步步提高的，而CMM就是一个用来描述软件组织进化阶段的模型。它将软件过程改进分为以下五个成熟度级别：</p><ul><li><strong>初始级</strong>：该阶段的软件过程杂乱无章，几乎没有明确定义的步骤，想要完成项目必须依靠英雄式核心人物的作用。</li><li><strong>可重复级</strong>：建立了基本的项目管理过程和实践，有必要的过程准则来重复以前在同类项目中的成功。</li><li><strong>已定义级</strong>：管理和工程两方面的软件过程已经文档化和标准化。所有项目都采用根据实际情况修改后得到的标准软件过程来开发和维护软件。</li><li><strong>已管理级</strong>：制定了软件过程和产品质量的详细度量标准，软件过程的质量都被开发人员所理解和控制。</li><li><strong>优化级</strong>：加强了定量分析，有不断的反馈使得软件过程可以不断持续地改进。</li></ul><h4 id="2-能力成熟度模型集成（CMMI）">2. 能力成熟度模型集成（CMMI）</h4><p>CMMI是若干个过程模型的综合和改进，能够支持多个工程学科。CMMI提供了两种表示方法：</p><ul><li>阶段式模型：阶段式模型的结构类似于CMM。<ul><li>初始的：过程不可预测且缺乏控制。</li><li>已管理的：过程为项目服务。</li><li>已定义的：过程为组织服务。</li><li>定量管理的：过程已度量和控制。</li><li>优化的：集中于过程改进。</li></ul></li><li>连续式模型：我们将软件过程中的特定领域的标准化实践集合称之为过程域，而连续式模型关注的就是过程域的能力。连续式模型中使用能力等级（CL）来评估过程域的能力：<ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><msub><mi>L</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">CL_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>（未完成的）：未完成<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><msub><mi>L</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">CL_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>中制定的目标即为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><msub><mi>L</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">CL_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><msub><mi>L</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">CL_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>（已执行的）：过程​​能被执行​​（能将可标识的输入转换为可标识的输出），但依赖个人能力，无标准化。</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><msub><mi>L</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">CL_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>（已管理的）：过程​​有计划、有监控​​，能按文档化流程执行。</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><msub><mi>L</mi><mn>3</mn></msub></mrow><annotation encoding="application/x-tex">CL_3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>（已定义的）：过程​​标准化​​，基于组织级最佳实践，并培训团队。</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><msub><mi>L</mi><mn>4</mn></msub></mrow><annotation encoding="application/x-tex">CL_4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>（定量管理的）：过程​通过数据（如需求变更率）优化。</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><msub><mi>L</mi><mn>5</mn></msub></mrow><annotation encoding="application/x-tex">CL_5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>（优化的）：使用<strong>量化手段</strong>​​持续改进过程​​，通过技术创新或流程再造提升效率。</li></ul></li></ul><h2 id="二、软件过程模型">二、软件过程模型</h2><p>软件过程模型，亦即软件开发模型，它是软件开发全部过程、活动和任务的结构框架。</p><h3 id="Ⅰ-瀑布模型">Ⅰ 瀑布模型</h3><h4 id="1-瀑布模型">1. 瀑布模型</h4><p>瀑布模型将软件生存周期中的各个活动规定为依照线性顺序连接的若干阶段的模型，各阶段间相互衔接，如同瀑布般逐级下落：</p><div class="center"><style>.njxpijxrodcd{}</style><img src="/2025/05/08/note35/note35_pic01.png" class="njxpijxrodcd"></div><p>显然，瀑布模型很适合软件需求非常明确的模型，或者已经掌握了开发技术的软件。但是在瀑布模型中，客户必须能够完整清晰地表达他们的需求，而且需求或设计中的错误只有到了项目后期才会被发现，容易出现积重难返的现象。此外，瀑布模型也难以适应变化的需求。</p><h4 id="2-V模型">2. V模型</h4><p>V模型是瀑布模型的一个变体，左侧用来描述开发，右侧用来描述测试，这样就使得测试与开发能够并行设计，能够在项目早期就发现缺陷。</p><div class="center"><style>.ponjdvfkvvhh{}</style><img src="/2025/05/08/note35/note35_pic02.png" class="ponjdvfkvvhh"></div><h3 id="Ⅱ-增量模型">Ⅱ 增量模型</h3><p>增量模型事实上也是瀑布模型的一个变体，它融合了瀑布模型的迭代特征。在增量模型中将总体需求分段为一系列增量产品，每个增量包含一个完整的功能子集。</p><div class="center"><style>.ndpjichdkcre{}</style><img src="/2025/05/08/note35/note35_pic03.png" class="ndpjichdkcre"></div><p>如图所示，每个增量都可以分别开发并分批发布。一般来说会将软件最核心的功能包含进第一个增量当中，这样一来用户就能在整个系统开发完毕之前抢先进行使用，并给出反馈以便下一个增量发布新特征和新功能。<br>增量模型的困难在于需要比较长远的项目规划，否则前期开发的增量有可能造成后来增量的不稳定或者产生重新开发的成本。</p><h3 id="Ⅲ-演化模型">Ⅲ 演化模型</h3><p>演化模型​​是一种​​渐进式、迭代式​​的软件开发方法，通过​​不断反馈和优化​​逐步完善系统，最终交付符合用户需求的完整产品。其核心思想是：​​“先构建核心功能，再逐步扩展和优化”​​，适用于需求不明确或可能频繁变化的项目。</p><p>典型的演化模型有原型模型和螺旋模型等：</p><h4 id="1-原型模型">1. 原型模型</h4><p>​​原型模型​​是一种通过快速构建原型（预期系统的一个可执行版本）来验证需求和设计的开发方法，其核心是​​“先试错，再开发”​​。开发团队利用工具快速制作可交互原型，由用户试用并反馈，经过多次迭代优化后，最终确定需求或直接基于稳定原型开发完整系统。</p><div class="center"><style>.yfstlsbsbchd{}</style><img src="/2025/05/08/note35/note35_pic04.png" class="yfstlsbsbchd"></div><h4 id="2-螺旋模型">2. 螺旋模型</h4><p>对于复杂的大型软件，开发一个原型往往达不到要求，那么人们就开发出了一种将瀑布模型和演化模型结合起来的模型，即螺旋模型。</p><div class="center"><style>.vfqvhzutynfx{}</style><img src="/2025/05/08/note35/note35_pic07.png" class="vfqvhzutynfx"></div><p>和瀑布模型类似，螺旋模型​将开发过程分为多个循环周期，每个周期包含​​需求分析、风险评估、原型开发及用户验证​​四个阶段，通过逐步迭代完善系统。<br>但是螺旋模型还支持用户需求的动态变化，其核心特点就是​​早期识别并控制风险，适用于复杂度高、不确定性大的项目（如军工、医疗软件）。相比瀑布模型更灵活，相比纯迭代模型更强调系统性风险管理，但成本较高且依赖专业风险评估能力。</p><hr><div class="center"><style>.rrrikfhynbif{}</style><img src="/2025/05/08/note35/note35_pic05.png" class="rrrikfhynbif"></div><p><strong>C</strong>，瀑布模型和V模型都是都是基于明确的开发需求的开发模型，而当用户的需求不明确时就需要用原型模型不断地捕捉需求。</p><hr><div class="center"><style>.wntklvscbvsf{}</style><img src="/2025/05/08/note35/note35_pic06.png" class="wntklvscbvsf"></div><p><strong>B</strong>，原型模型仅适用于小规模不复杂的软件，否则其原型开发也将消耗大量成本，并且难以满足需求。</p><hr><div class="center"><style>.xdmebwczfsrq{}</style><img src="/2025/05/08/note35/note35_pic08.png" class="xdmebwczfsrq"></div><p><strong>DC</strong>，不再赘述。</p><h3 id="Ⅳ-喷泉模型">Ⅳ 喷泉模型</h3><p>喷泉模型是一种面向对象的软件开发方法，其核心特点是开发阶段的无缝迭代与回溯，强调各阶段之间的非线性交互和并行推进。与瀑布模型的线性流程不同，喷泉模型的开发活动之间不存在明显的边界，允许开发者在任意阶段根据需求动态调整（如设计时发现分析不足可回溯补充），尤其适合需求易变、需频繁重构的面向对象项目。其优势在于灵活性高、适应性强，但需严格管理文档和版本控制以避免混乱。</p><div class="center"><style>.rkuijvkcvufo{}</style><img src="/2025/05/08/note35/note35_pic09.png" class="rkuijvkcvufo"></div><h3 id="Ⅴ-敏捷方法">Ⅴ 敏捷方法</h3><p>敏捷开发的总体目标是通过“尽可能早地、持续地对有价值的软件的交付”来使客户满意。在软件开发中假如灵活性之后，用户能够在敏捷方法的开发后期增加或改变需求。</p><p>敏捷方法的典型方法有以下几种：</p><h4 id="1-极限编程（XP）">1. 极限编程（XP）</h4><p>这一部分的知识点过于琐碎，做题的时候按直觉回答即可。</p><h4 id="2-水晶法">2. 水晶法</h4><p>水晶法认为每一个不同的项目都需要一套不同的策略。</p><h4 id="3-并列争求法">3. 并列争求法</h4><p>并列争求法使用迭代的方法，把每30天一次的迭代称为一个“冲刺”，并按需求的优先级别来实现产品。</p><h4 id="4-敏捷统一过程（AUP）">4. 敏捷统一过程（AUP）</h4><p>AUP采用“在大型上连续”以及“在小型上迭代”的原理来构建软件系统。它采用经典的UP阶段性活动，能够使团队为软件项目构想出一个全面的过程流。</p><h2 id="三、需求分析">三、需求分析</h2><h3 id="Ⅰ-软件需求">Ⅰ 软件需求</h3><p>软件需求是指用户对于目标软件系统的期望，主要包括以下几个方面：</p><ol><li>功能需求：考虑系统要做什么，在何时做，在何时以及如何修改或升级。</li><li>性能需求：考虑软件开发的技术性指标。</li><li>数据需求：考虑输入、输出数据的格式，接收、发送数据的频率等。</li></ol><hr><div class="center"><style>.hhmjtwwibkgm{}</style><img src="/2025/05/08/note35/note35_pic10.png" class="hhmjtwwibkgm"></div><p><strong>A</strong>，A为功能需求，BD为性能需求，C为数据需求。</p><h3 id="Ⅱ-系统设计">Ⅱ 系统设计</h3><p>系统设计阶段的任务就是将软件“做什么”的逻辑模型转换为“怎么做”的物理模型。系统设计的基本任务大体上可以分为概要设计和详细设计两个步骤。</p><h4 id="1-概要设计">1. 概要设计</h4><p>概要设计的重点是设计软件系统的总体结构：其基本任务是采用某种设计方法，将一个复杂的系统按功能划分为模块，并缕清每个模块的功能、模块之间的调用关系、确定模块之间的接口和评价模块结构的质量。</p><h4 id="2-详细设计">2. 详细设计</h4><ul><li>对每个模块进行详细的算法设计。</li><li>对模块的数据结构进行设计。</li><li>对数据库的物理结构进行设计。</li></ul><h3 id="Ⅲ-系统测试">Ⅲ 系统测试</h3><p>系统测试是为了以最少的人力和时间发现潜在的各种错误和缺陷。</p><h4 id="1-系统测试的基本原则">1. 系统测试的基本原则</h4><p>这一部分的知识点过于琐碎，做题的时候按直觉回答即可。</p><h4 id="2-传统软件的测试策略">2. 传统软件的测试策略</h4><p>有效的软件测试实际上分为4步进行，即单元测试、集成测试、确认测试和系统测试，这里我们重点了解前两步。</p><h5 id="1）单元测试">1）单元测试</h5><h5 id="2）集成测试">2）集成测试</h5><h3 id="Ⅳ-测试方法">Ⅳ 测试方法</h3>]]></content>
    
    
    <summary type="html">软考中级备考笔记</summary>
    
    
    
    <category term="软考" scheme="http://example.com/categories/%E8%BD%AF%E8%80%83/"/>
    
    <category term="软件设计师" scheme="http://example.com/categories/%E8%BD%AF%E8%80%83/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/"/>
    
    <category term="上午题" scheme="http://example.com/categories/%E8%BD%AF%E8%80%83/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/%E4%B8%8A%E5%8D%88%E9%A2%98/"/>
    
    
    <category term="软考" scheme="http://example.com/tags/%E8%BD%AF%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>软件设计师 上午题 结构化开发</title>
    <link href="http://example.com/2025/05/08/note34/"/>
    <id>http://example.com/2025/05/08/note34/</id>
    <published>2025-05-08T06:40:25.000Z</published>
    <updated>2025-05-08T08:27:17.522Z</updated>
    
    <content type="html"><![CDATA[<style>.center {  width: auto;  display: table;  margin-left: auto;  margin-right: auto;}</style><h1>软件设计师 上午题 结构化开发</h1><p>结构化开发是一种系统化的软件开发方法，强调通过清晰的步骤、模块化设计和标准化工具来提升软件的可维护性、可靠性和开发效率。其核心思想是将复杂问题分解为更小、更易管理的部分，通常与​​结构化编程​​和​​结构化设计​​密切相关。</p><h2 id="一、系统分析与设计概述">一、系统分析与设计概述</h2><h3 id="Ⅰ-系统设计的基本原理">Ⅰ 系统设计的基本原理</h3><h4 id="1-抽象">1. 抽象</h4><p>抽象，即将一个复杂的现象简化到可以分析、实验或者可以理解的程度。例如在设计用户登录模块时，在较高层次的抽象中只需定义输入（账号/密码）、输出（成功/失败），无需关心密码加密的具体算法。具体的算法可以在较低的抽象层次中细化。</p><h4 id="2-模块化">2. 模块化</h4><p>模块化即将系统分解为功能独立的模块，每个模块完成单一职责。这是一种对复杂问题分而治之的原则。</p><h4 id="3-信息隐蔽">3. 信息隐蔽</h4><p>信息隐蔽意味着将每个程序的成分封装在一个单一的设计模块中，在定义每一个模块时尽可能少地显露其内部的处理。</p><h4 id="4-模块独立">4. 模块独立</h4><p>模块独立是指每个模块完成一个相对独立的特定子功能，并且要求模块之间的联系要尽可能简单。我们可以使用两个指标来衡量模块独立的程度：</p><h5 id="1）耦合">1）耦合</h5><p>耦合定义的是模块间依赖关系的紧密程度。耦合越低，独立性越强。一般来说，模块之间的耦合会有以下几种类型：</p><div class="center"><style>.ccvjjqtuwbav{}</style><img src="/2025/05/08/note34/note34_pic01.png" class="ccvjjqtuwbav"></div><ul><li><strong>无直接耦合</strong>：两个模块间没有直接的关系。</li><li><strong>数据耦合</strong>：两个模块之间存在值传递。</li><li><strong>标记耦合</strong>：两个模块之间存在数据结构的传递。</li><li><strong>控制耦合</strong>：一个模块调用另一个模块中的某一功能。</li><li><strong>外部耦合</strong>：模块间通过软件之外的环境连接，比如I/O将模块耦合到特定的设备上。</li><li><strong>公共耦合</strong>：多个模块共享全局数据。</li><li><strong>内容耦合</strong>：一个模块直接使用另一个模块的内部数据，或者一个模块通过非正常入口转入另一个模块内部。</li></ul><h5 id="2）内聚">2）内聚</h5><p>内聚着眼于一个模块内部，即一个模块中的各个元素彼此结合的紧密程度。一个高内聚的模块应当只做一件事。模块的内聚一般有以下几种类型：</p><div class="center"><style>.sciioyjyilti{}</style><img src="/2025/05/08/note34/note34_pic02.png" class="sciioyjyilti"></div><ul><li><strong>偶然内聚</strong>：一个模块内的各个元素之间没有任何联系。</li><li><strong>逻辑内聚</strong>：一个模块能够执行若干个逻辑上相似的功能。</li><li><strong>时间内聚</strong>：把需要同时执行的动作组合在一起的模块称作时间内聚模块。</li><li><strong>过程内聚</strong>：一个模块完成多个任务，且这些任务必须按指定的过程执行。</li><li><strong>通信内聚</strong>：模块内的所有元素都在同一个数据结构上操作，这样一来大体的效果就是各处理在使用相同的输入时会产生相同的输出。</li><li><strong>顺序内聚</strong>：一个模块内的各个处理元素都密切相关于完成一个功能且必须顺序执行。</li><li><strong>功能内聚</strong>：一个模块内的所有元素都密切相关于完成一个功能，缺一不可。</li></ul><h3 id="Ⅱ-系统总体结构设计">Ⅱ 系统总体结构设计</h3><h4 id="1-系统结构设计原则">1. 系统结构设计原则</h4><ul><li><strong>分解-协调原则</strong>：解决复杂问题的一个重要原则为将其分解成多个小问题分别处理，在处理过程中根据系统的总体要求协调各部门之间的关系。</li><li><strong>自顶向下的原则</strong>：首先抓住系统总的功能，再逐层分解实现。</li><li><strong>信息隐蔽、抽象的原则</strong>：上层模块只规定下层模块要干什么，而不干涉怎么实现，以保证模块间的独立性和层次性。</li><li><strong>一致性原则</strong>：整个软件设计过程中需要有统一的规范。</li><li><strong>明确性原则</strong>：每个模块必须功能明确、接口明确，消除冗余的功能和接口。</li><li><strong>模块的扇入系数和扇出系数要合理</strong>：一个模块直接调用其它模块的个数称之为扇出系数，反之则称之为扇入系数。扇出系数和扇入系数必须适当。</li><li><strong>模块之间的耦合尽可能小，模块的内聚度尽可能高</strong>。</li><li><strong>模块的规模适当</strong>。</li><li><strong>模块的作用范围应该在其控制范围之内</strong>。</li></ul><h2 id="二、结构化分析方法">二、结构化分析方法</h2><h3 id="Ⅰ-数据流图（DFD）">Ⅰ 数据流图（DFD）</h3><p>数据流图的详细内容请参见：<a href="https://loquattree.xyz/2025/04/23/note28/">软件设计师 下午题 试题一 数据流图设计</a></p><hr><ol><li>2012年上半年：</li></ol><div class="center"><style>.neotxgolsuqs{}</style><img src="/2025/05/08/note34/note34_pic03.png" class="neotxgolsuqs"></div><p><strong>B</strong>，在分层数据流图中有顶层数据流图、0层数据流图和底层数据流图三种。它们的功能依次是1）以最简形式描述系统的边界、主要输入/输出流；2）将系统分解为关键的处理过程，如“订单处理”、“支付验证”等；3）进一步细化每个处理过程的内部逻辑。</p><h3 id="Ⅱ-数据字典（DD）">Ⅱ 数据字典（DD）</h3><blockquote><p>数据流图描述了系统的分解，但没有对图中各成分进行说明。数据字典就是为数据流图中的每个数据流、文件、加工，以及组成数据流或文件的数据项做出说明。其中，对加工的描述称为“小说明”，也可以称为“加工逻辑说明”。</p></blockquote><h4 id="1-数据字典的内容">1. 数据字典的内容</h4><p>数据字典中有以下4类条目：</p><ul><li><strong>数据流条目</strong>：通常列出数据流的来源、去向和组成。</li><li><strong>数据存储条目</strong>：定义系统中持久化数据的存储结构（如数据库表、文件）。</li><li><strong>数据项条目</strong>：细化数据流或数据存储中的​​最小数据单元​​，包括类型、长度、约束等。</li><li><strong>基本加工条目</strong>：用来说明DFD中基本加工的处理逻辑。</li></ul><div class="center"><style>.hkxirkybkmnt{}</style><img src="/2025/05/08/note34/note34_pic04.png" class="hkxirkybkmnt"></div><h4 id="2-结构化语言">2. 结构化语言</h4><p>结构化语言是一种常见的用来描述加工逻辑的方法，这是一种介于自然语言和形式化语言之间的半形式化语言。结构化语言的结构通常可分为内层和外层：</p><ul><li>外层：用来描述控制结构，有以下几种基本结构：<ul><li>顺序结构：一组祈使语句、选择语句、重复语句的顺序排列。</li><li>选择结构：一般采用IF-ELSE等关键词。</li><li>重复结构：一般采用DO-WHILE-ENDDO等关键词。</li></ul></li><li>内层：了解即可，语法比较灵活，一般是采用祈使语句的自然语言短语。</li></ul>]]></content>
    
    
    <summary type="html">软考中级备考笔记</summary>
    
    
    
    <category term="软考" scheme="http://example.com/categories/%E8%BD%AF%E8%80%83/"/>
    
    <category term="软件设计师" scheme="http://example.com/categories/%E8%BD%AF%E8%80%83/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/"/>
    
    <category term="上午题" scheme="http://example.com/categories/%E8%BD%AF%E8%80%83/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/%E4%B8%8A%E5%8D%88%E9%A2%98/"/>
    
    
    <category term="软考" scheme="http://example.com/tags/%E8%BD%AF%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>访问Apache服务器时出现“403 Forbidden”的解决方案</title>
    <link href="http://example.com/2025/05/07/md07/"/>
    <id>http://example.com/2025/05/07/md07/</id>
    <published>2025-05-07T03:30:43.000Z</published>
    <updated>2025-05-07T03:35:51.459Z</updated>
    
    <content type="html"><![CDATA[<style>.center {  width: auto;  display: table;  margin-left: auto;  margin-right: auto;}</style><h1>访问Apache服务器时出现“403 Forbidden”的解决方案</h1><div class="center"><style>.yeskvcddxoeu{}</style><img src="/2025/05/07/md07/md07_pic01.png" class="yeskvcddxoeu"></div><p>在配置Apache服务器时，如果修改了默认的根目录就可能出现被拒绝访问的情况，可以执行以下命令解决：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">确保目录可读</span><br>sudo chmod 755 /home/rhauser/public_html<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">确保文件可读</span><br>sudo chmod 644 /home/rhauser/public_html/*<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">确保Apache对父目录也有权限</span><br>sudo chmod +x /home /home/rhauser<br></code></pre></td></tr></table></figure><p>成功解决：</p><div class="center"><style>.mupwoxvwyymy{}</style><img src="/2025/05/07/md07/md07_pic02.png" class="mupwoxvwyymy"></div>]]></content>
    
    
    <summary type="html">该问题一般出现更改了Apache服务器默认地址时</summary>
    
    
    
    <category term="疑难杂症解决方案" scheme="http://example.com/categories/%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    
    
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>VMWare扩容虚拟机时“指定的虚拟磁盘需要进行修复”报错的解决方案</title>
    <link href="http://example.com/2025/05/06/md06/"/>
    <id>http://example.com/2025/05/06/md06/</id>
    <published>2025-05-06T14:26:41.000Z</published>
    <updated>2025-05-06T14:31:06.046Z</updated>
    
    <content type="html"><![CDATA[<style>.center {  width: auto;  display: table;  margin-left: auto;  margin-right: auto;}</style><h1>VMWare扩容虚拟机时“指定的虚拟磁盘需要进行修复”报错的解决方案</h1><p>在Windows命令提示符中依次执行以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd VMWare安装路径<br><br>vmware-vdiskmanager -R &quot;虚拟磁盘路径&quot;<br></code></pre></td></tr></table></figure><p>以我的安装路径为例：</p><div class="center"><style>.sbpeinxoscks{}</style><img src="/2025/05/06/md06/md06.png" class="sbpeinxoscks"></div><p>当出现提示<code>The virtual disk, 'E:\VIT1204 Ass1 Lab3\Ass1 Lab3.vmdk', was corrupted and has been successfully repaired.</code>即为修复成功。</p>]]></content>
    
    
    <summary type="html">该问题一般出现为虚拟机扩容时</summary>
    
    
    
    <category term="疑难杂症解决方案" scheme="http://example.com/categories/%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    
    
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>CentOS 7 dnf命令“conflicting requests”报错的解决方案</title>
    <link href="http://example.com/2025/05/06/md05/"/>
    <id>http://example.com/2025/05/06/md05/</id>
    <published>2025-05-06T11:15:17.000Z</published>
    <updated>2025-05-06T15:39:48.930Z</updated>
    
    <content type="html"><![CDATA[<style>.center {  width: auto;  display: table;  margin-left: auto;  margin-right: auto;}</style><h1>CentOS 7 dnf命令“conflicting requests”报错的解决方案</h1><h3 id="Reference">Reference</h3><ul><li><a href="https://blog.csdn.net/SerMa/article/details/131226445">centos7升级glibc2.25避坑指南</a></li><li><a href="https://blog.csdn.net/yutenys/article/details/122154162">centos7升级gcc&amp;glibc(踩坑)</a></li></ul><p>笔者在CentOS 7系统中安装Chrome浏览器时使用到了<code>dnf</code>命令来处理其安装包，但是出现了以下报错：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">错误：<br> 问题: conflicting requests<br>  - nothing provides libc.so.6(GLIBC_2.18)(64bit) needed by google-chrome-stable-136.0.7103.59-1.x86_64<br></code></pre></td></tr></table></figure><p>GLIBC是GNU发布的libc库，即c运行库。GLIBC是linux系统中最底层的api，几乎其它任何运行库都会依赖于GLIBC，而CentOS 7系统中的GLIBC版本为<code>GLIBC_2.17</code>，而报错信息则说明在使用这一命令时需要<code>GLIBC_2.18</code>及以上版本，因此我们需要对GLIBC库进行更新（直接升级到<code>GLIBC_2.31</code>版本）：</p><h3 id="1-基础环境准备">1. 基础环境准备</h3><p>将GLIBC库升级到目标版本需要满足两个基础条件：</p><ul><li>GCC版本为9.X.X及以上</li><li>make版本为4.0.X及以上</li></ul><h4 id="1）make升级">1）make升级</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">检查版本，满足条件可以跳过此步</span><br>make -v<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">----------------------------</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">安装依赖</span><br>yum -y install gcc gcc+<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">建立根目录</span><br>mkdir /backup<br><span class="hljs-meta prompt_"> </span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">下载make安装包</span><br>cd /backup<br>wget https://mirrors.aliyun.com/gnu/make/make-4.3.tar.gz<br><span class="hljs-meta prompt_"> </span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">解压压缩包并建立构建目录</span><br>tar -xf make-4.3.tar.gz<br>cd make-4.3<br>mkdir build<br>cd build<br><span class="hljs-meta prompt_"> </span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">指定安装到具体的目录下，此示例表示将make安装到/opt下</span><br>../configure --prefix=/opt/make<br><span class="hljs-meta prompt_"> </span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">编译安装</span><br>make &amp;&amp; make install<br><span class="hljs-meta prompt_"> </span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">建立软连接</span><br>ln -sf /opt/make/bin/make /usr/bin/make<br><span class="hljs-meta prompt_"> </span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">检查make版本</span><br>make --version<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">----------------------------</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">目标输出</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">GNU Make 4.3</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">为 x86_64-pc-linux-gnu 编译</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Copyright (C) 1988-2020 Free Software Foundation, Inc.</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">许可证：GPLv3+：GNU 通用公共许可证第 3 版或更新版本&lt;http://gnu.org/licenses/gpl.html&gt;。</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">本软件是自由软件：您可以自由修改和重新发布它。</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">在法律允许的范围内没有其他保证。</span><br></code></pre></td></tr></table></figure><h4 id="2）GCC升级">2）GCC升级</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">检查版本，满足条件可以跳过此步</span><br>gcc -v<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">----------------------------</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">安装升级依赖</span><br>yum install -y gcc-c++ glibc-devel mpfr-devel libmpc-devel gmp-devel glibc-devel.i686<br>​<br><span class="hljs-meta prompt_"># </span><span class="language-bash">下载gcc9.3.1安装包</span><br>cd /backup<br>wget https://ftp.gnu.org/gnu/gcc/gcc-9.3.0/gcc-9.3.0.tar.gz --no-check-certificate<br>​<br><span class="hljs-meta prompt_"># </span><span class="language-bash">解包并执行编译前的准备</span><br>tar -xf gcc-9.3.0.tar.gz<br>cd gcc-9.3.0<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">下载依赖包</span><br>./contrib/download_prerequisites<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">建立构建目录</span><br>mkdir build<br>cd build<br>​<br><span class="hljs-meta prompt_"># </span><span class="language-bash">指定安装到具体的目录下，此示例表示将make安装到/usr下</span><br>../configure --enable-checking=release --enable-language=c,c++ --disable-multilib --prefix=/usr<br>​<br><span class="hljs-meta prompt_"># </span><span class="language-bash">编译安装</span><br>make -j4 # -j代表编译时的任务数，一般有几个cpu核心就写几，构建速度会更快一些。该步骤执行时间很长！！！大概需要一个半钟头左右。<br>make install<br>​<br><span class="hljs-meta prompt_"># </span><span class="language-bash">7.安装完成后检查gcc版本</span><br>gcc -v<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">----------------------------</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">目标输出</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">使用内建 specs。</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">COLLECT_GCC=gcc</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">COLLECT_LTO_WRAPPER=/usr/libexec/gcc/x86_64-pc-linux-gnu/9.3.0/lto-wrapper</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">目标：x86_64-pc-linux-gnu</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">配置为：../configure --enable-checking=release --enable-language=c,c++ --disable-multilib --prefix=/usr</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">线程模型：posix</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">gcc 版本 9.3.0 (GCC)</span> <br></code></pre></td></tr></table></figure><h3 id="2-升级GLIBC库">2. 升级GLIBC库</h3><p>执行以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">下载安装包</span><br>cd /opt<br>wget https://mirrors.aliyun.com/gnu/glibc/glibc-2.31.tar.gz<br><br>tar -zxf glibc-2.31.tar.gz<br>cd glibc-2.31/<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">检查是否满足基本需求</span><br>cat INSTALL | grep -E &quot;newer|later&quot;<br><br>mkdir build<br>cd build<br><br>../configure  --prefix=/usr --disable-profile --enable-add-ons --with-headers=/usr/include --with-binutils=/usr/bin --disable-sanity-checks --disable-werror<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">一定要有这一步，python2安装会报错</span><br>yum install python3 <br><br>make -j8 # 使用8核编译后速度显著快于-j4<br>make install<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">解决新启动远程终端时报一个WARNING</span><br>make localedata/install-locales<br></code></pre></td></tr></table></figure><p>如果再升级后仍出现和原先相同的报错，使用强制安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo rpm -ivh --nodeps /tmp/chrome.rpm<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">该问题一般出现使用Linux dnf命令时</summary>
    
    
    
    <category term="疑难杂症解决方案" scheme="http://example.com/categories/%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    
    
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>CentOS 7 yum命令“There are no enabled repos”报错的解决方案</title>
    <link href="http://example.com/2025/05/06/md04/"/>
    <id>http://example.com/2025/05/06/md04/</id>
    <published>2025-05-06T07:31:10.000Z</published>
    <updated>2025-05-06T11:46:24.952Z</updated>
    
    <content type="html"><![CDATA[<style>.center {  width: auto;  display: table;  margin-left: auto;  margin-right: auto;}</style><h1>CentOS 7 yum命令“There are no enabled repos”报错的解决方案</h1><p>当在Linux CentOS当中使用<code>yum</code>命令并出现以下报错时：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">error:There are no enabled repositories in &quot;/etc/yum.repos.d&quot;, &quot;/etc/yum/repos.d&quot;<br></code></pre></td></tr></table></figure><p>并且使用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo yum grouplist<br></code></pre></td></tr></table></figure><p>后出现报错为</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">http://mirrors.cloud.aliyuncs.com/centos/7/os/x86_64/repodata/repomd.xml: [Errno 14] HTTP Error 404 - Not Found<br>Trying other mirror.<br></code></pre></td></tr></table></figure><p>这种情况一般就是YUM仓库（repository）的配置问题，导致无法正常解析，需要对YUM仓库进行换源。</p><h3 id="1-备份原yum源">1. 备份原yum源</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup<br></code></pre></td></tr></table></figure><h3 id="2-下载新的yum源">2. 下载新的yum源</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo wget -O /etc/yum.repos.d/CentOS-Base.repo https://mirrors.aliyun.com/repo/Centos-7.repo<br></code></pre></td></tr></table></figure><h3 id="3-更新配置">3. 更新配置</h3><p>随后运行以下命令更新配置即可：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">yum clear all<br>yum makecache<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">该问题一般出现使用Linux yum命令时</summary>
    
    
    
    <category term="疑难杂症解决方案" scheme="http://example.com/categories/%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    
    
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>VMWare “Capacity mismatch for disk XXX。”报错的解决方案</title>
    <link href="http://example.com/2025/05/05/md03/"/>
    <id>http://example.com/2025/05/05/md03/</id>
    <published>2025-05-05T12:17:42.000Z</published>
    <updated>2025-05-06T11:46:35.824Z</updated>
    
    <content type="html"><![CDATA[<style>.center {  width: auto;  display: table;  margin-left: auto;  margin-right: auto;}</style><h1>VMWare “Capacity mismatch for disk XXX。”报错的解决方案</h1><p>笔者在使用<em>VMware Workstation Pro</em>虚拟机环境完成<a href="https://loquattree.xyz/2025/05/05/php02/">课内大作业</a>的过程中需要导入一个老师提供的.ova文件，但是在导入时出现了以下报错：</p><div class="center"><style>.xikzwfkkbhfq{}</style><img src="/2025/05/05/md03/md03_pic01.png" class="xikzwfkkbhfq"></div><p>以下是解决方案：</p><h3 id="一、解压-ova文件">一、解压.ova文件</h3><p>​​.ova文件​​（Open Virtual Appliance）是一种​​虚拟设备打包格式，因此它实际上是一个压缩包文件，其中包含了以下内容：</p><ul><li>.ovf文件​​（Open Virtualization Format）：描述虚拟机的硬件配置（CPU、内存、网络等）、磁盘信息和其他元数据（XML格式）。</li><li>vmdk/.vhd等磁盘镜像​​：存储虚拟机的操作系统和数据（格式取决于虚拟化平台，如VMware用VMDK，Hyper-V用VHD）。</li><li>​​.mf文件​​（Manifest File）：是虚拟设备中的​​清单文件​​，用于验证文件完整性和确保虚拟机的安全导入。</li></ul><p>但是常见的解压缩工具都无法直接解压.ova文件，因此需要先手动将其后缀改为.zip格式再解压缩即可。解压结果如下图所示：</p><div class="center"><style>.dhomkyvsmcsq{}</style><img src="/2025/05/05/md03/md03_pic02.png" class="dhomkyvsmcsq"></div><h3 id="二、配置-ovf文件">二、配置.ovf文件</h3><p>笔者搜索到的绝大部分解决方案都是将.ovf文件中的虚拟机软件的版本号修改为当前自己使用到的版本号即可，如下图所示：</p><div class="center"><style>.vatjtuxyghex{}</style><img src="/2025/05/05/md03/md03_pic03.png" class="vatjtuxyghex"></div><p>可以一试，可能对低版本的VMware Workstation Pro是起效的，但是笔者使用的版本在修改后依旧会报错，因此需要更彻底的更改：</p><h4 id="1-删除“-Disk-ovf-capacity-“18103500800”-ovf-diskId-“vmdisk2”-ovf-fileRef-“file1”-ovf-format-“http-www-vmware-com-interfaces-specifications-vmdk-html-streamOptimized”-vbox-uuid-“bf38c60b-49bd-48c9-9c03-55acfcec0141”-”">1. 删除“&lt;Disk ovf:capacity=“18103500800” ovf:diskId=“vmdisk2” ovf:fileRef=“file1” ovf:format=“<a href="http://www.vmware.com/interfaces/specifications/vmdk.html#streamOptimized">http://www.vmware.com/interfaces/specifications/vmdk.html#streamOptimized</a>” vbox:uuid=“bf38c60b-49bd-48c9-9c03-55acfcec0141”/&gt;”</h4><p>在.ovf文件的最开始，内容可能不太一致，删除即可。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">DiskSection</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">Info</span>&gt;</span>List of the virtual disks used in the package<span class="hljs-tag">&lt;/<span class="hljs-name">Info</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">Disk</span> <span class="hljs-attr">ovf:capacity</span>=<span class="hljs-string">&quot;18103500800&quot;</span> <span class="hljs-attr">ovf:diskId</span>=<span class="hljs-string">&quot;vmdisk2&quot;</span> <span class="hljs-attr">ovf:fileRef</span>=<span class="hljs-string">&quot;file1&quot;</span> <span class="hljs-attr">ovf:format</span>=<span class="hljs-string">&quot;http://www.vmware.com/interfaces/specifications/vmdk.html#streamOptimized&quot;</span> <span class="hljs-attr">vbox:uuid</span>=<span class="hljs-string">&quot;bf38c60b-49bd-48c9-9c03-55acfcec0141&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">DiskSection</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="2-删除“-Image-uuid-“-bf38c60b-49bd-48c9-9c03-55acfcec0141-”-”">2. 删除“&lt;Image uuid=“{bf38c60b-49bd-48c9-9c03-55acfcec0141}”/&gt;”</h4><p>在.ovf文件的最末尾：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">AttachedDevice</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;HardDisk&quot;</span> <span class="hljs-attr">hotpluggable</span>=<span class="hljs-string">&quot;false&quot;</span> <span class="hljs-attr">port</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">device</span>=<span class="hljs-string">&quot;0&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">Image</span> <span class="hljs-attr">uuid</span>=<span class="hljs-string">&quot;&#123;bf38c60b-49bd-48c9-9c03-55acfcec0141&#125;&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">AttachedDevice</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="3-继续删除">3. 继续删除</h4><p>在文章中间部分，可搜索<code>/disk/vmdisk</code>找到，全部删除：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">Item</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">rasd:AddressOnParent</span>&gt;</span>0<span class="hljs-tag">&lt;/<span class="hljs-name">rasd:AddressOnParent</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">rasd:Caption</span>&gt;</span>disk2<span class="hljs-tag">&lt;/<span class="hljs-name">rasd:Caption</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">rasd:Description</span>&gt;</span>Disk Image<span class="hljs-tag">&lt;/<span class="hljs-name">rasd:Description</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">rasd:ElementName</span>&gt;</span>disk2<span class="hljs-tag">&lt;/<span class="hljs-name">rasd:ElementName</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">rasd:HostResource</span>&gt;</span>/disk/vmdisk2<span class="hljs-tag">&lt;/<span class="hljs-name">rasd:HostResource</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">rasd:InstanceID</span>&gt;</span>9<span class="hljs-tag">&lt;/<span class="hljs-name">rasd:InstanceID</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">rasd:Parent</span>&gt;</span>5<span class="hljs-tag">&lt;/<span class="hljs-name">rasd:Parent</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">rasd:ResourceType</span>&gt;</span>17<span class="hljs-tag">&lt;/<span class="hljs-name">rasd:ResourceType</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">Item</span>&gt;</span><br></code></pre></td></tr></table></figure><p>保存退出即可。</p><h3 id="三、配置-mf文件">三、配置.mf文件</h3><p>随便找一个文件Hash值的在线计算网站，计算出更改后的.ovf文件的SHA1值，并对应地将.mf文件中的值修改即可，不然无法导入.ovf文件：</p><div class="center"><style>.sowonmyjnyyd{}</style><img src="/2025/05/05/md03/md03_pic04.png" class="sowonmyjnyyd"></div><h3 id="四、导入-ovf文件">四、导入.ovf文件</h3><p>全部完成之后使用VMware Workstation Pro打开修改过后的.ovf文件即可：</p><div class="center"><style>.uiljeinhiutr{}</style><img src="/2025/05/05/md03/md03_pic05.png" class="uiljeinhiutr"></div><h2 id="Bingo！">Bingo！</h2>]]></content>
    
    
    <summary type="html">该问题一般出现在ova文件导入环节</summary>
    
    
    
    <category term="疑难杂症解决方案" scheme="http://example.com/categories/%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    
    
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>使用Linux部署Apache服务器</title>
    <link href="http://example.com/2025/05/05/php02/"/>
    <id>http://example.com/2025/05/05/php02/</id>
    <published>2025-05-05T09:27:00.000Z</published>
    <updated>2025-05-08T07:40:58.601Z</updated>
    
    <content type="html"><![CDATA[<style>.center {  width: auto;  display: table;  margin-left: auto;  margin-right: auto;}</style><h1>使用Linux部署Apache服务器</h1><h2 id="要求文档">要求文档</h2><div class="center"><style>.mzqhlpmcwevk{}</style><img src="/2025/05/05/php02/php02_pic08.png" class="mzqhlpmcwevk"></div><h2 id="Task-1">Task 1</h2><h3 id="一、在虚拟机环境中安装Apache服务器">一、在虚拟机环境中安装Apache服务器</h3><h4 id="1-为虚拟机配置网络环境">1. 为虚拟机配置网络环境</h4><p>对于一个全新的虚拟机环境来说，它是没有网络连接的，因此在安装Apache服务器之前需要先配置其网络环境。</p><h5 id="1）在VMWare当中将虚拟机的网络适配器更改为NAT模式">1）在VMWare当中将虚拟机的网络适配器更改为NAT模式</h5><div class="center"><style>.wjnvgtgtlkdt{}</style><img src="/2025/05/05/php02/php02_pic01.png" class="wjnvgtgtlkdt"></div><h5 id="2）修改虚拟机的网络配置信息">2）修改虚拟机的网络配置信息</h5><p>首先在Linux终端中输入命令以查看配置信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo vim /etc/sysconfig/network-scripts/ifcfg-ens33<br></code></pre></td></tr></table></figure><p>结果如下图所示：</p><div class="center"><style>.lkwxgrpgmlsw{}</style><img src="/2025/05/05/php02/php02_pic02.png" class="lkwxgrpgmlsw"></div><p>将其中的<code>ONBOOT=no</code>更改为<code>ONBOOT=yes</code>以启用ens33端口。</p><p>随后在重启网络配置之后输入<code>ifconfig</code>命令以查看虚拟机IP地址信息：</p><div class="center"><style>.pglhgxoxhjcy{}</style><img src="/2025/05/05/php02/php02_pic03.png" class="pglhgxoxhjcy"></div><p>记录其中ens33端口对应的IP地址，并将其添加到<code>/etc/sysconfig/network-scripts/ifcfg-ens33</code>文件当中：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">在源文件内容下新增：</span><br>GATEWAY= # 输入记录下来的IP地址<br>DNS1=114.114.114.114<br></code></pre></td></tr></table></figure><p>随后继续输入命令修改配置文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo vim /etc/resolv.conf<br></code></pre></td></tr></table></figure><p>将其中<code>nameserver</code>一行的值替换为<code>114.114.114.114</code>。</p><p>重启网络后成功ping通，网络环境配置完毕：</p><div class="center"><style>.uvbobgkbrcjk{}</style><img src="/2025/05/05/php02/php02_pic04.png" class="uvbobgkbrcjk"></div><h4 id="2-更新安装包">2. 更新安装包</h4><p>使用以下命令更新所有已安装的包：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo yum update<br>sudo yum install tree<br></code></pre></td></tr></table></figure><p><em>注：如有需要请参见<a href="https://loquattree.xyz/2025/05/06/md04/">CentOS yum命令“There are no enabled repos”报错的解决方案</a></em></p><h4 id="3-安装Apache服务器">3. 安装Apache服务器</h4><p>执行以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">安装并启用Apache服务器软件</span><br>sudo yum install -y httpd httpd-tools mod_ssl<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">启用并启动服务器</span><br>sudo systemctl enable httpd<br>sudo systemctl start httpd<br></code></pre></td></tr></table></figure><h4 id="4-检查配置结果">4. 检查配置结果</h4><h5 id="1）在Linux中安装chrome浏览器">1）在Linux中安装chrome浏览器</h5><p>执行以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">wget -O /tmp/chrome.rpm https://dl.google.com/linux/direct/google-chrome-stable_current_x86_64.rpm<br><br>su -<br><br>dnf localinstall /tmp/chrome.rpm<br></code></pre></td></tr></table></figure><p><em>注：如有需要请参见<a href="https://loquattree.xyz/2025/05/06/md05/">CentOS 7 dnf命令“conflicting requests”报错的解决方案</a></em></p><p>安装成功后如下图所示：</p><div class="center"><style>.fzxchktkmlbc{}</style><img src="/2025/05/05/php02/php02_pic05.png" class="fzxchktkmlbc"></div><h5 id="2）使用chrome浏览器检查配置结果">2）使用chrome浏览器检查配置结果</h5><p>执行以下命令以修改Apache配置文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo nano /etc/httpd/conf/httpd.conf<br></code></pre></td></tr></table></figure><p>使用Crtl+w检索<code>SeverName</code>，如下图所示添加<code>ServerName localhost:80</code>：</p><div class="center"><style>.vskdkpapkqmo{}</style><img src="/2025/05/05/php02/php02_pic06.png" class="vskdkpapkqmo"></div><p>保存并退出文件后继续执行命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">重启服务</span><br>sudo systemctl stop httpd<br>sudo systemctl restart httpd<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">切换到指定目录</span><br>cd /var/www/html<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">创建index页，在其中输入任意内容即可</span><br>sudo nano index.html<br></code></pre></td></tr></table></figure><div class="center"><style>.cyslmsrnjouj{}</style><img src="/2025/05/05/php02/php02_pic07.png" class="cyslmsrnjouj"></div><h3 id="二、在虚拟机环境中安装PHP服务器">二、在虚拟机环境中安装PHP服务器</h3><h4 id="1-安装PHP服务器">1. 安装PHP服务器</h4><p>依次执行以下命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">yum clean metadata<br><br>sudo yum install php-cli php-pdo php-fpm php-mysqlnd<br>sudo yum install php php-&#123;pear,cgi,common,curl,mbstring,gd,mysqlnd,gettext,bcmath,json,xml,fpm,intl,zip,imap&#125;<br></code></pre></td></tr></table></figure><h4 id="2-检查配置结果">2. 检查配置结果</h4><p>执行以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd /var/www/html<br><br>sudo mv index.html index.php<br><br>sudo nano /etc/httpd/conf/httpd.conf # 检索“DirectoryIndex”，在index.html同一行中继续添加index.php<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">重启服务</span><br>sudo systemctl stop httpd<br>sudo systemctl restart httpd<br></code></pre></td></tr></table></figure><p>随后在浏览器中输入<code>localhost/index.php</code>检查结果，如果有正常显示即为配置成功。</p><h2 id="Task-2">Task 2</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">创建存放目录</span><br>cd ~<br>mkdir public_html<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">修改主配置文件</span><br>sudo vim /etc/httpd/conf/httpd.conf<br></code></pre></td></tr></table></figure><div class="center"><style>.msebqrofsxtg{}</style><img src="/2025/05/05/php02/php02_pic09.png" class="msebqrofsxtg"></div><p>将第<code>120</code>, <code>125</code>和<code>131</code>中的地址都改为自定义地址<code>/home/rhauser/public_html</code>并重新启动Apache服务器即可。</p><p><em>注：如有需要请参见<a href="https://loquattree.xyz/2025/05/07/md07/">访问Apache服务器时出现“403 Forbidden”的解决方案</a></em></p><p>随后在<code>public_html</code>文件夹中创建一个<code>index.php</code>文件和一个空文件夹<code>sub_test</code>，将要求的模板写入<code>index.php</code>文件后保存退出。此时打开该文件和该文件夹的效果应该如下所示：</p><div class="center"><style>.orcvkjomlhor{}</style><img src="/2025/05/05/php02/php02_pic10.png" class="orcvkjomlhor"></div><div class="center"><style>.fdkvjkbgwhfn{}</style><img src="/2025/05/05/php02/php02_pic11.png" class="fdkvjkbgwhfn"></div><h2 id="Task-3">Task 3</h2><p>执行以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo mkdir -p /home/rhauser/public_html/secure/development/restricted # -p确保自动创建父级目录<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">进入受限文件夹并创建目标文件</span><br>cd /home/rhauser/public_html/secure/development/restricted<br>sudo nano index.php<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">----------------------------</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">在index.php中写入以下内容</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">&lt;!DOCTYPE html&gt;</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">&lt;html&gt;</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">&lt;<span class="hljs-built_in">head</span>&gt;</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">&lt;title&gt;Example site name&lt;/title&gt;</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">&lt;/head&gt;</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">&lt;body&gt;</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">&lt;h1&gt;You are visiting the restricted area!!!&lt;/h1&gt;</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">&lt;br&gt;&lt;br&gt;</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">&lt;!-- Any other links goes here --&gt;</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">&lt;br&gt;&lt;br&gt;</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">&lt;pre&gt;</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Current Directory: &lt;?= <span class="hljs-built_in">dirname</span>(__FILE__) ?&gt;</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">&lt;/pre&gt;</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">----------------------------</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">修改Apache配置文件</span><br>sudo vim /etc/httpd/conf/httpd.conf<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">----------------------------</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">目标样式：</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-comment"># 建立虚拟路径和物理路径之间的映射</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Alias /restricted /home/rhauser/public_html/secure/development/restricted</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">&lt;Directory <span class="hljs-string">&quot;/home/rhauser/public_html&quot;</span>&gt;</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">    Options Indexes FollowSymLinks</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">    AllowOverride None</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">    Require all granted</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">&lt;/Directory&gt;</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">----------------------------</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">检查语法是否正确并重启服务</span><br>sudo apachectl configtest  <br>sudo systemctl restart httpd<br></code></pre></td></tr></table></figure><p>完成后访问限制路径内的索引页的效果如下图所示：</p><div class="center"><style>.dcevtgbgnqdu{}</style><img src="/2025/05/05/php02/php02_pic12.png" class="dcevtgbgnqdu"></div><h2 id="Task-4">Task 4</h2><p>执行以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">首先需要确认主配置允许使用 .htaccess 文件：</span><br>sudo vim /etc/httpd/conf/httpd.conf<br><span class="hljs-meta prompt_"># </span><span class="language-bash">----------------------------</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">在 /etc/httpd/conf/httpd.conf 中找到对应目录配置</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">&lt;Directory <span class="hljs-string">&quot;/var/www/html&quot;</span>&gt;</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">    AllowOverride AuthConfig</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">    <span class="hljs-comment"># 其他配置...</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">&lt;/Directory&gt;</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">----------------------------</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">创建密码文件并添加第一个用户Alice</span><br>sudo htpasswd -c /etc/httpd/.htpasswd Alice # 系统会提示输入密码，输入&quot;redhat&quot;并确认<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">添加第二个用户Bob</span><br>sudo htpasswd /etc/httpd/.htpasswd Bob # 同样输入密码&quot;redhat&quot;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">设置适当权限</span><br>sudo chown apache:apache /etc/httpd/.htpasswd<br>sudo chmod 640 /etc/httpd/.htpasswd<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">创建 .htaccess 文件</span><br>sudo vim /home/rhauser/public_html/secure/development/restricted/.htaccess<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">文件内容如下：</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">----------------------------</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">AuthType Basic</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">AuthName <span class="hljs-string">&quot;Restricted Area&quot;</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">AuthUserFile /etc/httpd/.htpasswd</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Require valid-user</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">----------------------------</span><br></code></pre></td></tr></table></figure><p>完成后就能实现访问限制区域后需要登录的效果：</p><div class="center"><style>.pqqzstfldogb{}</style><img src="/2025/05/05/php02/php02_pic13.png" class="pqqzstfldogb"></div><p>登录后就能收到访问限制提示：</p><div class="center"><style>.ernfwdqbvtcy{}</style><img src="/2025/05/05/php02/php02_pic14.png" class="ernfwdqbvtcy"></div><h2 id="Task-5">Task 5</h2><p>执行以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">创建新用户并设置密码</span><br>sudo useradd -m sxxxxxxx<br>echo &quot;redhat&quot; | sudo passwd --stdin sxxxxxxx<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">将新用户添加到sudoers当中</span><br>su -<br>sudo usermod -aG wheel sxxxxxxx<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">创建新的目录</span><br>sudo -u sxxxxxxx mkdir /home/sxxxxxxx/public_html<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">创建新的php文件</span><br>sudo su - sxxxxxxx<br>sudo vim ~/public_html/index.php<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">文件内容如下：</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">----------------------------</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">&lt;!DOCTYPE html&gt;</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">&lt;html&gt;</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">&lt;<span class="hljs-built_in">head</span>&gt;</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">&lt;title&gt;Example site name&lt;/title&gt;</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">&lt;/head&gt;</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">&lt;body&gt;</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">&lt;h1&gt;Welcome to S8118532<span class="hljs-string">&#x27;s Page!!&lt;/h1&gt;</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">&lt;br&gt;&lt;br&gt;</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">&lt;!-- Any other links goes here --&gt;</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">&lt;br&gt;&lt;br&gt;</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">&lt;pre&gt;</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">Current Directory: &lt;?= dirname(__FILE__) ?&gt;</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">&lt;/pre&gt;</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">----------------------------</span></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">启用用户目录模块</span></span><br>sudo sed -i &#x27;s/^#UserDir public_html/UserDir public_html/&#x27; /etc/httpd/conf.d/userdir.conf<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">设置目录权限</span></span><br>sudo chmod 711 /home/sxxxxxxx<br>sudo chmod 755 /home/sxxxxxxx/public_html<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">启用用户目录功能</span></span><br>sudo nano /etc/httpd/conf.d/userdir.conf<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">文件内容修改如下：</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">----------------------------</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">&lt;IfModule mod_userdir.c&gt;</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">    # 注释掉禁用行，启用用户目录功能</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">    #UserDir disabled</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">    UserDir public_html</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">    UserDir disabled root  # 禁止root用户使用此功能</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">&lt;/IfModule&gt;</span></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">&lt;Directory &quot;/home/*/public_html&quot;&gt;</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">    AllowOverride FileInfo AuthConfig Limit Indexes</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">    Options MultiViews Indexes SymLinksIfOwnerMatch IncludesNoExec</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">    Require method GET POST OPTIONS</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">&lt;/Directory&gt;</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">----------------------------</span></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">重启Apache</span></span><br>sudo systemctl restart httpd<br>sudo systemctl enable httpd<br></code></pre></td></tr></table></figure><p>最终效果如下所示：</p><div class="center"><style>.hcsxutdovfdc{}</style><img src="/2025/05/05/php02/php02_pic15.png" class="hcsxutdovfdc"></div><h2 id="Task-6">Task 6</h2><p>执行以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">创建错误页目录及文件</span><br>mkdir -p /home/rhauser/public_html/error<br>vi /home/rhauser/public_html/error/403.php<br>vi /home/rhauser/public_html/error/404.php<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">设置权限（确保Apache用户可读）</span><br>chmod 755 /home/rhauser/public_html/error<br>chmod 644 /home/rhauser/public_html/error/*.php<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">修改Apache配置</span><br>sudo vi /etc/httpd/conf/httpd.conf<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">---------------------</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">在配置文件中 ​​全局或对应&lt;VirtualHost&gt;段​​ 添加：</span><br>ErrorDocument 403 /error/403.php # 路径 /error/... 是相对于DocumentRoot的，无需写绝对路径<br>ErrorDocument 404 /error/404.php # 这里我输入的内容是“This is a diy 404 page!!”<br><span class="hljs-meta prompt_"># </span><span class="language-bash">---------------------</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">修改限制目录的权限</span><br>chmod 611 /home/rhauser/public_html/secure/development/restricted<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">重启Apache服务器</span><br>sudo systemctl restart httpd<br></code></pre></td></tr></table></figure><p>完成后，访问一个不存在的页面，例如<code>localhost/notfound</code>页面，打开的效果如下图所示：</p><div class="center"><style>.zmqyvxmobrpp{}</style><img src="/2025/05/05/php02/php02_pic16.png" class="zmqyvxmobrpp"></div>]]></content>
    
    
    <summary type="html">VIT1024 Ass01 Lab3实现小结</summary>
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="PHP" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/PHP/"/>
    
    
    <category term="PHP" scheme="http://example.com/tags/PHP/"/>
    
    <category term="linux" scheme="http://example.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>软件设计师 上午题 操作系统知识</title>
    <link href="http://example.com/2025/04/28/note33/"/>
    <id>http://example.com/2025/04/28/note33/</id>
    <published>2025-04-28T14:32:24.000Z</published>
    <updated>2025-05-08T08:27:13.937Z</updated>
    
    <content type="html"><![CDATA[<style>.center {  width: auto;  display: table;  margin-left: auto;  margin-right: auto;}.heimu, .heimu a, a .heimu, .heimu a.new {  background-color: #252525;  color: #252525;  text-shadow: none;}.heimu:hover, .heimu:active,.heimu:hover .heimu, .heimu:active .heimu {  color: white !important;}.heimu:hover a, a:hover .heimu,.heimu:active a, a:active .heimu {  color: lightblue !important;}.heimu:hover .new, .heimu .new:hover, .new:hover .heimu,.heimu:active .new, .heimu .new:active, .new:active .heimu {  color: #BA0000 !important;}</style><h1>软件设计师 上午题 操作系统知识</h1><p>操作系统(Operating System, OS)是为裸机配置的一种系统软件，用于填补人与机器之间的鸿沟。操作系统在计算机系统中的地位如下图所示：</p><div class="center"><style>.usufymowbehm{}</style><img src="/2025/04/28/note33/note33_pic01.png" class="usufymowbehm"></div><p>不难发现，操作系统是裸机上的第一层软件，是对硬件系统功能的首次扩充，是用户与计算机之间的接口。有了操作系统，系统软件和应用软件等大量其它软件才有了使用基础，因此，操作系统已成为现代计算机系统中必不可少的最重要的系统软件。<br>操作系统的核心功能模块分为进程管理、存储管理、设备管理、文件管理和作业管理五个部分，它们共同构成了操作系统对计算机硬件和软件资源的管理体系。</p><h2 id="一、进程管理">一、进程管理</h2><p>进程管理也称之为处理机管理，为了描述系统中程序执行时的动态变化，操作系统中引入了进程的概念。所谓进程管理即管理计算机中正在运行的程序，其管理重点是研究诸进程之间的并发特性，以及进程之间相互合作与资源竞争产生的问题，进而确保CPU资源被合理分配。</p><h3 id="Ⅰ-基本概念">Ⅰ 基本概念</h3><h4 id="1-程序与进程">1. 程序与进程</h4><p>程序的执行方式大致可以分为顺序执行和并发执行两类：</p><p><strong>1）程序顺序执行的特征</strong>：</p><p>顺序执行是指程序严格按照代码编写的顺序依次执行，前一条语句执行完毕才会执行下一句。程序顺序执行时的主要特征包括顺序性、封闭性和可再现性。<br>此外，有一种有向无环图叫做前驱图，它可以用来描述程序中各个任务之间的依赖关系。因此顺序执行的任务就可以转换为一条线性前驱图，如下图所示：</p><div class="center"><style>.uvddeoooqjej{}</style><img src="/2025/04/28/note33/note33_pic02.png" class="uvddeoooqjej"></div><p>其中，输入结束之后才能进行计算，计算结束之后才能进行输出。</p><p><strong>2）程序并发执行的特征</strong>：</p><p>若在计算机系统当中采用多道程序设计技术，则主存中的多道程序可处于并发执行状态。虽然每个作业中有前驱关系的各程序段不能并行执行，但是每个作业中没有前驱关系的程序段或者不同作业的程序段可以并行执行。</p><div class="center"><style>.vnthzkkjelti{}</style><img src="/2025/04/28/note33/note33_pic03.png" class="vnthzkkjelti"></div><p>若每个程序有三个程序段：输入<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>I</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">I_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>、计算<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>C</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">C_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>和输出<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">P_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。如图4-2所示，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>I</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">I_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>就可以和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>C</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">C_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>并行执行，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>I</mi><mn>3</mn></msub></mrow><annotation encoding="application/x-tex">I_3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>、<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>C</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">C_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">P_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>也可以并行执行等等。<br>同时，程序并发执行时有以下特征：</p><ul><li><strong>失去了程序的封闭性</strong>：在顺序执行时，程序独占所有资源，其执行过程不受外界干扰，结果完全由程序自身决定，这也就是所谓的封闭性。而在并发执行的过程中，多个程序共享资源就会打破这一封闭性。</li><li><strong>程序和机器的执行程序的活动不再一一对应</strong>：在顺序执行中，程序指令严格按照代码顺序执行，程序行为是可预测的。但是在并发执行当中因CPU调度、中断、抢占等问题，指令的执行顺序可能被打乱。</li><li><strong>并发程序间的相互制约性</strong>：并发程序由于共享资源或者协作关系，会彼此制约和影响。其中又分为直接制约和间接制约。前者是指程序间进行显式通信，而后者指的是竞争同一资源导致阻塞。</li></ul><hr><div class="center"><style>.tmxesttnktfr{}</style><img src="/2025/04/28/note33/note33_pic04.png" class="tmxesttnktfr"></div><p>首先需要了解的是什么是信号量和PV操作。信号量本质上是一个计数器+等待队列+原子操作(即PV操作)。其中计数器中的整型变量，也就是题目中所谓的<code>S1</code>，<code>S2</code>，<code>S3</code>，<code>S4</code>，是用来表示当前可用的“通行许可证”数量，可以用来衡量当前系统中剩余的资源数量。而P操作（Proberen，荷兰语“通过”）是申请资源，操作结果是计数器<code>S</code>-=1，V操作（Verhogen，荷兰语“释放”）是释放资源，作结果是计数器<code>S</code>+=1。另外，信号量是针对于进程转换这个过程而言的，也就是图中的每一个“箭头”，而非针对进程本身。<strong>在每一个箭头当中应该先完成一次V操作再完成一次P操作</strong>。<br>那么对于本题来说，<code>S1</code>是指P1P2之间的箭头，其余以此类推。那么P1进行时，应该先分别完成一次V(S1)和一次V(S2)；然后为了使P2准备就绪，就应该再完成一次P(S1)。重复执行这个思路就能得到最终答案。</p><hr><div class="center"><style>.nrvjthpfkvwg{}</style><img src="/2025/04/28/note33/note33_pic05.png" class="nrvjthpfkvwg"></div><p>BAC，捋顺<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>I</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">I_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>-&gt;<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>C</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">C_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>-&gt;<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">P_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的关系即可。</p><h4 id="2-进程的状态及其状态间的切换">2. 进程的状态及其状态间的切换</h4><p>进程一般有3种基本状态：运行、就绪和阻塞：</p><ul><li>运行：当一个进程在处理机上运行时，则称该进程处于运行状态。</li><li>就绪：一个进程获得了除处理机外的一切所需资源，一旦得到处理机即可运行，则称此进程处于就绪状态。</li><li>阻塞：阻塞也称等待或者睡眠状态，当一个进程正在等待某一事件发生而暂停运行（即使把处理机分配给进程也无法运行），此时该进程处于阻塞状态。</li></ul><p>当在这三种基本状态中捋顺了转换关系，就构成了三态模型：</p><div class="center"><style>.jsmybqpnyybe{}</style><img src="/2025/04/28/note33/note33_pic06.png" class="jsmybqpnyybe"></div><h3 id="Ⅱ-进程间的通信">Ⅱ 进程间的通信</h3><p>显而易见，在一个多道程序环境的系统当中，进程间必然存在资源共享和相互合作的问题，而进程通信就是指各个进程之间交换信息的过程。</p><h4 id="1-同步与互斥">1. 同步与互斥</h4><blockquote><p>同步是合作进程间的直接制约问题，互斥是申请临界资源进程间的间接制约问题。<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="软件设计师教程（第五版）. (2018).">[1]</span></a></sup></p></blockquote><p>用人话说就是，同步是多个进程需要按照特定的顺序协作完成任务，互斥是多个进程竞争同一资源，需要保证同一时间仅一个进程访问。</p><p><strong>1）进程间的同步</strong></p><p>在计算机系统当中，多个进程可以并发执行，每个进程都以各自独立的、不可预知的速度向前推进，但是需要在某些确定点上协调相互合作进程间的工作。例如进程A煮米，进程B炒米，那显然必须是进程A完成了之后才能进行进程B，否则进程B就要停下来等待进程A。</p><p><strong>2）进程间的互斥</strong></p><p>在多道程序系统环境当中，有一种资源一次只能供一个进程使用，这种资源我们称其为临界资源，比如打印机。那么进程之间的互斥就是系统中多个进程因争用临界资源而发生的互斥执行。</p><p><strong>3）临界区管理的原则</strong></p><p>临界区即进程中对临界资源实施操作的那段程序，对互斥临界区的管理有以下几条原则：</p><ul><li>有空即进。</li><li>无空则等。</li><li>有限等待：应该保证进程在<strong>有限的时间</strong>内能够进入临界区，以免其陷入“饥饿”状态。</li><li>让权等待：当进程不能进入自己的临界区时，应立即释放处理机，以免进程陷入忙等待（如果暂时轮不到你的时候就先去忙别的事情）。</li></ul><h4 id="2-信号量机制">2. 信号量机制</h4><p>在本文的前边我们已经了解过信号量和PV操作相关的内容，这里我们主要探讨如何使用PV操作实现进程间的同步和互斥：</p><p><strong>1）利用PV操作实现进程间的同步</strong></p><p>要实现进程的同步可以用一个信号量与消息联系起来，当信号量的值为0时表示希望的消息未产生，当信号量的值为非0的时候表示希望的消息已经存在。那么进程就可以通过调用P操作测试消息是否到达，通过调用V操作通知消息已经准备好。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c">semaphore sync = <span class="hljs-number">0</span>; <span class="hljs-comment">// 初始值为0的同步信号量</span><br><br>Process <span class="hljs-title function_">A</span><span class="hljs-params">()</span> <br>&#123;<br>    <span class="hljs-comment">// 执行操作A</span><br>    V(sync);    <span class="hljs-comment">// 通知进程B操作A已完成</span><br>&#125;<br><br>Process <span class="hljs-title function_">B</span><span class="hljs-params">()</span> <br>&#123;<br>    P(sync);    <span class="hljs-comment">// 等待操作A完成</span><br>    <span class="hljs-comment">// 执行操作B</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>2）利用PV操作实现进程间的互斥</strong></p><p>令信号量S的初值为1，当进入临界区时执行P操作，退出临界区时执行V操作。这样一来，每当有程序段调用临界资源时S就能减1，防止共用一个临界资源的情况产生。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c">semaphore mutex = <span class="hljs-number">1</span>; <span class="hljs-comment">// 初始值为1的互斥信号量</span><br><br>Process <span class="hljs-title function_">P1</span><span class="hljs-params">()</span> <br>&#123;<br>    P(mutex);    <span class="hljs-comment">// 进入临界区前申请锁</span><br>    <span class="hljs-comment">// 临界区代码</span><br>    V(mutex);    <span class="hljs-comment">// 离开临界区后释放锁</span><br>&#125;<br><br>Process <span class="hljs-title function_">P2</span><span class="hljs-params">()</span> <br>&#123;<br>    P(mutex);<br>    <span class="hljs-comment">// 临界区代码</span><br>    V(mutex);<br>&#125;<br></code></pre></td></tr></table></figure><hr><div class="center"><style>.nyykfoxutcuy{}</style><img src="/2025/04/28/note33/note33_pic07.png" class="nyykfoxutcuy"></div><p><strong>D</strong>。系统内有两台打印机，那么说明起始的可用资源总数应为2，即S的最大值应为2。当第一个进程想要调用打印机时，它就需要进行一次P(S)操作，S变为1。随后依次类推，每个进程逐次进行P(S)操作，最后就得到了S的最小值为-(n-2)。</p><hr><div class="center"><style>.hbvvcmdgzepv{}</style><img src="/2025/04/28/note33/note33_pic08.png" class="hbvvcmdgzepv"></div><p><strong>BA</strong>，不难发现，生产者甲和生产者乙两者之间需要保持一种同步关系，而生产者甲和生产者乙自身所处的过程则需要保持一种互斥关系。在之前的学习中我们了解到，如果要保持同步关系，需要先执行一次V操作通知资源已经准备好，而如果要保持互斥关系，需要先执行一次P操作来占用资源。据此分析，S1是一个互斥信号量，在存放前减一，在取出后加一，用来表示的应该是半成品箱中被占用的资源，<strong>因此其初值应该为n</strong>；而S2是一个同步信号量，用来表示生产者甲通知生产者乙已经完成了一个半成品，<strong>因此其初值应该为0</strong>。此外，根据题目，S也是一个互斥信号量，鉴于它在每一个临界区中都会出现，它表示的应该是半成品箱是否正在被占用以存取物品，<strong>因此其初值应该为1</strong>。</p><hr><div class="center"><style>.bywlghthphjf{}</style><img src="/2025/04/28/note33/note33_pic09.png" class="bywlghthphjf"></div><p><strong>CD</strong>， <span class="heimu"><s>信号量S应该与一个互斥的进程有关，即当前还有几个购票终端可以使用，那么这个信号量的初值就应该为n-1。</s></span>  用户在选定具体的终端<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">P_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>之后需要占用这个终端，因此需要一个互斥信号量S，<strong>其初始值应该为1</strong>；<strong>(a)处应该为P(S)</strong>，因为当一个乘客想要买票时会占用一个终端；<strong>(b)处和©处都应该是V(S)</strong>，因为此时已经完成了购票流程，可以释放终端了。</p><h3 id="Ⅲ-死锁">Ⅲ 死锁</h3><p>死锁现象的一般表现为：多个进程/线程均无法继续执行，系统整体或部分功能停滞（如程序无响应、任务无法完成），在本小节中我们仅了解同类资源分配不当引起的死锁。<br>当系统中有n个进程，每个进程所需要的资源数为k，系统中的资源总数为m，且系统采用的分配策略是轮流地为每个进程分配资源时，若<strong>m &lt; n*（k-1）+1</strong>，则会发生死锁。</p><h4 id="1-进程资源图">1. 进程资源图</h4><p>进程资源图是一种​​有向图​​，用于描述操作系统中的​​进程与资源之间的分配和请求关系​​，是分析和检测死锁的重要工具，其一般形式如下图所示：</p><div class="center"><style>.vfecpsekbggi{}</style><img src="/2025/04/28/note33/note33_pic10.png" class="vfecpsekbggi"></div><p>其中，一个圆圈代表一个进程，一个矩形代表一个资源，其中的圆圈个数是其资源的数量。</p><p>不同数字代表的箭头含义不同：</p><ol><li>表示P1向R申请一个资源</li><li>表示R向P1分配一个资源</li><li>表示<strong>R先分配给P1一个资源</strong>，P1再向R申请一个资源</li><li>R已经向三个进程分配了自己全部的三个资源，此时P1再向R申请资源就会进入等待态，即堵塞状态。</li></ol><p>此外，进程资源图是可化简的，其步骤如下所述：</p><ol><li>把不阻塞的进程的所有边都去掉，形成一个孤立的点，再把系统分配给这个进程的资源回收回来。</li><li>看剩下的进程有哪些是不阻塞的，然后又把它们逐个变成孤立的点。</li><li>最后，所有的资源和进程都变成孤立的点。这样的图就叫做“可完全简化”。</li></ol><p>如果一个图可完全简化，该系统就不会产生死锁，反之就会产生死锁。</p><hr><div class="center"><style>.knmrrxmcoifn{}</style><img src="/2025/04/28/note33/note33_pic11.png" class="knmrrxmcoifn"></div><p><strong>BC</strong>，在图(a)中，R1中两个资源已经分配完毕但依旧有P2的申请，因此P2是一个堵塞结点，P1同理，图(b)同理。</p><hr><h4 id="2-死锁的避免策略">2. 死锁的避免策略</h4><p>银行家算法​​是一种经典的​​死锁避免算法​​，由Dijkstra提出，用于确保操作系统在分配资源时不会进入死锁状态。它的核心思想是​​模拟资源分配​​，仅当分配后系统仍处于​​安全状态​​时才批准请求，否则让进程等待。</p><blockquote><p>银行家（操作系统）需要确保手头的现金（资源）能满足所有客户（进程）的贷款需求，同时避免资金链断裂（死锁）。</p></blockquote><div class="center"><style>.wvqbwgqrsyjw{}</style><img src="/2025/04/28/note33/note33_pic12.png" class="wvqbwgqrsyjw"></div><p>以此题为例，通过对已分配资源数的加和计算，不难发现R1，R2和R3的剩余资源数分别为1、1、0。<br>那么显然此时不能再继续执行还需要R3分配资源的进程了，观察后发现只有P4符合这一条件，因此执行序列的第一个应该为P4，<strong>排除①②</strong>。<br>下面可以讨论序列③能否完成，可以借助下图分析：</p><div class="center"><style>.hntmokbfurww{}</style><img src="/2025/04/28/note33/note33_pic13.png" class="hntmokbfurww"></div><p>如果一个进程最终能够执行完毕，我们就给它打上一个<code>True</code>的标志。而检查其是否能够执行完毕的条件即为<code>可用</code>能否覆盖<code>需求</code>。同时，一个进程完成之后会释放所有已经占用的资源，即<code>可用+已分</code>部分的内容。据此分析，P1是无法完成的，因此<strong>排除序列③</strong>。</p><h3 id="Ⅳ-线程">Ⅳ 线程</h3><blockquote><p>传统的进程有两个基本属性:可拥有资源的独立单位;可独立调度和分配的基本单位。引入线程的原因是进程在创建、撤销和切换中，系统必须为之付出较大的时空开销，故在系统中设置的进程数目不宜过多，进程切换的频率不宜太高，这就限制了并发程度的提高。引入线程后，将传统进程的两个基本属性分开，线程作为调度和分配的基本单位，进程作为独立分配资源的单位。用户可以通过创建线程来完成任务，以减少程序并发执行时付出的时空开销。<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="软件设计师教程（第五版）. (2018).">[1]</span></a></sup></p></blockquote><div class="center"><table><thead><tr><th><strong>对比维度</strong></th><th><strong>进程（Process）</strong></th><th><strong>线程（Thread）</strong></th></tr></thead><tbody><tr><td><strong>定义</strong></td><td>操作系统资源分配的基本单位，拥有独立的内存空间。</td><td>进程内的执行单元，共享进程资源，是CPU调度的基本单位。</td></tr><tr><td><strong>资源占用</strong></td><td>独立的内存、文件句柄、CPU时间等。</td><td>共享进程的内存和资源，仅私有栈和寄存器。</td></tr><tr><td><strong>创建/销毁开销</strong></td><td>高（需分配独立资源）。</td><td>低（共享进程资源，仅需少量初始化）。</td></tr><tr><td><strong>切换成本</strong></td><td>高（需切换内存空间、更新页表等）。</td><td>低（仅切换寄存器、栈等线程私有数据）。</td></tr><tr><td><strong>独立性</strong></td><td>崩溃后不影响其他进程。</td><td>崩溃可能导致整个进程终止（共享地址空间）。</td></tr><tr><td><strong>并发性</strong></td><td>多进程依赖进程间切换（上下文切换成本高）。</td><td>多线程可真正并行（同一进程内线程切换成本低）。</td></tr><tr><td><strong>适用场景</strong></td><td>需要隔离性、安全性的任务（如不同用户的程序）。</td><td>需要高并发、低延迟的任务（如Web服务器处理请求）。</td></tr><tr><td><strong>类比</strong></td><td>独立的“工厂”，拥有自己的设备和资源。</td><td>工厂中的“工人”，共享设备但独立执行任务。</td></tr></tbody></table></div><p>此外，同一个进程中的不同线程都可以共享这个进程中的资源。</p><h2 id="二、存储管理">二、存储管理</h2><blockquote><p>存储器管理的对象是主存存储器简称主存或内存。存储器是计算机系统中的关键性资源，是存放各种信息的主要场所。尽管近年来内存越来越便宜、容量越来越大，但系统软件、应用软件在功能及其所需存储空间等方面都在急剧膨胀，如何对存储器实施有效的管理，不仅直接影响到存储器的利用率，而且还对系统性能有很大的影响。存储器管理的主要功能包括主存空间的分配和回收、提高主存的利用率、扩充主存、对主存信息实现有效保护。<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="软件设计师教程（第五版）. (2018).">[1]</span></a></sup></p></blockquote><h4 id="前置知识：局部性原理">前置知识：局部性原理</h4><p>局部性原理是计算机系统的一个重要行为特征，它描述了程序在执行过程中对内存访问的规律性，即程序更倾向于在短时间内集中访问某些特定的内存区域，而不是均匀地访问整个地址空间：</p><ul><li>时间局部性：如果一个数据或指令被访问过，那么它在不久的将来很可能再次被访问。</li><li>空间局部性：如果一个数据被访问，那么它附近的数据（如相邻的内存地址）也可能很快被访问。</li></ul><h3 id="Ⅰ-分页存储管理">Ⅰ 分页存储管理</h3><p>进行分页管理的原理即为将一个进程的地址空间划分成若干个大小相等的区域，称为页，同时将主存空间划分成与页相等大小的若干个物理块，称为块。在实际运行时会将若干个页分别装入多个不相邻接的块中。</p><div class="center"><style>.eyawjnyllycr{}</style><img src="/2025/04/28/note33/note33_pic14.png" class="eyawjnyllycr"></div><p>分页系统的地址结构如上图所示，由页号和偏移量（即页内地址）两部分组成。其中页号是高位部分，用于索引页表，而页内偏移是低位部分，直接对应物理页内的位置。</p><hr><div class="center"><style>.fcyeryyxkbxt{}</style><img src="/2025/04/28/note33/note33_pic16.png" class="fcyeryyxkbxt"></div><p><strong>AC</strong>，根据题意不难发现，页面0、页面2和页面4在内存当中，若需淘汰应在在三个页面当中淘汰。而根据程序的局部性原理，页面0最近被访问过，页面2、页面4既被访问过又被修改过，因此最有可能淘汰的是页面0。此外，由于页面大小为4KB，即4×2^10字节，亦即2^12字节，说明该系统中页有12位。也就是说只有当<strong>页面偏移量为12时</strong>才能覆盖所有位，如此一来便确定了页面偏移量。而题目中给出的2C25H等同于0x2C25（H用来表明该数采用十六进制表示），也就是一共有4个数，即4×4=16位。那么在后12位为页面偏移量的情况下，剩余的前4位，即第1个数就是页号了，为2。随后再根据页表内的信息将页号转换为页帧号（即物理块号），就得到了<strong>物理地址为4C25H</strong>。</p><h3 id="Ⅱ-段页式存储管理">Ⅱ 段页式存储管理</h3><p>段页式存储管理是一种对段式存储和页式存储“各取所长”的存储管理方式，它先将整个主存划分成大小相等的存储块，随后将用户程序按程序的逻辑关系分为若干个段，再将一个段划分成若干个页。据此就形成了由段号、段内页号和业内地址三部分组成的段页式管理的地址：</p><div class="center"><style>.fcffrvpqkdtq{}</style><img src="/2025/04/28/note33/note33_pic17.png" class="fcffrvpqkdtq"></div><hr><div class="center"><style>.lhfhtyyrdeby{}</style><img src="/2025/04/28/note33/note33_pic18.png" class="lhfhtyyrdeby"></div><p><strong>B</strong>，简单的分段计算，唯一需要注意的是页号所在段的长度描述的是每个段<strong>最大允许</strong>有多少多少个页。</p><h2 id="三、设备管理">三、设备管理</h2><h3 id="Ⅰ-缓冲技术">Ⅰ 缓冲技术</h3><p>缓冲技术是一种通过临时存储数据来协调不同速度设备或组件之间数据传输的方法，旨在解决速度不匹配问题，提高系统效率和性能。其核心原理是在数据生产者（如CPU、磁盘）与消费者（如打印机、网络）之间设立一个中间存储区（缓冲区），允许两者以各自最佳速率运行，减少等待时间。此外，亦有单缓冲区和双缓冲区的差别：</p><div class="center"><table><thead><tr><th><strong>特性</strong></th><th><strong>单缓冲区</strong></th><th><strong>双缓冲区</strong></th></tr></thead><tbody><tr><td><strong>结构</strong></td><td>仅一个缓冲区</td><td>两个缓冲区交替使用（Buffer A/B）</td></tr><tr><td><strong>工作流程</strong></td><td>生产者填满→消费者读取→生产者等待</td><td>生产者填满A时，可立即填充B，消费者同时读取A</td></tr><tr><td><strong>阻塞情况</strong></td><td>生产/消费过程可能相互阻塞</td><td>生产与消费可并行，减少阻塞</td></tr><tr><td><strong>效率</strong></td><td>较低</td><td>较高</td></tr><tr><td><strong>适用场景</strong></td><td>低速或非实时场景</td><td>高速或实时需求</td></tr></tbody></table></div><hr><div class="center"><style>.qbbdidgsemww{}</style><img src="/2025/04/28/note33/note33_pic19.png" class="qbbdidgsemww"></div><p><strong>CB</strong>，</p><p>单缓冲工作的过程图和并行工作的示意图如下图所示：</p><div class="center"><style>.pcyeafufrqme{}</style><img src="/2025/04/28/note33/note33_pic20.png" class="pcyeafufrqme"></div><p>不难发现当单缓冲区并行工作时，上一个任务的处理过程和下一个任务的输入过程是并行的，因此每个任务的实际工作时长可以看作10+5=15μs，再加上最后一个任务多余的处理时间，总时间即为15×10+2=152μs。</p><p>双缓冲工作的过程图和并行工作的示意图如下图所示：</p><div class="center"><style>.doqxkmjcvkyy{}</style><img src="/2025/04/28/note33/note33_pic21.png" class="doqxkmjcvkyy"></div><p>双缓冲区和单缓冲区的不同就在于其输入过程是持续不断的，因此只需要计算10次输入过程的时长，并再加上最后一个任务的传送以及处理时间即可，答案为107μs。</p><h3 id="Ⅱ-磁盘调度">Ⅱ 磁盘调度</h3><p>计算机从一个磁盘中读取数据的基本过程为：读/写头移动到目标柱面上，这一过程称之为寻道时间；而存储数据的目标扇区会一刻不停旋转，想要读取数据就需要等待扇区旋转到读/写头的位置，这一过程称之为旋转延迟。</p><div class="center"><style>.duosdbwnckcv{}</style><img src="/2025/04/28/note33/note33_pic23.png" class="duosdbwnckcv"></div><p>而磁盘调度算法分为移臂调度和旋转调度两类，并且是先进行移臂调度，然后进行旋转调度。需要注意的是，在访问磁盘的过程中最耗时的是寻道时间。</p><h4 id="1-移臂调度算法">1. 移臂调度算法</h4><h5 id="1）-先来先服务算法（FCFS）">1） 先来先服务算法（FCFS）</h5><h5 id="2）-最短寻道时间优先算法（SSTF）">2） 最短寻道时间优先算法（SSTF）</h5><p>这种算法要求访问的磁道与当前磁头所在的磁道距离最近。</p><h5 id="3）-扫描算法（SCAN）">3） 扫描算法（SCAN）</h5><p>SCAN算法较于SSTF算法的区别在于其只考虑当前移动方向内的距离最近的磁道，在当前移动方向上没有磁道需要访问了磁头才会转向。</p><h5 id="4）-单向扫描调度算法（CSCAN）">4） 单向扫描调度算法（CSCAN）</h5><p>CSCAN算法和SCAN算法的区别在于前者是一种单向扫描算法，这意味着该算法在折返过程中不会停留，将保持循环往复保持同一起点进行单向扫描。</p><h4 id="2-旋转调度算法">2. 旋转调度算法</h4><p>当读写头到达指定位置之后，会有多个进程等待访问该柱面，那么该如何决定这些进程的访问顺序？就需要考虑以下几种情况：</p><ul><li>进程请求访问的是同一磁道上不同编号的扇区</li><li>进程请求访问的是不同磁道上不同编号的扇区</li><li>进程请求访问的是不同磁道上相同编号的扇区</li></ul><p>对于前两种情况，旋转调度总是让首先到达读/写头位置的扇区进行操作，而后一种情况下则是任选一个扇区进行传送操作。</p><p>旋转调度算法中常常涉及到在磁盘中对信息存储进行优化分布，鉴于在这里不便展开，详情请参见<a href="https://www.bilibili.com/video/BV1AY411E7GC?vd_source=d2a4fcb87f01b1e635c2de07e4f9fb34&amp;spm_id_from=333.788.videopod.episodes&amp;p=79">2010年上半年第27、28题</a>。</p><h2 id="四、文件管理">四、文件管理</h2><h3 id="Ⅰ-文件目录">Ⅰ 文件目录</h3><p>为了实现文件的“按名存取”，操作系统中势必存在一种来管理文件的数据结构，我们称其为文件控制块（FCB），而FCB的有序集合就是文件目录，故而文件控制块也可以被称作目录项。</p><h4 id="1-文件控制块">1. 文件控制块</h4><p>FCB中包含以下三类信息：</p><ul><li>基本信息类：存储文件名、文件的物理地址、文件长度等。</li><li>存取控制信息类：存储文件的存取权限。</li><li>使用信息类：存储文件建立日期、最后一次修改日期、当前使用的信息等。</li></ul><h4 id="2-目录结构">2. 目录结构</h4><p>如何组织目录结构显然是一个重要的议题，它将直接影响文件的存取速度。常见的目录结构有以下三种:</p><ul><li>一级目录结构：整个目录结构是一个线性结构，即在整个系统中只需要建立一张目录表，系统为每一个文件分配一个目录项。</li><li>二级目录结构：一级目录结构的一个缺点就是不同用户的文件容易重名且缺乏隔离性，因此我们可以引入二级目录结构的概念。二级目录结构由用户目录和主目录组成，主目录是系统唯一的顶层目录，包含所有用户的子目录，而用户目录则用来管理用户自己的独立文件。</li><li>多级目录结构：但是二级目录结构过强的隔离性又影响了多个用户之间的协作，比如一个用户难以直接访问另一个用户的文件，因此我们又引入了多级目录结构。多级目录结构类似于一棵树，从树根向下，每一个结点是一个目录，叶子节点即为文件，现代操作系统一般都采用了这种目录结构。</li></ul><div class="center"><table><thead><tr><th><strong>特性</strong></th><th>单级目录</th><th>二级目录</th><th><strong>多级目录</strong></th></tr></thead><tbody><tr><td><strong>结构复杂度</strong></td><td>最简单（所有文件同级存储）</td><td>中等（用户目录+主目录）</td><td>最复杂（树形嵌套，但灵活性最高）</td></tr><tr><td><strong>命名冲突</strong></td><td>极易发生（文件名必须唯一）</td><td>用户间隔离（同用户仍冲突）</td><td>路径唯一性彻底解决（如<code>/a/1.txt</code>和<code>/b/1.txt</code>可共存）</td></tr><tr><td><strong>扩展性</strong></td><td>无法扩展</td><td>有限扩展（仅两级）</td><td>无限嵌套子目录（如<code>/a/b/c/...</code>）</td></tr><tr><td><strong>权限控制</strong></td><td>全局统一权限</td><td>用户目录独立权限</td><td>每个目录可单独设权限（<code>chmod</code>）</td></tr><tr><td><strong>典型系统</strong></td><td>早期DOS</td><td>早期Unix</td><td>现代Linux/Windows/macOS</td></tr><tr><td><strong>路径示例</strong></td><td><code>file.txt</code></td><td><code>/home/user1/file.txt</code></td><td><code>/home/user1/docs/project1.txt</code></td></tr></tbody></table></div><h3 id="Ⅱ-存储空间的管理">Ⅱ 存储空间的管理</h3><h4 id="位示图">位示图</h4><p>位示图是一种常见的空闲空间的管理方法，它通过在外存上建立一张位示图来记录文件存储器的使用情况。</p><div class="center"><style>.cmmpnkmqcwrc{}</style><img src="/2025/04/28/note33/note33_pic26.png" class="cmmpnkmqcwrc"></div><p>其中，每一个<strong>字</strong>对应的是文件存储器中的连续的物理块。假如当前的计算机系统的字长为32位，那么第0字就代表了0~31号物理块，第1字就代表了32~63号物理块，以此类推。而物理块上填写的0、1即为其空闲与否的状态。</p><hr><div class="center"><style>.hfkfkvrytrpf{}</style><img src="/2025/04/28/note33/note33_pic27.png" class="hfkfkvrytrpf"></div><p><strong>B</strong>，简单计算，不再赘述。</p><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>软件设计师教程（第五版）. (2018).<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <summary type="html">软考中级备考笔记</summary>
    
    
    
    <category term="软考" scheme="http://example.com/categories/%E8%BD%AF%E8%80%83/"/>
    
    <category term="软件设计师" scheme="http://example.com/categories/%E8%BD%AF%E8%80%83/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/"/>
    
    <category term="上午题" scheme="http://example.com/categories/%E8%BD%AF%E8%80%83/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/%E4%B8%8A%E5%8D%88%E9%A2%98/"/>
    
    
    <category term="软考" scheme="http://example.com/tags/%E8%BD%AF%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>软件设计师 上午题 设计模式</title>
    <link href="http://example.com/2025/04/27/note32/"/>
    <id>http://example.com/2025/04/27/note32/</id>
    <published>2025-04-27T11:32:14.000Z</published>
    <updated>2025-05-08T08:27:09.560Z</updated>
    
    <content type="html"><![CDATA[<style>.center {  width: auto;  display: table;  margin-left: auto;  margin-right: auto;}</style><h1>软件设计师 上午题 设计模式</h1><blockquote><p>每一个模式描述了一个在我们周围不断重复发生的问题，以及该问题的解决方案的核心。这样，你就能一次又一次地使用该方案而不必做重复劳动。<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="软件设计师教程（第五版）. (2018).">[1]</span></a></sup></p></blockquote><p>设计模式提供了相关问题的解决方案，使得人们可以更加简单方便地复用成功的设计和体系结构，其中一般有以下4个基本要素：</p><ol><li>模式名称：一个助记名，用一两个词来描述模式的问题、解决方案和效果。</li><li>问题：问题描述了应该在何时使用模式。</li><li>解决方案：解决方案描述了设计的组成成分、它们之间的相互关系以及各自的职责和协作方式。</li><li>效果：效果描述了模式应用的效果以及使用模式应权衡的问题。</li></ol><p>而总的来说，设计模式部分的内容可以按着下面这个表格梳理：</p><div class="center"><style>.txgbcqiaekgb{}</style><img src="/2025/04/27/note32/note32_pic01.png" class="txgbcqiaekgb"></div><h2 id="一、创建型设计模式">一、创建型设计模式</h2><p>创建型设计模式的侧重点为对象创建机制，也就是说通过控制对象的创建方式来提升代码的灵活性和可复用性。</p><blockquote><p>因此，创建型模式在什么被创建，谁创建它，它是怎样被创建的，以及何时创建这些方面给予了很大的灵活性。它们允许用结构和功能差别很大的“产品”对象配置一个系统。配置可以是静态的(即在编译时指定)，也可以是动态的(在运行时)。<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="软件设计师教程（第五版）. (2018).">[1]</span></a></sup></p></blockquote><p>一般来说，创建型设计模式有以下几种具体的实现方式：</p><h3 id="Ⅰ-工厂模式">Ⅰ 工厂模式</h3><p>工厂模式是最常见的设计模式之一，它提供了一种使得创建对象的过程与使用对象的过程分离的方式，使得用户在创建对象时无需指定要创建的具体类。就如同如果朱博宁去买高铁，它只需要去提车即可，不需要关心高铁是如何制造出来的。工厂模式具体有以下几种：</p><h4 id="1-简单工厂模式">1. 简单工厂模式</h4><p>简单工厂模式不属于GoF 23种设计模式，但它是工厂方法模式实现的基础。简单工厂模式提供一个静态工厂方法，可以根据传入的参数决定创建哪种具体产品类的实例。但这显然违背了开闭原则(Open for extension, closed for modification)，如果要新增产品就要修改工厂逻辑。</p><h4 id="2-工厂方法模式">2. 工厂方法模式</h4><p>和简单工厂模式不同的是，工厂方法模式中定义了一个创建对象的接口，这样一来就满足了开闭原则。</p><div class="center"><style>.cxvwusbtxjcx{}</style><img src="/2025/04/27/note32/note32_pic02.png" class="cxvwusbtxjcx"></div><p>在工厂方法模式当中，父类（抽象工厂）只声明创建方法（比如上图中的<code>createProduct()</code>）而不关心具体实现，子类（具体工厂）负责实现父类的创建方法并返回具体的产品实例。</p><h4 id="3-抽象工厂模式">3. 抽象工厂模式</h4><p>和工厂方法模式当中创建单一产品不同的是，抽象工厂模式当中创建了一个产品家族，即一系列相关或相互依赖的的对象。</p><div class="center"><style>.ffwxuxqfpiif{}</style><img src="/2025/04/27/note32/note32_pic03.png" class="ffwxuxqfpiif"></div><h3 id="Ⅱ-生成器模式">Ⅱ 生成器模式</h3><p>生成器模式的特点是将对象的构造过程与其表示分离，使得同样的构建过程可以创建不同的表示，主要用于分步骤构建复杂对象，其结构如下所示：</p><div class="center"><style>.gpwkutpgmpex{}</style><img src="/2025/04/27/note32/note32_pic05.png" class="gpwkutpgmpex"></div><h3 id="Ⅲ-原型模式">Ⅲ 原型模式</h3><p>原型模式的核心思想是通过复制现有对象（原型）来创建新对象，而不是通过<code>new</code>实例化。因此原型模式可以基于克隆快速生成对象，避免重复执行耗时的初始化操作。其结构如下所示：</p><div class="center"><style>.ijmpqyqhlmfu{}</style><img src="/2025/04/27/note32/note32_pic07.png" class="ijmpqyqhlmfu"></div><h3 id="Ⅳ-单例模式">Ⅳ 单例模式</h3><p>单例模式确保一个类中只有一个实例，并提供一个全局访问点。它通过控制实例化过程，避免重复创建对象，节省资源。其结构如下所示：</p><div class="center"><style>.qahlgwnxgacb{}</style><img src="/2025/04/27/note32/note32_pic08.png" class="qahlgwnxgacb"></div><h3 id="Ⅴ-真题赏析">Ⅴ 真题赏析</h3><div class="center"><style>.xjdlkyuhjcjn{}</style><img src="/2025/04/27/note32/note32_pic06.png" class="xjdlkyuhjcjn"></div><p><strong>ACAD</strong>，对于（45）而言，所谓的<code>构造一个使用Builder接口的对象</code>指的就是控制整个流程的类，是<strong>Director(指挥者)</strong>，那么对于本题而言就是Waiter。此外，对于（47）而言，Builder模式适用于：1）创建复杂对象的算法应该独立于该对象的组成部分以及装配方式时；2）当构造过程必须允许被构造对象有不同的表示时。</p><h2 id="二、结构型设计模式">二、结构型设计模式</h2><p>结构型设计模式是一类用于处理对象组合和关系的设计模式，其重点解决：1）如何组合类和对象以形成更大的结构；2）如何简化对象间的依赖关系，提升灵活性和可扩展性。<br>结构型设计模式有以下七种经典模式：</p><h3 id="Ⅰ-适配器模式">Ⅰ 适配器模式</h3><p>适配器模式的核心思想是通过一个中间层（适配器）来解决接口不匹配的问题，类似于电源插头转换器的角色。它用于将不兼容的接口转换为客户端期望的接口，使原本无法协同工作的类能够一同工作。适配器模式的结构如下所示：</p><div class="center"><style>.yywrjbfuvfhd{}</style><img src="/2025/04/27/note32/note32_pic09.png" class="yywrjbfuvfhd"></div><h3 id="Ⅱ-桥接模式">Ⅱ 桥接模式</h3><p>桥接模式的核心思想是通过组合代替继承，解决多层继承带来的类爆炸问题，提升系统的灵活性和可扩展性。这使得桥接模式可以将抽象部分和实现部分分离，使得它们可以独立变化。桥接模式的结构如下所示：</p><div class="center"><style>.sjvvdlyyxjkm{}</style><img src="/2025/04/27/note32/note32_pic10.png" class="sjvvdlyyxjkm"></div><p>其中，抽象是系统的高级控制逻辑，定义客户端直接使用的接口和行为。抽象并不关心具体实现细节，而是通过组合持有一个实现的引用。而实现则是系统的底层核心操作，独立于抽象，可以自由变化或者替换。</p><h3 id="Ⅲ-组合模式">Ⅲ 组合模式</h3><p>假如现在有这么一个公司组织结构：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs txt">CEO<br>├── 技术部<br>│   ├── 开发组<br>│   │   ├── 程序员A（叶子）<br>│   │   └── 程序员B（叶子）<br>│   └── 测试组<br>│       └── 测试员X（叶子）<br>└── 财务部<br>    └── 会计Y（叶子）<br></code></pre></td></tr></table></figure><p>在组合模式当中，无论是部门（容器节点）还是员工（叶子结点），都可以被统一看作“公司成员”。它们之间的区别是叶子结点直接实现基础行为，而容器节点除了自身行为之外还可以递归调用子节点的方法。例如在计算全公司人数时，只需要让每个“公司成员”返回自己的人数并进行递归累加即可，无需区分部门还是员工。<br>这就是组合模式，它会将对象组合成树形结构以表示“部分-整体”的层次关系，使得用户对单个对象和组合对象的使用具有一致性。其结构如下图所示：</p><div class="center"><style>.wheyfwdlcsyw{}</style><img src="/2025/04/27/note32/note32_pic12.png" class="wheyfwdlcsyw"></div><h3 id="Ⅳ-装饰器">Ⅳ 装饰器</h3><p>装饰器的核心思想是通过嵌套包装对象来扩展功能，而非通过子类继承。因此，装饰器模式可以用于动态地为对象添加额外职责。其结构如下所示：</p><div class="center"><style>.pvqyuhgoggdi{}</style><img src="/2025/04/27/note32/note32_pic14.png" class="pvqyuhgoggdi"></div><h3 id="Ⅴ-外观模式">Ⅴ 外观模式</h3><p>外观模式的核心思想是用一个高层接口包装一组接口，让客户端只需调用一个简单方法就能完成复杂功能。这样一来就可以为复杂的子系统提供一个统一的简化接口，隐藏内部细节，降低客户端与子系统的耦合度。外观模式的结构如下图所示：</p><div class="center"><style>.ofsfohbchikk{}</style><img src="/2025/04/27/note32/note32_pic15.png" class="ofsfohbchikk"></div><p>其中，Facade知道哪些子系统类复制处理请求，会将客户的请求代理给适当的子系统对象。</p><h3 id="Ⅵ-享元模式">Ⅵ 享元模式</h3><p>享元模式的核心思想是分离对象的固有状态（共享）和外部状态（非共享），从而通过共享技术高效地支持大量细粒度对象的复用，进而减少内存占用和对象创建开销。享元模式的结构如下图所示：</p><div class="center"><style>.tevewklcjxqs{}</style><img src="/2025/04/27/note32/note32_pic17.png" class="tevewklcjxqs"></div><p>例如在一款射击游戏当中需要渲染大量子弹，对于每颗子弹而言有以下属性：</p><ul><li>固有状态（共享）：纹理图片、颜色、伤害值等（所有子弹相同）。</li><li>外部状态（非共享）：位置坐标、飞行角度等（每颗子弹不同）。</li></ul><p>享元模式就是共享相同纹理的子弹对象来解决内存消耗过大的问题。</p><h3 id="Ⅶ-代理模式">Ⅶ 代理模式</h3><p>代理模式通过创建一个代理对象来控制对原始对象的访问，在不改变原始类的情况下增强功能。代理模式的核心思想是由“代理”充当中间人，在客户端和目标对象之间插入一层，用于添加额外逻辑。其结构如下图所示：</p><div class="center"><style>.xzvjasmsruzo{}</style><img src="/2025/04/27/note32/note32_pic18.png" class="xzvjasmsruzo"></div><h3 id="Ⅷ-真题赏析">Ⅷ 真题赏析</h3><div class="center"><style>.hfvzsepixqyc{}</style><img src="/2025/04/27/note32/note32_pic11.png" class="hfvzsepixqyc"></div><p><strong>CDAB</strong>，桥接模式适用于：</p><ol><li>不希望在抽象和它的实现部分之间有一个固定的绑定关系。</li><li>类的抽象以及它的实现都应该可以通过生成子类的方法加以扩充。</li><li>对一个抽象的实现部分的修改应对客户不产生影响，即客户代码不必重新编译。</li><li>(C++)想对客户完全隐藏抽象的实现部分。</li><li>有许多类要生成的类层次结构。</li><li>想在多个对象间共享实现(可能使用引用计数)，但同时要求客户并不知道这一点。</li></ol><hr><div class="center"><style>.ipjepoitpupn{}</style><img src="/2025/04/27/note32/note32_pic16.png" class="ipjepoitpupn"></div><p><strong>CD</strong>，对于（45）题的A选项而言，这是<strong>责任链模式</strong>的适用情况。</p><h2 id="三、行为型设计模式">三、行为型设计模式</h2><p>行为型设计模式是设计模式当中的最后一大类，和先前介绍的注重于对象创建机制的创建型设计模式、注重于对象组合和关系的结构型设计模式不同的是，行为型设计模式专注于对象之间的交互方式和算法的封装。这类设计模式不关注对象如何创建或者组合，而是<strong>定义对象如何协作完成任务</strong>。</p><p>常见的行为型设计模式有以下11种（死…）：</p><h3 id="Ⅰ-责任链模式">Ⅰ 责任链模式</h3><p>责任链使得多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。它允许用户将请求沿着处理链传递，直到有一个处理者能够处理它。其结构如下图所示：</p><div class="center"><style>.xitssykolcok{}</style><img src="/2025/04/27/note32/note32_pic19.png" class="xitssykolcok"></div><h3 id="Ⅱ-命令模式">Ⅱ 命令模式</h3><p>命令模式将请求封装为独立的对象（命令），允许用户参数化客户端（调用者）与接收者（执行者），从而支持请求的排队、撤销、日志记录等操作。其结构如下图所示：</p><div class="center"><style>.cfelxfqhfhcq{}</style><img src="/2025/04/27/note32/note32_pic20.png" class="cfelxfqhfhcq"></div><h3 id="Ⅲ-解释器模式">Ⅲ 解释器模式</h3><p>解释器模式的核心思想是“将语言种的每个语法规则表示为一个类，通过组合这些类来构建语法树，最终解释执行”。因此这种设计模式可以用于定义一种语言的语法规则，并提供一个解释器来解释该语言中的表达式。其结构如下图所示：</p><div class="center"><style>.obhbuinwygqm{}</style><img src="/2025/04/27/note32/note32_pic21.png" class="obhbuinwygqm"></div><h3 id="Ⅳ-迭代器模式">Ⅳ 迭代器模式</h3><p>迭代器模式提供一种方法顺序访问聚合对象（列表、树等）中的元素，而不需要暴露该对象的内部表示，这实际上是将遍历逻辑从聚合对象中分离出来了。这种设计模式的结构如下所示：</p><div class="center"><style>.toudwcawjsrt{}</style><img src="/2025/04/27/note32/note32_pic22.png" class="toudwcawjsrt"></div><h3 id="Ⅴ-中介者模式">Ⅴ 中介者模式</h3><p>中介者模式的核心思想是“使用一个中介者来封装一系列对象之间的交互，使各个对象不需要显式地相互引用”，即通过引入中介对象来集中管理多个对象之间的交互，从而减少对象间的直接耦合，使系统更易于维护和扩展。这种设计模式的结构如下图所示：</p><div class="center"><style>.auhfgccejqxl{}</style><img src="/2025/04/27/note32/note32_pic23.png" class="auhfgccejqxl"></div><h3 id="Ⅵ-备忘录模式">Ⅵ 备忘录模式</h3><p>备忘录模式的核心思想是“在不暴露对象实现细节的情况下，保存和恢复其内部状态”，它允许在不破坏封装性的前提下捕获并外部化对象的内部状态，以便后续可以恢复到该状态。其结构如下图所示：</p><div class="center"><style>.clhwhhpanyjm{}</style><img src="/2025/04/27/note32/note32_pic24.png" class="clhwhhpanyjm"></div><h3 id="Ⅶ-观察者模式">Ⅶ 观察者模式</h3><p>在观察者模式当中定义了对象间的一对多依赖关系，当一个对象（主题）状态改变时，所有依赖它的对象（观察者）都会自动收到通知并更新。其结构如下图所示：</p><div class="center"><style>.fljyhljhyiqh{}</style><img src="/2025/04/27/note32/note32_pic25.png" class="fljyhljhyiqh"></div><h3 id="Ⅷ-状态模式">Ⅷ 状态模式</h3><p>状态模式的核心为：同一个动作在不同状态下有不同的表现。例如日常用的台灯，正常状态下按开关出现的是白光，护眼模式下同样按开关出现的却是黄光。</p><blockquote><p>（状态模式）允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它的类。<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="软件设计师教程（第五版）. (2018).">[1]</span></a></sup></p></blockquote><p>状态模式的结构如下图所示：</p><div class="center"><style>.puqnwptgaxgw{}</style><img src="/2025/04/27/note32/note32_pic26.png" class="puqnwptgaxgw"></div><h3 id="Ⅸ-策略模式">Ⅸ 策略模式</h3><p>策略模式是一种将算法抽离出来的设计模式，它定义一系列算法（策略）​​，并将每个算法封装成独立类，使它们可以​​互相替换​​，且算法的变化不影响使用它的客户端。该模式的结构如下图所示：</p><div class="center"><style>.kogcsuqgtece{}</style><img src="/2025/04/27/note32/note32_pic27.png" class="kogcsuqgtece"></div><h3 id="Ⅹ-模板方法">Ⅹ 模板方法</h3><p>模板方法模式的核心思想为：“在不改变算法结构的情况下，允许子类重写算法的特定步骤”，这就类似于我们在按照食谱做一道菜的时候，大致的步骤是固定的，但其中诸如撒盐多少的细节就可以根据个人喜好进行调整。也就是说，模板方法模式在父类当中定义算法的骨架，而将某些步骤的具体实现延迟到子类当中完成，其结构如下图所示：</p><div class="center"><style>.aqvxqohjciop{}</style><img src="/2025/04/27/note32/note32_pic28.png" class="aqvxqohjciop"></div><h3 id="XI-访问者模式">XI 访问者模式</h3><p><em><s>最后一个！！！</s></em></p><p>访问者模式适用于对象结构稳定但需要频繁新增操作的场景，它可以将数据结构和数据操作分离，允许在不修改对象类的前提下，让新增操作像“访问者”一样灵活接入。这种设计模式的结构如下图所示：</p><div class="center"><style>.vuviqebghqdq{}</style><img src="/2025/04/27/note32/note32_pic29.png" class="vuviqebghqdq"></div><h2 id="三、真题赏析">三、真题赏析</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>软件设计师教程（第五版）. (2018).<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <summary type="html">软考中级备考笔记</summary>
    
    
    
    <category term="软考" scheme="http://example.com/categories/%E8%BD%AF%E8%80%83/"/>
    
    <category term="软件设计师" scheme="http://example.com/categories/%E8%BD%AF%E8%80%83/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/"/>
    
    <category term="上午题" scheme="http://example.com/categories/%E8%BD%AF%E8%80%83/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/%E4%B8%8A%E5%8D%88%E9%A2%98/"/>
    
    
    <category term="软考" scheme="http://example.com/tags/%E8%BD%AF%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>软件设计师 下午题 试题三 UML分析与设计</title>
    <link href="http://example.com/2025/04/26/note31/"/>
    <id>http://example.com/2025/04/26/note31/</id>
    <published>2025-04-26T15:21:03.000Z</published>
    <updated>2025-05-08T08:27:06.869Z</updated>
    
    <content type="html"><![CDATA[<style>.center {  width: auto;  display: table;  margin-left: auto;  margin-right: auto;}</style><h1>软件设计师 下午题 试题三 UML分析与设计</h1><p>试题三考察的内容依旧是UML，没有什么新的知识点的引入，在下午题的学习当中就以做题的形式简单熟悉一下。</p><h3 id="1-2016年上半年">1. 2016年上半年</h3><div class="center"><style>.simtirouskhg{}</style><img src="/2025/04/26/note31/note31_pic01.jpg" class="simtirouskhg"></div><ul><li>【问题1】<strong>U1/U2: Run, Step; U3: Write; U4/U5/U6: Move, Left, Read</strong>。</li><li>【问题2】<strong>U1, U2和Run Program有泛化关系; U3, U4, U5, U6和Select Robot有扩展关系</strong>。首先需要注意的是，图3-2是一张用例图，而在用例图当中，只有包含、扩展和泛化三种关系。而用例U1和U2是用例Run Program的继承且表现出更特别的行为，所以它们之间是泛化关系；用例U3~U6是用例Select Robot中独立且可选的行为，是扩展关系。</li><li>【问题3】<strong>C1：文件；C2：机器人在虚拟世界中的行为；C3：Instruction；C4：Instruction Set；C5：仿真系统</strong>。</li></ul><h3 id="2-2015年上半年">2. 2015年上半年</h3><div class="center"><style>.jqoxxpojlmii{}</style><img src="/2025/04/26/note31/note31_pic02.jpg" class="jqoxxpojlmii"></div><ul><li>【问题1】<strong>(1) C5; (2) C9; (3) C7; (4) C6; (5)(6) C8, C10; (7) C2</strong>。需要注意的是，C7和C9并不能交换位置。C7和C9都有指向C5的泛化关系不难理解，但是C9和C5之间应该还会有一层聚合关系，也就是说C5可以包含多个C9，这与题干中的“多个团体可以组成一个新的团体”的题意是相符的。</li><li>【问题2】<strong>M1: C5; M2: C2; M3: C3; M4: C3; M5: C3; M6: C8; M7: C10; M8: C10; M9: C12; M10: C1</strong>。</li><li>【问题3】<strong>组合模式，在本题中由于拍卖者分为个人拍卖者和团体拍卖者两种，而团体也可以组成新的团体参与拍卖活动。这样的整体-部分关系，适合于使用组合模式表达</strong>。</li></ul><h3 id="3-2014年下半年">3. 2014年下半年</h3><div class="center"><style>.omwmcjvjqdnu{}</style><img src="/2025/04/26/note31/note31_pic03.jpg" class="omwmcjvjqdnu"></div><ul><li>【问题1】<strong>C1: Address; C2: Riding; C3: Ineligible; C4: Eligible</strong>。</li><li>【问题2】<strong>M1: 1; M2: *; M3: *; M4: 1; M5: *; M6: 1</strong>。</li><li>【问题3】<strong>将M1和M4修改为1…</strong>*。</li></ul>]]></content>
    
    
    <summary type="html">软考中级备考笔记</summary>
    
    
    
    <category term="软考" scheme="http://example.com/categories/%E8%BD%AF%E8%80%83/"/>
    
    <category term="软件设计师" scheme="http://example.com/categories/%E8%BD%AF%E8%80%83/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/"/>
    
    <category term="下午题" scheme="http://example.com/categories/%E8%BD%AF%E8%80%83/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/%E4%B8%8B%E5%8D%88%E9%A2%98/"/>
    
    
    <category term="软考" scheme="http://example.com/tags/%E8%BD%AF%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>Git “bad config line 1 in file .git/config”报错的解决方案</title>
    <link href="http://example.com/2025/04/24/md02/"/>
    <id>http://example.com/2025/04/24/md02/</id>
    <published>2025-04-24T05:43:19.000Z</published>
    <updated>2025-05-06T11:46:48.829Z</updated>
    
    <content type="html"><![CDATA[<style>.center {  width: auto;  display: table;  margin-left: auto;  margin-right: auto;}</style><h1>Git “bad config line 1 in file .git/config”报错的解决方案</h1><p>昨天晚上下了自习之后准备把笔记到Hexo上然后回寝室睡大觉，结果出现了以下报错：</p><div class="center"><style>.yevmqyjkihgs{}</style><img src="/2025/04/24/md02/md02_pic01.png" class="yevmqyjkihgs"></div><p>其实之前也出现过一次这样的情况，但是当时什么动作也没做重新第二遍尝试<code>hexo d</code>就提交成功了，加上搜了一些技术文档看到有人说只是网络问题所以就没放在心上继续回去睡大觉了。<br><br>但是今天早上起来再尝试deploy的时候依旧出现同样的报错，这下开始发现应该是哪个配置文件出现了问题，下面是花两节课摸索出来的解决方案：</p><h3 id="1-删除-hexo-deploy-git">1. 删除/hexo/.deploy_git</h3><div class="center"><style>.otclfogmveuc{}</style><img src="/2025/04/24/md02/md02_pic02.png" class="otclfogmveuc"></div><p>我的本地代码库如上图所示，我最开始找<code>config</code>文件时一直找的就是<code>/.git</code>文件夹中的<code>config</code>文件。但是不论我用记事本打开这个文件还是用<code>$ vi .git/config</code>检查这个文件其中的内容都一切正常。<br><br>后来也反复尝试过删除<code>/.git/config</code>文件，再使用<code>$ git init</code>命令恢复它也无济于事。<br><br>直到我突然发现<code>.deploy_git</code>文件夹中也有一个<code>.git</code>文件夹，并且其中也有一个<code>config</code>文件，并且打开之后其内容是一片空白！<br><br>那么也许这就是问题所在了，于是我尝试删除了<code>/hexo/.deploy_git</code>。</p><h3 id="2-使用管理员模式运行Git-Bash">2. 使用管理员模式运行Git Bash</h3><p>在删除目标文件夹之后我重新尝试了<code>$ hexo d</code>命令，但是提示错误信息为没有足够的权限：</p><div class="center"><style>.gkovrlfzynbn{}</style><img src="/2025/04/24/md02/md02_pic05.png" class="gkovrlfzynbn"></div><br><p>那么就需要使用管理员模式运行<code>Git Bash</code>了，按下图图示操作即可：<br></p><br><div class="center"><style>.kotimcwcvtku{}</style><img src="/2025/04/24/md02/md02_pic03.png" class="kotimcwcvtku"></div><br><p>随后就能正常递交文档了：</p><br><div class="center"><style>.miatwquzshku{}</style><img src="/2025/04/24/md02/md02_pic04.png" class="miatwquzshku"></div>]]></content>
    
    
    <summary type="html">hexo无法成功提交的解决方案</summary>
    
    
    
    <category term="疑难杂症解决方案" scheme="http://example.com/categories/%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    
    
  </entry>
  
  <entry>
    <title>软件设计师 上午题 UML</title>
    <link href="http://example.com/2025/04/24/note30/"/>
    <id>http://example.com/2025/04/24/note30/</id>
    <published>2025-04-24T05:30:30.000Z</published>
    <updated>2025-05-08T08:27:03.183Z</updated>
    
    <content type="html"><![CDATA[<style>.center {  width: auto;  display: table;  margin-left: auto;  margin-right: auto;}</style><h1>软件设计师 上午题 UML</h1><p>统一建模语言(Unified Modeling Language, UNL)是一种面向对象软件的标准化建模语言，其简单、统一且富有表达力，目前已经成为可视化建模语言事实上的工业标准。<br>UML的词汇表中包含了3种构造块：事物、关系和图。事物是对模型种最具有代表性的成分的抽象；关系将事物联系在了一起；图则聚集了相关的事物。下面我们将逐一了解这些构造块：</p><h2 id="一、事物">一、事物</h2><p>UML中有四种事物：结构事物、行为事物、分组事物和注释事物：</p><h4 id="1-结构事物">1. 结构事物</h4><p>结构事物通常是模型中的静态部分，用来描述概念或者物理元素，各种结构事物的图形化表示如下图所示：</p><div class="center"><style>.hsaodghmhion{}</style><img src="/2025/04/24/note30/note30_pic01.png" class="hsaodghmhion"></div><h4 id="2-行为事物">2. 行为事物</h4><p>行为事物通常是模型中的动态部分，用来描述跨越时间和空间的行为，其图形化表示如下图所示：</p><div class="center"><style>.cbqlqfixkxbm{}</style><img src="/2025/04/24/note30/note30_pic02.png" class="cbqlqfixkxbm"></div><h4 id="3-分组事物">3. 分组事物</h4><p>分组事物是UML模型中的组织部分，是一些由模型分解成的“盒子”。在应用中最主要的分组事物是包(Package)，它能够将元素组织起来，绝大分事物都可以放进包内。包的图形化表示如下图所示：</p><div class="center"><style>.jhsjunjxdnwr{}</style><img src="/2025/04/24/note30/note30_pic03.png" class="jhsjunjxdnwr"></div><h4 id="4-注释事物">4. 注释事物</h4><p>这种事物的概念不难理解，而注解(Note)是其中比较重要的一种注释事物，其图形化表示如下图所示：</p><div class="center"><style>.tcsgfywrortv{}</style><img src="/2025/04/24/note30/note30_pic04.png" class="tcsgfywrortv"></div><h2 id="二、关系">二、关系</h2><p>UML当中有四种关系：依赖、关联、泛化和实现。</p><h3 id="Ⅰ-概念了解">Ⅰ 概念了解</h3><h4 id="1-依赖">1. 依赖</h4><p>在依赖关系中，一个事物（独立事物）发生变化会影响另一个事物（依赖事物）的语义，其图形化表示如下图所示：</p><div class="center"><style>.mpevtemjlrhb{}</style><img src="/2025/04/24/note30/note30_pic05.png" class="mpevtemjlrhb"></div><p>当出现<code>A --------&gt; B</code>时，A是<code>依赖事物</code>，B是<code>独立事物</code>。<br>需要注意的是，依赖关系是单向的且是临时的，仅表示依赖事物需要独立事物，反之不成立。依赖可以体现在代码中的参数传递、局部变量、静态方法调用等场景。</p><h4 id="2-关联">2. 关联</h4><p>当两个对象之间被连接起来，它们就构成了关联关系，如下图所示：</p><div class="center"><style>.ylnpoulctekk{}</style><img src="/2025/04/24/note30/note30_pic06.png" class="ylnpoulctekk"></div><p>不难发现，在关联上还可以标注重复度(Multiplicity)和角色(Role)，其中重复度指的就是参与关联的对象数量关系。<br><br>此外，还有两种特殊的关联，即聚集和组合，它们都描述的是整体和部分之间的结构关系，但是也略有不同：<br>i.  聚集：部分和整体的生命周期不一致，整体消失了，部分仍然存在。例如员工和公司。<br>ii. 组合：部分和整体的生命周期一致，整体消失了，部分也就消失了。例如部门和公司。</p><div class="center"><style>.oxyytjmvxlnt{}</style><img src="/2025/04/24/note30/note30_pic07.png" class="oxyytjmvxlnt"></div><p>此外还有一种单向关联的情况，类似于<code>A ——&gt; B</code>，它和依赖关系<code>A ---&gt; B</code>的区别就在于前者不是临时的但后者是临时的。例如<code>人 ——&gt; 氧气</code>和<code>人 ---&gt; 食物</code>。</p><h4 id="3-泛化">3. 泛化</h4><p>即继承，它由特殊元素（子元素）指向一般元素（父元素）。用这种方法，子元素就可以共享父元素的结构和行为。例如猫泛化动物、狗泛化动物等。</p><div class="center"><style>.udksgfvultcx{}</style><img src="/2025/04/24/note30/note30_pic08.png" class="udksgfvultcx"></div><h4 id="4-实现">4. 实现</h4><p>实现是类元之间的语义关系，其中一个类元指定了另一个类元保证执行的契约。</p><div class="center"><style>.bkhisvewbumq{}</style><img src="/2025/04/24/note30/note30_pic09.png" class="bkhisvewbumq"></div><h3 id="Ⅱ-真题赏析">Ⅱ 真题赏析</h3><div class="center"><style>.xrjfjrfktyyx{}</style><img src="/2025/04/24/note30/note30_pic10.png" class="xrjfjrfktyyx"></div><p><strong>A</strong>，关联关系和泛化关系的区别在于，虽然它们都是特殊和一般之间的关系，但是关联关系是对象之间的关系，但是泛化是类之间的关系。</p><hr><div class="center"><style>.sqiqyvptzydw{}</style><img src="/2025/04/24/note30/note30_pic11.png" class="sqiqyvptzydw"></div><p><strong>D</strong>，两个类之间的关联关系可以有多个，但不能有无限多个，都必须有对应的角色进行标识（如下图所示）。多个关联不必强行聚合成一个，聚合仅是一种特殊的关联。</p><div class="center"><style>.zbilffswnidl{}</style><img src="/2025/04/24/note30/note30_pic12.png" class="zbilffswnidl"></div><h2 id="三、图">三、图</h2><p>在UML当中，图是一组元素的图形表示，我们一般情况下会将图画成事物和弧的连通图，而常见的图有以下几类：<br></p><p><em>注：由于这个板块的知识点比较零碎，不再单独设置<strong>真题赏析</strong>模块，真题将直接附在每个子模块后边。</em></p><h3 id="Ⅰ-类图">Ⅰ 类图</h3><p>类图是面向对象系统的建模中所建立的最常见的图，一般来说，一个类图中的内容即为类和类之间的依赖、泛化和关联关系。</p><div class="center"><style>.wgqjcoabmgew{}</style><img src="/2025/04/24/note30/note30_pic13.png" class="wgqjcoabmgew"></div><hr><ol><li>2015年下半年：</li></ol><div class="center"><style>.gftbmolfnhgi{}</style><img src="/2025/04/24/note30/note30_pic14.png" class="gftbmolfnhgi"></div><p><strong>B</strong>，继承和覆盖的区别在于前者是一种复用，而后者则是一种重新实现。在本题当中，显然在<code>Car</code>类和<code>Boat</code>类当中的<code>+move()</code>函数并不是同一种函数，也就是说它们不可能都是对<code>Transport</code>类中<code>+move()</code>函数的继承，那么只能是为了实现多态而重新实现该函数了。</p><hr><ol start="2"><li>2020年下半年：</li></ol><div class="center"><style>.qpnuitfcgjka{}</style><img src="/2025/04/24/note30/note30_pic15.png" class="qpnuitfcgjka"></div><p><strong>D</strong>，我们首先需要搞清楚什么是直接对象什么是非直接对象，直接对象是指直接从某个类中实例化的对象，而非直接对象则是指通过继承或者关联关系间接属于某个类的对象。对于本题中的A类，它是一个抽象类，抽象类是无法进行实例化的，也就是说A1和A2是A类的非直接对象。那么D选项中所谓的“A的直接对象”根本就不存在，错误。</p><h3 id="Ⅱ-对象图">Ⅱ 对象图</h3><p>对象图展现的是某一时刻的一组对象以及它们之间的关系，描述了在类图中所建立的事物的实例的静态快照，其中一般包括的有对象和链。</p><div class="center"><style>.wzticmwlyfyz{}</style><img src="/2025/04/24/note30/note30_pic16.png" class="wzticmwlyfyz"></div><h3 id="Ⅲ-用例图">Ⅲ 用例图</h3><p>用例图是UML当中用于描述系统功能需求和用户交互的静态视图，其核心关注点在于参与者和系统功能之间的关系。</p><div class="center"><style>.wfvazwlvqess{}</style><img src="/2025/04/24/note30/note30_pic17.png" class="wfvazwlvqess"></div><p>可以注意到的是，在用例图当中还包含了三种关系，这三种关系是用来描述用例和用例之间的交互逻辑的：</p><ul><li>包含关系：表示一个用例必须调用另一个用例的功能，属于强依赖关系。</li><li>扩展关系：表示一个用例在特定条件下扩展另一个用例的功能，属于可选依赖。</li><li>泛化关系：表示用例之间的继承关系，子用例继承父用例的行为并扩展。</li></ul><p>需要注意的是，包含关系和扩展关系再用例图当中的线条是一样的，区分它们的依据是虚线旁边的<code>&lt;&lt;extend&gt;&gt;</code>或者<code>&lt;&lt;include&gt;&gt;</code>。</p><h3 id="Ⅳ-交互图">Ⅳ 交互图</h3><p>交互图是UML中用于描述​​对象间动态交互行为​​的图表，根据不同的目的又可划分为序列图和通信图。</p><h4 id="1-序列图">1. 序列图</h4><p>序列图是场景(Scenario)的图形化表示，描述了以时间顺序组织的对象之间的交互活动，如下图所示。</p><div class="center"><style>.iltcmfwtxmlp{}</style><img src="/2025/04/24/note30/note30_pic18.png" class="iltcmfwtxmlp"></div><p>在序列图当中，我们一般把参加交互的对象放在图的上方（发起交互的对象在左，下级对象在右），然后把这些对象发送和接收的消息沿垂直方向按时间顺序从上到下放置。这样一来我们就得到了控制流随时间的可视化轨迹。<br>序列图当中还有两个特征：</p><ul><li>对象生命线：在序列图当中用一根垂直的虚线来表示一个对象在一段时间内的存在。</li><li>控制焦点：在序列图当中用一个瘦高的矩形来表示一个对象执行一个动作所经历的时间段。</li></ul><hr><ol><li>2013年下半年：</li></ol><div class="center"><style>.xgsrpvnunaxj{}</style><img src="/2025/04/24/note30/note30_pic19.png" class="xgsrpvnunaxj"></div><p><strong>CB</strong>，首先要注意的是，在此题当中除了用虚线表示的<code>evaluation()</code>函数是返回消息之外，其余的四种函数都是同步消息。而一条从A指向B的同步消息的本质是A要求B执行一个明确的操作，也就意味着如果对象A向对象B发送一条同步消息则对象B必须实现该方法。根据此原则不难发现，除了<code>check()</code>函数需要<code>Person</code>类来实现之外，其余的几种函数都需要<code>Account</code>类来实现。</p><h4 id="2-通信图">2. 通信图</h4><p>通信图在早期的版本中也被称作协作图，强调的是参加交互的对象的组织关系，如下图所示：</p><div class="center"><style>.opjobphflaye{}</style><img src="/2025/04/24/note30/note30_pic20.png" class="opjobphflaye"></div><p>通信图中有两个特性：</p><ul><li>通信图中有路径：通信图当中用实线连接两个对象来表示对象之间存在的交互关联关系。</li><li>通信图中有顺序号：通信图中每个新消息前都有一个数字前缀，用于表示消息的时间顺序。</li></ul><p><strong>不难发现，序列图和通信图是同构的，它们之间可以互相转换。</strong></p><h3 id="Ⅴ-状态图">Ⅴ 状态图</h3><p>状态图展现了一个状态机，用来描述对象生命周期内状态变化，专注于展示对象如何响应事件并在不同状态间转换，如下图所示：</p><div class="center"><style>.dhiwisbgqvxq{}</style><img src="/2025/04/24/note30/note30_pic21.png" class="dhiwisbgqvxq"></div><p>状态图当中包含了以下四个比较重要的概念：</p><ol><li>状态：状态指的是对象在生命周期中的稳定条件，在特定时间段内保持属性值和行为不变。其中，●表示开始，⚪表示结束。如果一个状态当中还包含一个子状态，那么我们称这个状态为组合状态，或者为超状态。</li><li>活动：活动指的是对象在特定状态中持续执行的行为。<ol><li>入口活动(entry)：进入状态，立即执行。</li><li>执行活动(do)：占有有限时间，可以中断。</li><li>出口活动(exit)：退出状态，立即执行。</li></ol></li><li>转换：转换指的是状态间的有向跳转，由事件触发并可能伴随条件和动作。此外，在转移过程中存在一个被称为“监护条件”的布尔值，用<code>[]</code>表示，如果存在监护条件，只有其为真值时才能触发转换。</li><li>事件：事件指的是触发状态转换的离散发生的事宜。</li></ol><hr><ol><li>2013年上半年：</li></ol><div class="center"><style>.propccildofv{}</style><img src="/2025/04/24/note30/note30_pic22.png" class="propccildofv"></div><p><strong>C</strong>，这道题的难点在于如何区分选项C和选项D。我们首先需要明白的是，当对象处于某种状态时，这个状态被称之为激活状态，只有从激活状态出发才能进行转换。对于C选项，事件e2的激活状态只有状态B中嵌套的子状态B2，会发生转换的情况应该如选项B描述的那样；而对于D选项，事件e1的激活状态是整个状态B，也就是说不论是B1、B2、B3抑或是B4都是激活状态，事件e1一发生就能触发状态转换。</p><hr><ol start="2"><li>2019年下半年</li></ol><div class="center"><style>.qqrmhbtvpxxi{}</style><img src="/2025/04/24/note30/note30_pic23.png" class="qqrmhbtvpxxi"></div><p><strong>C</strong>，迁移要包含两个状态。</p><h3 id="Ⅵ-活动图">Ⅵ 活动图</h3><p>活动图是一种特殊的状态图，它展现了在系统内从一个活动到另一个活动的流程，其中一般包括活动状态和动作状态、转换和对象，如下图所示：</p><div class="center"><style>.ypligoxzkxhk{}</style><img src="/2025/04/24/note30/note30_pic24.png" class="ypligoxzkxhk"></div><hr><ol><li>2013年下半年：</li></ol><div class="center"><style>.xjsccwvmvxgn{}</style><img src="/2025/04/24/note30/note30_pic25.png" class="xjsccwvmvxgn"></div><p><strong>C</strong>，这里需要弄清除的是UML活动图当中各个符号的含义。1）菱形表示的是流程当中的条件分支，将根据监护条件决定下一步执行的路径。2）黑色粗长条表示的是分叉/汇合结点，其作用是将单一流程拆分为多个<strong>并行执行</strong>的子流程/将子流程合并为单一流程继续执行。</p><h3 id="Ⅶ-构件图">Ⅶ 构件图</h3><p>构件图展现了一组构件之间的组织和依赖关系，它与类图相关，通常把构件映射为一个或多个类、接口或者协作，如下图所示：</p><div class="center"><style>.eftlsjjcnifx{}</style><img src="/2025/04/24/note30/note30_pic26.png" class="eftlsjjcnifx"></div><hr><ol><li>2009年上半年：</li></ol><div class="center"><style>.krzpdshwrxme{}</style><img src="/2025/04/24/note30/note30_pic27.png" class="krzpdshwrxme"></div><p><strong>AB</strong>，在UML组件图当中，供接口和需接口之间的关系就是调用和被调用之间的关系。</p><h3 id="Ⅷ-部署图">Ⅷ 部署图</h3><p>部署图是UML中用于描述​​系统物理架构​​的静态结构图，展示软件组件如何部署到硬件节点（如服务器、设备）上，以及节点间的通信关系，常在<strong>实施阶段</strong>使用，如下图所示：</p><div class="center"><style>.rqgryyoldggi{}</style><img src="/2025/04/24/note30/note30_pic28.png" class="rqgryyoldggi"></div><h3 id="Ⅸ-总结">Ⅸ 总结</h3><div class="center"><h1>表3-1 UML各种视图及其主要概念</h1><table><thead><tr><th style="text-align:center">主要的域</th><th style="text-align:center">视图</th><th style="text-align:center">图</th><th style="text-align:center">主要概念</th></tr></thead><tbody><tr><td style="text-align:center"><strong>结构</strong></td><td style="text-align:center">静态视图</td><td style="text-align:center">类图</td><td style="text-align:center">类、关联、泛化、依赖关系、实现、接口</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">用例视图</td><td style="text-align:center">用例图</td><td style="text-align:center">用例、参与者、关联、扩展、包括、用例泛化</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">实现视图</td><td style="text-align:center">构件图</td><td style="text-align:center">构件、接口、依赖关系、实现</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">部署视图</td><td style="text-align:center">部署图</td><td style="text-align:center">节点、构件、依赖关系、实现</td></tr><tr><td style="text-align:center"><strong>动态</strong></td><td style="text-align:center">状态机视图</td><td style="text-align:center">状态图</td><td style="text-align:center">状态、事件、转换、动作</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">活动视图</td><td style="text-align:center">活动图</td><td style="text-align:center">状态、活动、完成转换、分叉、结合</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">交互视图</td><td style="text-align:center">顺序图</td><td style="text-align:center">交互、对象、消息、激活</td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">协作图</td><td style="text-align:center">协作、交互、协作角色、消息</td></tr><tr><td style="text-align:center"><strong>模型管理</strong></td><td style="text-align:center">模型管理视图</td><td style="text-align:center">类图</td><td style="text-align:center">包、子系统、模型</td></tr><tr><td style="text-align:center"><strong>可扩展性</strong></td><td style="text-align:center">所有</td><td style="text-align:center">所有</td><td style="text-align:center">约束、构造型、标记值</td></tr></tbody></table></div>]]></content>
    
    
    <summary type="html">软考中级备考笔记</summary>
    
    
    
    <category term="软考" scheme="http://example.com/categories/%E8%BD%AF%E8%80%83/"/>
    
    <category term="软件设计师" scheme="http://example.com/categories/%E8%BD%AF%E8%80%83/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/"/>
    
    <category term="上午题" scheme="http://example.com/categories/%E8%BD%AF%E8%80%83/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/%E4%B8%8A%E5%8D%88%E9%A2%98/"/>
    
    
    <category term="软考" scheme="http://example.com/tags/%E8%BD%AF%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>软件设计师 下午题 试题二 数据库设计</title>
    <link href="http://example.com/2025/04/23/note29/"/>
    <id>http://example.com/2025/04/23/note29/</id>
    <published>2025-04-23T13:01:43.000Z</published>
    <updated>2025-05-08T08:26:59.063Z</updated>
    
    <content type="html"><![CDATA[<style>.center {  width: auto;  display: table;  margin-left: auto;  margin-right: auto;}</style><h1>软件设计师 下午题 试题二 数据库设计</h1><h2 id="一、问题一">一、问题一</h2><p>问题一一般考察的内容就是ER图中缺失的联系，如下图所示：</p><div class="center"><style>.xkvwzipkofjx{}</style><img src="/2025/04/23/note29/note29_pic01.png" class="xkvwzipkofjx"></div><p>以《软件设计师考试同步辅导（下午科目）》中的例题为例：</p><div class="center"><style>.xnmlzfopsgcv{}</style><img src="/2025/04/23/note29/note29_pic02.png" class="xnmlzfopsgcv"></div><p>答：<strong>配送员-配送-地点，多对多联系</strong>。</p><h2 id="二、问题二">二、问题二</h2><p>问题二一般考察的是补充关系模式中缺失的属性，依旧以例1为例：</p><div class="center"><style>.fwssujisiaxn{}</style><img src="/2025/04/23/note29/note29_pic03.png" class="fwssujisiaxn"></div><p>答：<br>（a）<strong>商品数量，仓库信息</strong>；<br>（b）<strong>支付凭证号码</strong>；<br>（c）<strong>商品条码，订单ID</strong>；<br><br><br>作答此题时不能仅仅看ER图进行回答，还要通读题干中的【需求描述】，否则很容易遗失属性信息。此外每一空中不一定只缺失一个属性，需要将所有缺失的属性都补充完整。例如<code>仓库信息</code>的出处就是（5）中的<code>商品所在的仓库信息</code>。</p><h2 id="三、问题三">三、问题三</h2><p>问题三的考察内容不固定，但是一般需要掌握以下知识点，以应对除了修改ER图之外的考点：</p><ol><li>弱实体：弱实体是不能单独存在，必须依赖于其它实体才能存在的实体。弱实体用双线矩形框表示，其与实体的关系用双线菱形表示。</li><li>简单属性：简单属性是指​​不能再分解​​为更小组成部分的属性，它是数据库中最基本的数据单元。简单属性也称为​​原子属性​​，表示一个实体的单一特征。</li><li>规范性问题：按第一范式到第三范式的标准逐一检查是否符合规范，下面来复习一下各个范式的要求：<ol><li>第一范式：表中所有属性都应该是简单属性。</li><li>第二范式：表中不允许存在部分依赖，即非主属性不能依赖于组合主键的一部分。</li><li>第三范式：表中不允许存在传递依赖，即一个非主属性不能依赖于另一个非主属性。</li></ol></li></ol><p>除此之外，最主要的考察内容就是对ER图进行补充和修改，具体情况具体分析即可。</p>]]></content>
    
    
    <summary type="html">软考中级备考笔记</summary>
    
    
    
    <category term="软考" scheme="http://example.com/categories/%E8%BD%AF%E8%80%83/"/>
    
    <category term="软件设计师" scheme="http://example.com/categories/%E8%BD%AF%E8%80%83/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/"/>
    
    <category term="下午题" scheme="http://example.com/categories/%E8%BD%AF%E8%80%83/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/%E4%B8%8B%E5%8D%88%E9%A2%98/"/>
    
    
    <category term="软考" scheme="http://example.com/tags/%E8%BD%AF%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>软件设计师 下午题 试题一 数据流图设计</title>
    <link href="http://example.com/2025/04/23/note28/"/>
    <id>http://example.com/2025/04/23/note28/</id>
    <published>2025-04-23T11:32:38.000Z</published>
    <updated>2025-05-08T08:26:55.535Z</updated>
    
    <content type="html"><![CDATA[<style>.center {  width: auto;  display: table;  margin-left: auto;  margin-right: auto;}</style><h1>软件设计师 下午题 试题一 数据流图设计</h1><p>数据流图也称数据流程图（Data Flow Diagram, DFD），其中基本的图形元素有数据流、加工、数据存储和外部实体。</p><div class="center"><style>.fsvjjxhjdodl{}</style><img src="/2025/04/23/note28/note28_pic01.png" class="fsvjjxhjdodl"></div><ol><li>外部实体(External Agent)：存在于当前软件系统之外的人、物或者外部系统：<ol><li>人：学生、老师、员工…</li><li>物：传感器、控制器、车辆、部门…</li><li>外部系统：支付系统、库存管理系统…</li></ol></li><li>加工(Process)：加工描述了输入数据流到输出数据流之间的变换，每个加工都有一个名字和编号。一个加工至少有一个输入数据流和一个输出数据流。<ol><li>只有输入没有输出的加工称之为黑洞。</li><li>只有输出没有输入的加工称之为白洞。</li><li>加工的数据不足以产生输出数据，称其为灰洞。</li></ol></li><li>数据存储(Data Store)：用来表示存储的数据，每个数据存储都有一个名字。它可以存储加工的输出数据也可以提供加工的输入数据。</li><li>数据流(Data Flow)：用来表示数据的流向。<strong>数据流的起点或者终点必须有一个是加工</strong>。</li></ol><h2 id="一、问题一">一、问题一</h2><p>问题一考察的内容一般是要求写出3到5个实体的名称。</p><p>以《软件设计师考试同步辅导（下午试题）》中的例题为例：</p><div class="center"><style>.kclxsdktrppt{}</style><img src="/2025/04/23/note28/note28_pic02.jpg" class="kclxsdktrppt"></div><p>E1: <strong>学生</strong>，E2: <strong>讲师</strong>，E3: <strong>教务人员</strong></p><h2 id="二、问题二">二、问题二</h2><p>问题二考察的内容一般是要求写出3到5个数据存储的名称。</p><p>依旧以例2为例：</p><div class="center"><style>.juseslrusvfv{}</style><img src="/2025/04/23/note28/note28_pic03.jpg" class="juseslrusvfv"></div><p>D1：<strong>作业（表）</strong>，D2：<strong>学生表</strong>，D3：<strong>讲师表</strong>，D4：<strong>批改后的作业（表）</strong>。<br><br>此外，关于图1-4所表示的上下文数据流图和图1-5所表示的0层数据流图的区别如下表所示：</p><div class="center"><table><thead><tr><th><strong>特性</strong></th><th><strong>上下文DFD</strong></th><th><strong>0层DFD</strong></th></tr></thead><tbody><tr><td><strong>处理过程数量</strong></td><td>1个（整个系统）</td><td>多个（主要子过程）</td></tr><tr><td><strong>数据存储</strong></td><td>不显示</td><td>首次引入</td></tr><tr><td><strong>详细程度</strong></td><td>仅系统与外部交互</td><td>系统内部关键流程</td></tr><tr><td><strong>用途</strong></td><td>定义系统边界</td><td>初步设计内部逻辑</td></tr></tbody></table></div><h2 id="三、问题三">三、问题三</h2><p>问题三一般会考察缺失的数据流的情况，需要根据题意分析缺失了哪些数据流并将其补充完整。</p><p>解决问题三一般有以下几种方法：</p><ol><li>父图子图平衡：父图即为上下文数据流图，子图即为0层数据流图。父图显然一定正确，于是就可以根据父图的正确信息逐一排除子图中的数据流是否有缺失。</li><li>加工既有输入数据流也有输出数据流。</li></ol><p>依旧以例2为例：</p><div class="center"><style>.dfnurlwrxvhq{}</style><img src="/2025/04/23/note28/note28_pic03.jpg" class="dfnurlwrxvhq"></div><p>答：</p><ol><li>数据流名称：通知；起点：提交作业；终点：E1。</li><li>数据流名称：抽检报告；起点：作业抽检；终点：E2。</li><li>数据流名称：分数和评价；起点：记录分数和评价；终点：D2。</li><li>数据流名称：通知；起点：记录分数和评价；终点：E1。</li></ol>]]></content>
    
    
    <summary type="html">软考中级备考笔记</summary>
    
    
    
    <category term="软考" scheme="http://example.com/categories/%E8%BD%AF%E8%80%83/"/>
    
    <category term="软件设计师" scheme="http://example.com/categories/%E8%BD%AF%E8%80%83/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/"/>
    
    <category term="下午题" scheme="http://example.com/categories/%E8%BD%AF%E8%80%83/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/%E4%B8%8B%E5%8D%88%E9%A2%98/"/>
    
    
    <category term="软考" scheme="http://example.com/tags/%E8%BD%AF%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>软件设计师 上午题 数据库</title>
    <link href="http://example.com/2025/04/23/note27/"/>
    <id>http://example.com/2025/04/23/note27/</id>
    <published>2025-04-23T02:28:49.000Z</published>
    <updated>2025-05-08T08:26:51.586Z</updated>
    
    <content type="html"><![CDATA[<style>.center {  width: auto;  display: table;  margin-left: auto;  margin-right: auto;}</style><h1>软件设计师 上午题 数据库</h1><h2 id="一、数据库的三级模式结构">一、数据库的三级模式结构</h2><p>尽管数据库的产品很多，但其体系结构基本上都具有相同的特征，都采用“三级模式和两级映像”。</p><div class="center"><style>.vnjsivwoenkp{}</style><img src="/2025/04/23/note27/note27_pic01.png" class="vnjsivwoenkp"></div><p>数据按外模式的描述提供给用户，按内模式的描述存储在磁盘上，而概念模式提供了连接这两级模式的相对稳定的中间层，并使得两级中任意一级的改变都不受另一级影响。</p><h3 id="Ⅰ-概念模式">Ⅰ 概念模式</h3><p>概念模式也称模式，是在逻辑层上对数据进行抽象，是数据库中全部数据的逻辑结构和特征的描述。起到了基本表的作用（基本表是实际存在的表，是实际存储数据的逻辑表示）。</p><h3 id="Ⅱ-外模式">Ⅱ 外模式</h3><p>外模式也称用户模式或者子模式，是在视图层上对数据进行抽象。它可以作用户与数据库系统的接口，起到了视图的作用。</p><h3 id="Ⅲ-内模式">Ⅲ 内模式</h3><p>内模式也称存储模式，是在物理层上对数据进行抽象。它起到了存储文件的作用。</p><h3 id="Ⅳ-两级映像">Ⅳ 两级映像</h3><p>数据库系统在三级模式之间提供了两级映像：模式/内模式映像，外模式/模式映像。两级映像的确立使得数据具有了独立性：</p><ol><li>数据的物理独立性：内模式发生改变时数据库的逻辑模式不需改变，只需修改模式/内模式映像即可。</li><li>数据的逻辑独立性：用户的应用程序和数据库的逻辑结构是相互独立的，只需修改模式/外模式映像即可。</li></ol><h2 id="二、关系代数">二、关系代数</h2><h3 id="Ⅰ-完整性约束">Ⅰ 完整性约束</h3><p>完整性规则提供了一种手段来保证用户对数据库做修改时不会破坏数据的一致性，关系的完整性一共分为三类：</p><ol><li>实体完整性：关系中主键的值不能为空或部分为空。</li><li>参照完整性：如果关系R2的外键X与关系R1的主键相对应，则外键X的每个值必须在关系R1中主键的值中找到，或者为空值。</li><li>用户定义完整性：针对某一具体的关系数据库的约束条件，由应用的环境决定。例如人的年龄规定必须大于等于0，小于等于200。</li></ol><h3 id="Ⅱ-关系运算">Ⅱ 关系运算</h3><div class="center"><style>.lyjpigidwcrk{}</style><img src="/2025/04/23/note27/note27_pic02.png" class="lyjpigidwcrk"></div><p>以关系R和关系S为例：</p><div class="center"><style>.necitvgrybgo{}</style><img src="/2025/04/23/note27/note27_pic03.png" class="necitvgrybgo"></div><h4 id="1-笛卡尔积">1. 笛卡尔积</h4><p>两个关系R（m个属性n个元组）和S（k个属性p个元组）的笛卡尔积记为R×S，结果是一个新关系：</p><ul><li>包含m+k个属性（先R的所有数据，后S的所有属性）</li><li>包含n×p个元组（每个R的元组与每个S的元组组合一次）</li></ul><div class="center"><style>.sfnjphfeicuk{}</style><img src="/2025/04/23/note27/note27_pic04.png" class="sfnjphfeicuk"></div><h4 id="2-投影">2. 投影</h4><p>投影是从关系的垂直方向进行运算，在关系R中选出若干属性列<em>A</em>组成新的关系，记作$\pi _A\left( R \right) $。</p><div class="center"><style>.rbcvbmifujtq{}</style><img src="/2025/04/23/note27/note27_pic05.png" class="rbcvbmifujtq"></div><h4 id="3-选择">3. 选择</h4><p>选择是从关系的水平方向进行运算，在关系R中选择满足给定条件的诸元组，记作$\sigma _F\left( R \right) <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>。例如，</mtext></mrow><annotation encoding="application/x-tex">。例如，</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">。例如，</span></span></span></span>\sigma _{1\ge 6}\left( R \right) $表示选取R关系中第1个属性值大于等于第6个属性值的元组。</p><div class="center"><style>.kvmrntogfdpo{}</style><img src="/2025/04/23/note27/note27_pic06.png" class="kvmrntogfdpo"></div><h4 id="4-连接">4. 连接</h4><p>连接运算是从两个关系R和S的笛卡尔积中选取满足条件的元组。因此，可以认为笛卡尔积是无条件连接，其它连接认为是有条件连接。</p><h5 id="i-theta-连接">i. $\theta $连接</h5><p>$\theta $连接是从R×S中选取属性间满足一定条件的元组。</p><div class="center"><style>.qhaqrboqskif{}</style><img src="/2025/04/23/note27/note27_pic07.png" class="qhaqrboqskif"></div><h5 id="ii-等值连接">ii. 等值连接</h5><p>等值连接是特殊的$\theta $连接，其中的比较符号只能为&quot;=&quot;。</p><h5 id="iii-自然连接">iii. 自然连接</h5><p>自然连接是一种特殊的等值连接，它要求两个关系中进行比较的分量必须是相同的属性组，并在结果集中将重复属性列去掉。<br>自然连接可以记为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo>⋈</mo><mi>S</mi></mrow><annotation encoding="application/x-tex">R\Join S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6883em;vertical-align:-0.005em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⋈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span>。</p><div class="center"><style>.sqbnvxzgilgi{}</style><img src="/2025/04/23/note27/note27_pic08.jpg" class="sqbnvxzgilgi"></div><p>需要注意的是，自然连接不仅要在垂直方向上运算，也要在水平方向上运算。</p><hr><div class="center"><table><thead><tr><th>连接类型</th><th>条件</th><th>结果属性</th><th>重复列</th></tr></thead><tbody><tr><td>θ连接</td><td>任意比较条件</td><td>全部保留</td><td>保留</td></tr><tr><td>等值连接</td><td>等号条件</td><td>全部保留</td><td>保留</td></tr><tr><td>自然连接</td><td>同名属性自动匹配</td><td>去重</td><td>不保留</td></tr></tbody></table></div><h4 id="5-外连接">5. 外连接</h4><p>外连接是连接运算的扩展，可以处理由于连接运算而丢失的信息。</p><div class="center"><style>.jnhocdhmdewr{}</style><img src="/2025/04/23/note27/note27_pic09.jpg" class="jnhocdhmdewr"></div><p>如上图所示，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo>⋈</mo><mi>S</mi><mi>C</mi></mrow><annotation encoding="application/x-tex">S\Join SC</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6883em;vertical-align:-0.005em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⋈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">SC</span></span></span></span>中就丢失黎明、赵国庆等人的信息，而外连接就可以用来处理这种情况。</p><h5 id="i-左外连接">i. 左外连接</h5><p>左外连接是取出左侧关系中所有与右侧关系中任一元组都不匹配的元组，用空值null来填充所有来自右侧关系的属性，并构成新的元组。</p><div class="center"><style>.fwfoqgcxejth{}</style><img src="/2025/04/23/note27/note27_pic10.png" class="fwfoqgcxejth"></div><h5 id="ii-右外连接">ii. 右外连接</h5><p>右外连接和左外连接正相反，它是取出右侧关系中所有与左侧关系中任一元组都不匹配的元组，并用null替代后组成新的元组。</p><div class="center"><style>.zhuiichfvdqq{}</style><img src="/2025/04/23/note27/note27_pic11.png" class="zhuiichfvdqq"></div><h5 id="iii-全外连接">iii. 全外连接</h5><p>可以理解为在进行完一次左外连接之后再进行一次右外连接。</p><div class="center"><style>.cifpyisoryai{}</style><img src="/2025/04/23/note27/note27_pic12.png" class="cifpyisoryai"></div><h3 id="Ⅲ-真题赏析">Ⅲ 真题赏析</h3><div class="center"><style>.xfuevwdxcojx{}</style><img src="/2025/04/23/note27/note27_pic13.png" class="xfuevwdxcojx"></div><p><strong>D</strong>，应该优先执行选择运算，这样一来可以大幅缩减笛卡尔积得到的结果，增加查询效率。</p><hr><div class="center"><style>.rswgjgmykhql{}</style><img src="/2025/04/23/note27/note27_pic14.png" class="rswgjgmykhql"></div><ol start="54"><li><strong>C</strong>，由题意可得投影中的第一列为员工工号，第二列为姓名，也就是说第一张表的第一二列分别为员工工号、姓名，因此第一张表为E。此外，中文需要使用单引号包括。</li><li><strong>B</strong>。同理，第二张表为C。虽然最后不用查询商品号，但为了使用商品号属性和EC连接，在投影时还需要先包括这一列。</li><li><strong>C</strong>。同理，第三张表为EC。</li></ol><h3 id="后续内容大部分笔者都已经在专业课上学过了，就不再赘述了，留个尾巴以后刷题的时候在这里放错题集。">后续内容大部分笔者都已经在专业课上学过了，就不再赘述了，留个尾巴以后刷题的时候在这里放错题集。</h3>]]></content>
    
    
    <summary type="html">软考中级备考笔记</summary>
    
    
    
    <category term="软考" scheme="http://example.com/categories/%E8%BD%AF%E8%80%83/"/>
    
    <category term="软件设计师" scheme="http://example.com/categories/%E8%BD%AF%E8%80%83/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/"/>
    
    <category term="上午题" scheme="http://example.com/categories/%E8%BD%AF%E8%80%83/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/%E4%B8%8A%E5%8D%88%E9%A2%98/"/>
    
    
    <category term="软考" scheme="http://example.com/tags/%E8%BD%AF%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>软件设计师 上午题 知识产权</title>
    <link href="http://example.com/2025/04/23/note26/"/>
    <id>http://example.com/2025/04/23/note26/</id>
    <published>2025-04-23T02:26:17.000Z</published>
    <updated>2025-05-08T08:26:48.093Z</updated>
    
    <content type="html"><![CDATA[<style>.center {  width: auto;  display: table;  margin-left: auto;  margin-right: auto;}</style><h1>软件设计师 上午题 知识产权</h1><p>这一部分的知识技术性弱记忆性强，比较枯燥，主要涉及的知识点将直接按点陈列：</p><ol><li><p>著作权当中，只有发表权受时间限制（我国公民的作品发表权的保护期为作者终生及其死亡后50年），其它诸如署名权、修改权和保护作品完整权等权利均不受时间限制。</p></li><li><p>知识产权具有严格的地域性特点，即各国主管机关授予的知识产权只在本国领域内受法律保护，其它国家则不予保护。</p></li><li><p>软件著作权：</p><ol><li>软件著作权产生的时间为自作品完成创作之日。</li><li>软件著作权的客体，即受保护对象，有1）计算机程序，2）计算机软件的文档。</li><li>《中华人民共和国著作权法》和《计算机软件保护条例》是构成我国保护计算机软件著作权的两个法律文件。</li></ol></li><li><p>职务作品：职务作品即为公民在任职期间为工作单位开发的作品。</p><ol><li>如果雇员开发的软件属于本质工作的结果，或者主要使用了单位的设备进行开发，则软件著作权不属于个人。</li></ol><blockquote><p>如果是执行本职工作的结果，即针对本职工作中明确指定的开发目标所开发的，或者是从事本职工作活动所预见的结果或自然的结果;则该软件的著作权属于该单位。</p></blockquote><ol start="2"><li>公民仅享有职务作品的署名权。</li></ol></li><li><p>委托开发：</p><ol><li>若委托方与受托方以合同形式约定了软件著作权的归属关系，则软件著作权的归属应按根据此合同来确定。</li><li>若委托方与受托方没有签订合同，或没有在合同中明确规定了软件著作权的归属，则软件著作权属于受托方。</li></ol></li><li><p>利用商业秘密权可以对软件的技术信息、经营信息提供保护。</p></li></ol><blockquote><p>《反不正当竞争法》中商业秘密定义为“指不为公众所知悉的、能为权利人带来经济利益、具有实用性并经权利人采取保密措施的技术信息和经营信息”。</p></blockquote><ol start="7"><li>若甲、乙<strong>同一天</strong>向专利局申请发明专利，则专利权申请人需要由甲、乙公司协商确定。但是不可能向甲、乙都授予专利权。</li><li>我国商标权的保护期限自核准注册之日起10年内有效，但可以根据其所有人的需要无限地延长权利期限。</li><li>若甲、乙<strong>同一天</strong>进行商标注册且都不愿意放弃注册，则需要由甲、乙抽签决定谁能进行注册。</li><li>根据我国商标法，烟草制品必须使用注册商标。</li></ol>]]></content>
    
    
    <summary type="html">软考中级备考笔记</summary>
    
    
    
    <category term="软考" scheme="http://example.com/categories/%E8%BD%AF%E8%80%83/"/>
    
    <category term="软件设计师" scheme="http://example.com/categories/%E8%BD%AF%E8%80%83/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/"/>
    
    <category term="上午题" scheme="http://example.com/categories/%E8%BD%AF%E8%80%83/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/%E4%B8%8A%E5%8D%88%E9%A2%98/"/>
    
    
    <category term="软考" scheme="http://example.com/tags/%E8%BD%AF%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>软件设计师 上午题 程序设计语言</title>
    <link href="http://example.com/2025/04/22/note25/"/>
    <id>http://example.com/2025/04/22/note25/</id>
    <published>2025-04-22T07:00:53.000Z</published>
    <updated>2025-05-08T08:26:44.143Z</updated>
    
    <content type="html"><![CDATA[<style>.center {  width: auto;  display: table;  margin-left: auto;  margin-right: auto;}</style><h1>软件设计师 上午题 程序设计语言</h1><p>程序设计语言是为了书写计算机程序而人为设计的符号语言，本节主要介绍程序设计语言的基本概念、基本成分和一些有代表性的程序设计语言。</p><h2 id="一、程序设计语言的基本概念">一、程序设计语言的基本概念</h2><h3 id="Ⅰ-低级语言和高级语言">Ⅰ 低级语言和高级语言</h3><ol><li>低级语言：面向机器的语言，即机器语言和汇编语言。<ol><li>机器语言：机器语言是最基本的计算机语言，也就是我们在计算机系统章节中常常提起的机器指令，由01组成。使用机器语言设计的程序可读性很差，因此也难以维护。</li><li>汇编语言：人类并不能像机器一样直接读取01，因此人们就想出了一种办法：使用容易记忆的符号来代替01序列，比如用<code>ADD</code>来表示加法等。这些符号表示的指令即为汇编指令，进而可以构成汇编语言。</li></ol></li><li>高级语言：面向各类应用的程序设计语言，这类语言和人们使用的自然语言很接近，如主流的Java、Cpp和Python等。</li></ol><h3 id="Ⅱ-语言的翻译">Ⅱ 语言的翻译</h3><p>显然计算机不可能直接理解汇编语言和高级语言，因此执行这类语言时就需要翻译，基本方式有汇编、解释和编译。</p><ol><li>汇编：如果源程序是用汇编语言编写的，则需要一个汇编程序将其翻译成目标程序后才能执行。</li><li>解释和编译：如果源程序是用某种高级语言编写的，则需要对应的解释程序或者编译程序对其进行翻译：<ol><li>解释程序：边解释边执行，​​不生成独立的目标代码​​，每次运行都需要解释器实时翻译。</li><li>编译程序：将源代码​​一次性​​转换为目标机器代码（如二进制可执行文件），生成独立的可执行程序。</li></ol></li></ol><h2 id="二、语言处理程序基础">二、语言处理程序基础</h2><p>语言处理程序即为前文所述的翻译程序，它们将高级语言或汇编语言编写的程序翻译成某种机器语言程序使其可在计算机上运行。备考中我们重点要掌握的是编译程序的基本原理。</p><h3 id="Ⅰ-编译程序的基本原理">Ⅰ 编译程序的基本原理</h3><p>编译程序的功能是将某高级语言书写的源程序翻译成与之等价的目标程序（汇编语言或机器语言）。其工作过程如下图所示：</p><div class="center"><style>.kerlbxgqudgn{}</style><img src="/2025/04/22/note25/note25_pic01.png" class="kerlbxgqudgn"></div><h4 id="1-词法分析">1. 词法分析</h4><p>词法分析​是编译器的第一个阶段，其核心任务是将​​源代码的字符序列​​转换为有意义的​<strong>​词法单元</strong>（Token）序列​，也即<strong>记号流</strong>，为后续的语法分析提供结构化输入。<br>其中，每个Token常以二元组的方式输出，即<code>&lt;Token Type, Value&gt;</code>。常见的Token Type有关键字、标识符、常数、运算符和分隔符等。<br>比如有这样一串C语言代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> x = <span class="hljs-number">42</span>;<br></code></pre></td></tr></table></figure><p>那么在进行词法分析后输出的Tokens就应该为：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs txt">&lt;关键字, &quot;int&quot;&gt;<br>&lt;标识符, &quot;x&quot;&gt;<br>&lt;运算符, &quot;=&quot;&gt;<br>&lt;整常数, &quot;42&quot;&gt;<br>&lt;分隔符, &quot;;&quot;&gt;<br></code></pre></td></tr></table></figure><p>进行词法分析可以跳过空格、换行、注释等不影响程序逻辑的字符，并将连续的字符组合成有意义的单元（如变量名x、数字42），有效简化了后续的语法分析。</p><h4 id="2-语法分析">2. 语法分析</h4><p>​语法分析​​是继词法分析之后的第二个关键阶段，其核心任务是将​​词法分析生成的Token序列​​转换为​​结构化的语法树​​，以验证整个输入串是否构成一个语法上正确的程序。<br>如果源程序中没有语法错误，这一阶段就能正确地构造出一个语法树，否则就会指出源程序的语法错误并给出相应的诊断信息。<br>例如上文中的Tokens就能被构造出这样一个语法树：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs txt">     Declaration<br>     /    |    \<br>Type   Name   Value<br>(int)   (x)    (42)<br></code></pre></td></tr></table></figure><h4 id="3-语义分析">3. 语义分析</h4><p>​​语义分析是继​​词法分析​​和​​语法分析​​之后的第三个关键阶段。它的核心任务是​​检查源代码是否符合语言的语义规则​​，确保程序<strong>在逻辑上是正确的</strong>，不会出现类似于“猫吃代码”的谬误，而不仅仅是语法正确。<br>例如，整除取余运算符只能对整型进行运算，若其运算对象中有浮点数就可以认为存在类型不匹配的错误。</p><h4 id="4-中间代码生成">4. 中间代码生成</h4><p>中间代码生成​​是编译器的核心阶段之一，位于​​前端（词法/语法/语义分析）​​和​​后端（目标代码生成与优化）​​之间。它的任务是将​​语义分析后的语法树​转换为一种<strong>​​与机器无关</strong>的中间表示（IR）​​，可以将不同的高级语言转换为同一种中间代码，使其具备了跨平台的能力，为后续优化和目标代码生成提供了统一接口。<br>常见的中间代码有：后缀式、三地址码、三元式、四元式和树（图）等形式。</p><h4 id="5-目标代码生成">5. 目标代码生成</h4><p>目标代码生成是编译器工作的最后一个阶段，这一阶段的任务即为将中间代码变换为特定机器上的指令代码。由于是生成特定机器上的代码，<strong>这一阶段的工作与具体的机器密切相关</strong>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs asm">; 同一加法操作在不同架构下的代码可能完全不同<br><br>; x86<br>add eax, ebx<br><br>; ARM<br>add r0, r1, r2<br><br>; MIPS<br>add $t0, $t1, $t2<br></code></pre></td></tr></table></figure><p>编译过程中的中间代码生成和代码优化不是必须的，可省略。</p><h3 id="Ⅱ-词法分析中的模型">Ⅱ 词法分析中的模型</h3><p>正如前文所述，词法分析是一个将源程序中的字符串转换为单词符号序列的一个过程，而这个过程所依赖的模型有以下几个：</p><h4 id="1-正规式与正规集">1. 正规式与正规集</h4><div class="center"><style>.kergshcblyym{}</style><img src="/2025/04/22/note25/note25_pic07.png" class="kergshcblyym"></div><p>正规式是一种用于描述​​字符串模式​​的形式化表达式，用于匹配符合特定规则的字符串集合，是定义​​正规集​​的数学工具。<br>例如有一个正规式<code>a*</code>，它就定义了一个正规集<code>&#123;ε, &quot;a&quot;, &quot;aa&quot;, &quot;aaa&quot;, ...&#125;</code>；再比如正规式<code>(a|b)*</code>定义的正规集就是<code>&#123;ε, &quot;a&quot;, &quot;b&quot;, &quot;aa&quot;, &quot;ab&quot;, &quot;ba&quot;, &quot;bb&quot;, &quot;aabba&quot;, &quot;babab&quot;, ...&#125;</code>。</p><h4 id="2-有限自动机">2. 有限自动机</h4><p>有限自动机是一种用来识别正规集的抽象计算模型，又可以继续分为确定的有限自动机和不确定的有限自动机两类：</p><ul><li>确定的有限自动机（Deterministic Finite Automata, DFA）：对每一个状态来说识别字符后转移的状态是唯一的。</li></ul><div class="center"><style>.micbwlhfmjpq{}</style><img src="/2025/04/22/note25/note25_pic09.png" class="micbwlhfmjpq"></div><p>  有限自动机中所谓的状态转移图和状态转移矩阵的概念和在数电中学习过的状态图基本类似，只是需要注意的是双圈表示的结点是终结结点。</p><ul><li>不确定的有限自动机（Nodeterministic Finite Automata, NFA）：对每一个状态来说识别字符后转移的状态是不确定的。</li></ul><div class="center"><style>.sdjwzusxybdf{}</style><img src="/2025/04/22/note25/note25_pic10.png" class="sdjwzusxybdf"></div><p>当一个字符串被输入进有限自动机中之后，如果在最后一个字符被输入之后，自动机的状态落到了双圈的终结结点上，该自动机就会返回一个“接受”的状态，说明这个字符串满足目标语言的规则，反之就会返回一个“拒绝”的状态。<br>也就是说，在有限自动机当中，所谓的终结结点并不是说自动机在进入这一状态之后就会终止，而是在终止时据此返回结果。</p><h3 id="Ⅲ-语法分析中的模型">Ⅲ 语法分析中的模型</h3><p>语法分析中所要用到的一个重要模型是上下文无关文法，程序设计语言的绝大部分语法规则可以采用上下文无关文法进行描述。<br>一个上下文无关文法可以由以下几部分组成；</p><ul><li>非终结符：可进一步展开的表示语法结构的抽象符号，一般用大写英文字母表示。</li><li>终结符：组成语言的基本符号，一般用小写英文字母表示。</li><li>产生式规则：定义非终结符如何展开为终结符和非终结符的组合。</li><li>开始符号：语法推导的起点。</li></ul><p>比如以下这道例题：</p><div class="center"><style>.urgeaokmuckg{}</style><img src="/2025/04/22/note25/note25_pic12.png" class="urgeaokmuckg"></div><p>其中类似于<code>T -&gt; F|T*F</code>就是一条产生式规则，定义了在非终结符<code>T</code>的展开规则。</p><h3 id="Ⅳ-解释程序的基本原理">Ⅳ 解释程序的基本原理</h3><p>正如前文所述，编译程序可分为：词法分析、语法分析、语义分析、中间代码生成、代码优化和目标代码生成六个部分。而对于解释程序而言，有前三个过程即可。即编译器和解释器都不能省略词法分析、语法分析和语义分析三个阶段且顺序不可交换。</p><h3 id="Ⅴ-真题赏析">Ⅴ 真题赏析</h3><div class="center"><style>.ljgvfhsvfnbn{}</style><img src="/2025/04/22/note25/note25_pic02.png" class="ljgvfhsvfnbn"></div><p><strong>C</strong>，语义分析阶段只能发现静态错误，动态语义错误只有在程序运行时才能发现。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 静态语义错误</span><br><span class="hljs-type">int</span> x = <span class="hljs-string">&quot;hello&quot;</span>;  <span class="hljs-comment">// 错误：int 不能赋值为字符串（类型不匹配）</span><br><br><span class="hljs-built_in">printf</span>(y);        <span class="hljs-comment">// 错误：y 未声明</span><br><br><span class="hljs-comment">// -----------------------------------------------------------</span><br><br><span class="hljs-comment">// 动态语义错误</span><br><span class="hljs-type">int</span> a = <span class="hljs-number">10</span> / <span class="hljs-number">0</span>;    <span class="hljs-comment">// 运行时错误：除零</span><br><span class="hljs-type">int</span> arr[<span class="hljs-number">3</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, arr[<span class="hljs-number">5</span>]); <span class="hljs-comment">// 运行时错误：数组越界</span><br><br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span><br><span class="hljs-keyword">while</span> (i &lt; <span class="hljs-number">1</span>)<br>&#123;<br>  i--<br>&#125; <span class="hljs-comment">// 运行时错误：死循环</span><br><br></code></pre></td></tr></table></figure><hr><div class="center"><style>.mqvbyngijyqj{}</style><img src="/2025/04/22/note25/note25_pic03.png" class="mqvbyngijyqj"></div><p><strong>D</strong>，B选项的错误在于应该为<code>在语法分析阶段可以发现程序中的所有语法错误</code>，而非<code>所有错误</code>。</p><hr><div class="center"><style>.mfsnwbmmloie{}</style><img src="/2025/04/22/note25/note25_pic04.png" class="mfsnwbmmloie"></div><p><strong>D</strong>，寄存器分配是目标代码生成阶段的核心任务之一，这是由于将中间代码转换为机器码时需要分配物理寄存器。</p><hr><div class="center"><style>.kylpfgkpahpg{}</style><img src="/2025/04/22/note25/note25_pic05.png" class="kylpfgkpahpg"></div><p><strong>A</strong>，词法分析和语法分析的核心区别在于前者是检查字符是否符合规定而后者是检查语句是否符合规定。</p><hr><div class="center"><style>.ghgselncnkdi{}</style><img src="/2025/04/22/note25/note25_pic06.png" class="ghgselncnkdi"></div><p><strong>B</strong>，类型检查是​​语义分析阶段​​的核心任务之一，进行类型检查可以确保程序在逻辑上正确，避免出现对浮点数进行模运算等错误情况。</p><hr><div class="center"><style>.serrzgjolezs{}</style><img src="/2025/04/22/note25/note25_pic08.png" class="serrzgjolezs"></div><p><strong>B</strong>，对于A选项而言，0*有可能为空串，其开头和结尾也有可能是1。</p><hr><div class="center"><style>.lfuxhnqngzwh{}</style><img src="/2025/04/22/note25/note25_pic11.png" class="lfuxhnqngzwh"></div><p><strong>B</strong>，从题中的自动机可分析出，初态q0同时是终态，从q0到q0的弧(标记 0)表明该自动机识别零个或多个0构成的串，路径q0→q1→q0的循环表明“10”的多次重复，因此该自动机识别的字符串是“010”的无穷多次，表示为(0|10)*。</p>]]></content>
    
    
    <summary type="html">软考中级备考笔记</summary>
    
    
    
    <category term="软考" scheme="http://example.com/categories/%E8%BD%AF%E8%80%83/"/>
    
    <category term="软件设计师" scheme="http://example.com/categories/%E8%BD%AF%E8%80%83/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/"/>
    
    <category term="上午题" scheme="http://example.com/categories/%E8%BD%AF%E8%80%83/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/%E4%B8%8A%E5%8D%88%E9%A2%98/"/>
    
    
    <category term="软考" scheme="http://example.com/tags/%E8%BD%AF%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>软件设计师 上午题 计算机系统</title>
    <link href="http://example.com/2025/04/20/note24/"/>
    <id>http://example.com/2025/04/20/note24/</id>
    <published>2025-04-20T13:03:35.000Z</published>
    <updated>2025-05-08T08:26:32.837Z</updated>
    
    <content type="html"><![CDATA[<style>.center {  width: auto;  display: table;  margin-left: auto;  margin-right: auto;}.qus{  background-color: #ABBAEA;}</style><h1>软件设计师 上午题 计算机系统</h1><p>众所周知，计算机系统是由软件和硬件组成的。其中其基本硬件系统则由运算器、控制器、存储器、输入设备和输出设备5大部件组成。而运算器和控制器又被集成在一起组成了中央处理单元（CPU），亦即硬件系统的核心。</p><h2 id="一、中央处理单元（CPU）">一、中央处理单元（CPU）</h2><div class="center"><style>.zfpmioehhdfi{}</style><img src="/2025/04/20/note24/note24_pic01.png" class="zfpmioehhdfi"></div><p>正如前文所述，CPU由运算器和控制器，以及寄存器组组成（需要注意的是，运算器是在控制器的命令下进行动作的执行部件）：</p><h3 id="Ⅰ-CPU的组成部件">Ⅰ CPU的组成部件</h3><ol><li><p>运算器<br>正如其名，运算器是一种用来完成计算机的各种算术和逻辑运算的数据加工处理部件。因此其具有以下两个主要功能：</p><ol><li>执行所有的算术运算，例如基本的四则运算。</li><li>执行所有的逻辑运算并进行逻辑测试，例如与或非及零值测试。</li></ol><p>而运算器又是由以下几个部件组成的：</p><ol><li>算术逻辑单元（Arithmetic and Logic Unit, ALC），负责处理数据，实现对数据的算术运算和逻辑运算。</li><li>累加寄存器（Accumulator register, AC），亦即累加器。其主要功能是为ALU开辟一片工作区，这个过程与我们使用栈来进行数学计算的过程类似。由于最终的运算结果是存储在累加器中的，因此<strong>每个运算器中都至少要有一个累加器</strong>。</li><li>数据缓冲寄存器（DR）和状态条件寄存器（PSW）了解即可，前者是CPU和内存间交换数据的中转站，后者则是用来判别当前指令完成后的状态。</li></ol></li><li><p>控制器<br>和只能完成运算的运算器不同，控制器用于控制整个CPU的工作，实现了计算机运行的自动化。它不仅要保证程序的正确执行，还要能够处理异常事件。<br>控制器主要的功能有指令控制逻辑、时序控制逻辑、总线控制逻辑和中断控制逻辑：</p><ol><li>指令控制逻辑：即完成取指令、分析指令和执行指令的一系列操作，包含了以下部件（需要了解是，<strong>一条指令通常是由地址码和操作码组成的</strong>）：<ol><li>程序计数器（Program Counter, PC）：每次执行指令时，CPU都会自动修改PC的内容，使得其保持的始终都是将要执行的下一条指令的地址。</li><li>指令寄存器（Instruction Register, IR）：当CPU要从PC中得到了将要执行的下一条指令的地址时，这条指令的转移过程为：内存–&gt;数据缓存寄存器（DR）–&gt;指令寄存器（IR）。</li><li>指令译码器（Instruction Decoder, ID）：ID根据IR的内容获得指令，进而对指令中的操作码字段进行分析解释，进而向操作控制器发出具体的控制信号以完成所需的功能。</li><li>地址寄存器（Address Register, AR）：由于内存和CPU的操作速度不同，需要AR来保存当前CPU所访问的内存单元的地址，直到内存的I/O操作完成。</li></ol></li><li>时序控制逻辑：为每条指令按时间顺序提供应有的控制信号。</li><li>总线控制逻辑：控制总线，即控制为多个功能部件服务的信息通路。</li><li>中断控制逻辑：控制各种中断请求，并根据优先级的高低对中断请求进行排队。</li></ol></li><li><p>寄存器组<br>寄存器组可分为专用寄存器和通用寄存器，前者是指控制器和运算器中的寄存器，而后者的用途更为广泛，具体功能可以由程序员来定义。</p></li></ol><h3 id="Ⅱ-CPU的功能">Ⅱ CPU的功能</h3><p>通过以上几个组成部分的协作，CPU主要具备了以下几种功能：</p><ol><li>程序控制：CPU通过执行指令来控制程序的执行顺序。</li><li>操作控制：一条指令的实现需要若干个操作信号配合完成，因此CPU会产生每条指令的操作信号并将其送往对应的部件，使其按指令的功能要求进行操作。</li><li>时间控制：CPU对各种操作进行时间上的控制。</li><li>数据处理：CPU通过对数据进行加工处理来生成可以被人们利用的结果，<strong>这是CPU最根本的任务</strong>。</li><li>异常响应：CPU需要对系统内外的中断（异常）做出响应。</li></ol><h3 id="Ⅲ-寻址">Ⅲ 寻址</h3><p>寻址根据操作数的存放位置不同主要有以下几种类型：</p><blockquote><p>操作数和前文中提到的操作码并不相同，操作数是指令的操作对象，提供操作所需的数据或数据存储位置；而操作码则是指令中指定操作类型的部分，告诉CPU执行何种操作（如加法、跳转等）</p></blockquote><ul><li>立即寻址：操作数就包括在指令当中。</li><li>直接寻址：操作数存放在内存单元当中，指令中直接给出操作数所在存储单元的地址。</li><li>间接寻址：指令中给出操作数地址的地址。</li><li>寄存器寻址：操作数存放在某一寄存器当中，指令中给出存放操作数的寄存器名。</li><li>寄存器间接寻址：操作数存放在内存单元中，该单元的地址在某个寄存器中。</li></ul><h3 id="Ⅳ-真题赏析">Ⅳ 真题赏析</h3><div class="center"><style>.aehvljvleqoh{}</style><img src="/2025/04/20/note24/note24_pic02.png" class="aehvljvleqoh"></div><p><strong>C</strong>，一条将要被CPU执行的指令都将存放在指令寄存器（IR）当中，而操作码和地址码都是指令的一部分，也都将被存放在IR当中。</p><hr><div class="center"><style>.qajqhkfmuvtd{}</style><img src="/2025/04/20/note24/note24_pic03.png" class="qajqhkfmuvtd"></div><blockquote><p>“对用户透明”（Transparent to the User）在计算机科学中指的是：<br>某个硬件或软件组件的存在和操作对用户（程序员或普通用户）不可见，无需用户主动干预或直接操作。</p></blockquote><p><strong>B</strong>，IR存储当前正在执行的指令内容，由 CPU 内部自动管理，程序员无法直接访问或修改，因此对用户完全透明。</p><hr><div class="center"><style>.qxtwwmzgojoo{}</style><img src="/2025/04/20/note24/note24_pic04.png" class="qxtwwmzgojoo"></div><p><strong>C</strong>，虽然指令是被寄存在IR当中的，但正如上文中所说的“当CPU要从PC中得到了将要执行的下一条指令的地址时…”，首先需要在PC处获取下一条指令的地址才能从内存中读取指令操作码。</p><hr><div class="center"><style>.hvkpjaswfkfq{}</style><img src="/2025/04/20/note24/note24_pic06.png" class="hvkpjaswfkfq"></div><p><strong>B</strong>，题干中的<code>#45</code>即为操作数，操作数直接包含在指令当中，为立即寻址，将要把操作数放在寄存器当中，为寄存器寻址。</p><hr><div class="center"><style>.cjijiiryjhzy{}</style><img src="/2025/04/20/note24/note24_pic07.png" class="cjijiiryjhzy"></div><blockquote><p>计算机的​​字长​​（Word Size）是指计算机在​​一次操作中能够处理的数据位数​​，它是CPU设计中的一个核心参数，直接影响计算机的性能和效率。根据字长，我们可以确定计算机一次能处理的二进制位数，即“字”（Word）。</p></blockquote><p><strong>C</strong>，按字编址说明寻址的基本单位是“字”，即最小寻址单位就是一个Word，在本题的情境下，即32bits = 4Byte。而内存容量2GB = 2048MB = <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>31</mn></msup></mrow><annotation encoding="application/x-tex">2^{31}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">31</span></span></span></span></span></span></span></span></span></span></span></span>Byte。<br>那么可寻址范围即为</p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msup><mn>2</mn><mn>31</mn></msup><mo>÷</mo><msup><mn>2</mn><mn>2</mn></msup><mtext> </mtext><mo>=</mo><mtext> </mtext><msup><mn>2</mn><mn>29</mn></msup><mi>B</mi><mi>y</mi><mi>t</mi><mi>e</mi><mtext> </mtext><mo>=</mo><mtext> </mtext><mn>512</mn><mi>M</mi><mi>B</mi></mrow><annotation encoding="application/x-tex">2^{31}\div 2^2\ =\ 2^{29}Byte\ =\ 512MB</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9474em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">31</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">÷</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8641em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace"> </span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace"> </span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0585em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">29</span></span></span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mspace"> </span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace"> </span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">512</span><span class="mord mathnormal" style="margin-right:0.05017em;">MB</span></span></span></span></span></p><hr><div class="center"><style>.cptnulckdnqs{}</style><img src="/2025/04/20/note24/note24_pic08.png" class="cptnulckdnqs"></div><p><strong>A</strong>，寻址速度：立即寻址&gt;寄存器寻址&gt;直接寻址&gt;寄存器间接寻址&gt;间接寻址。</p><h2 id="二、计算机中的数据表示">二、计算机中的数据表示</h2><p>机器数的原反补及移码表示不再赘述，我们下边来了解一下定点数和浮点数：</p><h3 id="Ⅰ-定点数和浮点数">Ⅰ 定点数和浮点数</h3><p>定点数即小数点的位置固定不变的数，又可以细分为定点整数和定点小数。但是定点数所能表示的数值范围比较小，在运算中很容易因为结果超出范围而溢出，因此我们需要引入能表示更大范围的浮点数。<br>正如一个十进制数<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>83.125</mn></mrow><annotation encoding="application/x-tex">83.125</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">83.125</span></span></span></span>既可以写作<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>10</mn><mn>3</mn></msup><mo>×</mo><mn>0.083125</mn></mrow><annotation encoding="application/x-tex">10^3\times 0.083125</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0.083125</span></span></span></span>也可以写作<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>10</mn><mn>4</mn></msup><mo>×</mo><mn>0.0083125</mn></mrow><annotation encoding="application/x-tex">10^4\times 0.0083125</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0.0083125</span></span></span></span>，一个二进制数<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1011.10101</mn></mrow><annotation encoding="application/x-tex">1011.10101</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1011.10101</span></span></span></span>也既可以写作<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>4</mn></msup><mo>×</mo><mn>0.101110101</mn></mrow><annotation encoding="application/x-tex">2^4\times 0.101110101</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0.101110101</span></span></span></span>也可以写作<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>5</mn></msup><mo>×</mo><mn>0.0101110101</mn></mrow><annotation encoding="application/x-tex">2^5\times 0.0101110101</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0.0101110101</span></span></span></span>。也就是说，一个二进制数N可以用一种更一般的形式来表示：</p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>N</mi><mo>=</mo><msup><mn>2</mn><mi>E</mi></msup><mo>×</mo><mi>F</mi></mrow><annotation encoding="application/x-tex">N=2^E\times F</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.9747em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05764em;">E</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span></span></span></span></span></p><p>其中，E被称之为阶码，它与浮点数能够表示的范围有关，F被称之为尾数，它与浮点数能够表示的精度有关（<strong>尾数一定是一个纯小数</strong>，即其整数部分一定为0）。<br>用阶码和尾数来表示的数即为浮点数，这种表示数的方法也被称之为浮点表示法，显然我们可以用多个浮点形式表示同一个数。<br>此外，为了利用尾数来表示更多的有效数字，我们通常采用规格化浮点数，即将尾数的绝对值控制在区间[0.5, 1]。</p><h3 id="Ⅱ-真题赏析">Ⅱ 真题赏析</h3><div class="center"><style>.vurtrjrqblst{}</style><img src="/2025/04/20/note24/note24_pic05.png" class="vurtrjrqblst"></div><p>在两个浮点数相加时，需要先对阶，即将阶码保持一致。假如现在需要对<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>10</mn><mn>4</mn></msup><mo>×</mo><mn>0.1234</mn></mrow><annotation encoding="application/x-tex">10^4\times 0.1234</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0.1234</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>10</mn><mn>2</mn></msup><mo>×</mo><mn>0.1234</mn></mrow><annotation encoding="application/x-tex">10^2\times 0.1234</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0.1234</span></span></span></span>加和，如果我们将大阶向小阶对齐的话，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>10</mn><mn>4</mn></msup><mo>×</mo><mn>0.1234</mn></mrow><annotation encoding="application/x-tex">10^4\times 0.1234</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0.1234</span></span></span></span>(int(1234))需要对齐为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>10</mn><mn>2</mn></msup><mo>×</mo><mn>0.3400</mn></mrow><annotation encoding="application/x-tex">10^2\times 0.3400</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0.3400</span></span></span></span>(int(34))，<strong>这样一来就损失了1200</strong>；而如果我们将小阶向大阶对齐的话，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>10</mn><mn>2</mn></msup><mo>×</mo><mn>0.1234</mn></mrow><annotation encoding="application/x-tex">10^2\times 0.1234</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0.1234</span></span></span></span>(int(12.34))就需要更改为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>10</mn><mn>4</mn></msup><mo>×</mo><mn>0.001234</mn></mrow><annotation encoding="application/x-tex">10^4\times 0.001234</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0.001234</span></span></span></span>(int(0.1234))，<strong>这样一来就损失了12.2166</strong>。<br>两相比较，显然需要采用的是小阶向大阶对齐，并将小数点左移，即尾数右移。</p><h2 id="三、校验码">三、校验码</h2><p>计算机系统在运行时通常会采用校验码的方法来确保数据在传送过程中正确无误，常用的校验码有以下三种：</p><h3 id="Ⅰ-奇偶校验码">Ⅰ 奇偶校验码</h3><p>奇偶校验码（Parity Codes）通过在编码中增加一位校验位来使编码中1的个数为奇数（奇校验）或者为偶数（偶校验），从而使码距变为2。</p><blockquote><p>所谓码距,是指一个编码系统中任意两个合法编码之间至少有多少个二进制位不同。例如，4位 8421 码的码距为 1，在传输过程中，该代码的一位或多位发生错误，都将变成另外一个合法的编码，因此这种代码无检错能力。码距越长，一种编码的检验和纠错能力就越长。</p></blockquote><p>进行奇校验时，奇偶检验码只能检测代码中奇数位出错的编码，但不能发现偶数维出错的情况。</p><h3 id="Ⅱ-海明码">Ⅱ 海明码</h3><p>海明码（Hamming Code）是一种利用奇偶性的检验方法，其构成方法是在数据位之间的特定位置上插入k个校验位，通过扩大码距来实现检错和纠错（海明码的码距为3，码距大于等于3之后编码开始具备纠错能力）。<br>设数据位是n位，校验位是k位，则n和k必须满足以下关系：</p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msup><mn>2</mn><mi>k</mi></msup><mo>−</mo><mn>1</mn><mo>≥</mo><mi>n</mi><mo>+</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">2^k-1\ge n+k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9824em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8991em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span></span></p><h3 id="Ⅲ-循环冗余校验码">Ⅲ 循环冗余校验码</h3><p>循环冗余校验码（Cyclic Redundancy Check，CRC）为k个数据位产生r个校验位来进行编码，其总长度为k+r，CRC的代码格式如下图所示：</p><div class="center"><style>.lqidwxndeqxw{}</style><img src="/2025/04/20/note24/note24_pic09.png" class="lqidwxndeqxw"></div><p>在CRC当中，校验码是由信息码产生的，校验码位数越多，该代码的校验能力就越强。<br>此外，在求CRC编码时，采用的是按位的模2运算。</p><h3 id="Ⅳ-真题赏析-2">Ⅳ 真题赏析</h3><div class="center"><style>.tbezfxkltdws{}</style><img src="/2025/04/20/note24/note24_pic10.png" class="tbezfxkltdws"></div><p><strong>A</strong>，海明码是一种利用奇偶性来检错和纠错的编码。C选项，CRC不具有纠错能力，错误。</p><hr><div class="center" ><style>.iijynzmpjett{}</style><img src="/2025/04/20/note24/note24_pic11.png" class="iijynzmpjett"></div><p><strong>C</strong>，奇偶校验码是通过判断编码中1的个数是否满足奇校验或者偶校验的一种校验方法。当采用奇校验时，其要求编码中所有数据位中1的个数之和为一个奇数，因此只有<code>奇数个</code>位出错时才可以检验到错误，如果是偶数个的话错误会相互抵消。此外，奇偶校验码只能检测到存在错误而不能定位错误所在，因此不具备纠错能力。</p><h2 id="四、计算机指令系统">四、计算机指令系统</h2><h3 id="Ⅰ-CISC和RISC">Ⅰ CISC和RISC</h3><p>CISC和RISC是指令集发展的两种途径。</p><div class="center"><style>.vrxvvmjqivgo{}</style><img src="/2025/04/20/note24/note24_pic13.png" class="vrxvvmjqivgo"></div><h3 id="Ⅱ-指令流水线">Ⅱ 指令流水线</h3><p>指令流水线即模仿工业生产过程中的流水线，使得一个指令的子过程能够在专用模块上有效地并发工作：</p><div class="center"><style>.dufyftpamrwj{}</style><img src="/2025/04/20/note24/note24_pic14.png" class="dufyftpamrwj"></div><p>以下比较重要的几个概念：</p><ol><li>吞吐率是指单位时间内流水线处理机流出的结果数，如果流水线的子过程所用时间不一样，吞吐率<code>p</code>为最长子过程的倒数，即为：</li></ol><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>p</mi><mtext> </mtext><mtext> </mtext><mo>=</mo><mtext> </mtext><mtext> </mtext><mn>1</mn><mi mathvariant="normal">/</mi><mi>max</mi><mo>⁡</mo><mrow><mo fence="true">{</mo><mo>△</mo><msub><mi>t</mi><mn>1</mn></msub><mo separator="true">,</mo><mo>△</mo><msub><mi>t</mi><mn>2</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><mo>△</mo><msub><mi>t</mi><mi>m</mi></msub><mo fence="true">}</mo></mrow></mrow><annotation encoding="application/x-tex">p\,\,=\,\,1/\max \left\{ \bigtriangleup t_1,\bigtriangleup t_2,...,\bigtriangleup t_m \right\} </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">p</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1/</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">max</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">{</span><span class="mord">△</span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">△</span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">...</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">△</span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;">}</span></span></span></span></span></span></p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mo>=</mo><mtext> </mtext><mi>n</mi><mi mathvariant="normal">/</mi><mtext>执行1条指令的时间</mtext><mo>+</mo><mrow><mo fence="true">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo fence="true">)</mo></mrow><mo>×</mo><mtext>最长时间段</mtext></mrow><annotation encoding="application/x-tex">=\ n/\text{执行1条指令的时间}+\left( n-1 \right) \times \text{最长时间段}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">=</span><span class="mspace"> </span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mord">/</span><span class="mord text"><span class="mord cjk_fallback">执行</span><span class="mord">1</span><span class="mord cjk_fallback">条指令的时间</span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">1</span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord text"><span class="mord cjk_fallback">最长时间段</span></span></span></span></span></span></p><p>其中n是连续输入指令的个数，显然最大吞吐率取决于流水线中最慢一段所需的时间。<br>2. 流水线从起始状态到达最大吞吐率需要一定时间，这段时间即为建立时间。<br>3. 加速比也是衡量一条流水线性能的关键指标，其为<strong>非流水线系统的执行时间和流水线系统执行时间的比</strong>。</p><h3 id="Ⅲ-真题赏析">Ⅲ 真题赏析</h3><div class="center"><style>.sggqtekmltht{}</style><img src="/2025/04/20/note24/note24_pic15.png" class="sggqtekmltht"></div><p><strong>D</strong>，流水线中处理n条连续命令的时间即为(执行1条指令的时间)+(n-1)*(最长时间段)</p><h2 id="五、计算机存储系统">五、计算机存储系统</h2><div class="center"><style>.fiopewponghn{}</style><img src="/2025/04/20/note24/note24_pic16.png" class="fiopewponghn"></div><h3 id="Ⅰ-存储器的分类">Ⅰ 存储器的分类</h3><ol><li>按存储器所处位置分类：<ol><li>内存：也称之为主存，用来存放机器当前运行所需的程序和数据，以便向CPU提供信息，容量小、速度快。</li><li>外存：也称之为辅存，用来存放当下不参与运行的大量信息，而在需要时调入内存。</li></ol></li><li>按存储器的工作方式分类：<ol><li>读/写存储器（Read/Write Memory）：RAM的一种，既能读取数据也能存入数据。</li><li>只读存储器：<ol><li>固定只读存储器（Read Only Memory, ROM）：在出厂时就被商家写好了数据，其内容只可读取不可改变。</li><li>可编程的只读存储器（Programmable Read Only Memory, PROM）：其中的内容可以由用户一次性地写入，随后不能再更改。</li><li>可擦除可编程的只读存储器（Erasable Programmable Read Only Memory, EPROM）：其中的内容既可以读出，也可以由用户写入，写入后还可以再修改。擦除的方式是使用紫外线照射。</li><li>电擦除可编程的只读存储器（Electrically Erasable Programmable Read Only Memory, EEPROM）：和EPROM类似，只是擦除方式为电擦除。</li><li>闪速存储器（Flash Memory）：即闪存，其特性介于EPROM和EEPROM之间，类似于EEPROM，使用电信号进行信息擦除。以一整块为单位，闪存可以在数秒之内删除，速度远快于EPROM。</li></ol></li></ol></li><li>按寻址方式分类：<ol><li>随机存储器（Random Access Memory, RAM）：可对任何存储单元存入或读取数据，访问任何一个存储单元所需的时间都是相同的。</li><li>顺序存储器（Sequentially Addressed Memory, SAM）：访问数据所需要的时间与数据所在的存储位置有关。</li><li>直接存储器（Direct Addressed Memory, DAM）：介于随机存取和顺序存取之间的一种寻址方式。例如磁盘就是一个直接存储器，它对于每一个磁道的寻址是随机的，但在一个磁道当中的寻址是顺序的。</li></ol></li></ol><h3 id="Ⅱ-相联存储器">Ⅱ 相联存储器</h3><p>相联存储器是一种按内容访问的存储器，它可以将数据的某一部分作为关键字写入，特别适合于信息的检索和更新。</p><h3 id="Ⅲ-高速缓存-Cache">Ⅲ 高速缓存 Cache</h3><div class="center"><style>.zcodfcbswfcx{}</style><img src="/2025/04/20/note24/note24_pic20.png" class="zcodfcbswfcx"></div><p>Cache位于CPU和主存之间，用来存放当前最活跃的程序和数据。Cache也分为控制器和存储器两部分，控制部分会判断CPU想要访问的内容是否在Cache存储器中，存在即为命中，否则为没有命中。命中时直接对Cache存储器寻址，反之则要按照替换原则决定主存的信息将要放在Cache中的哪一块里（没有命中就说明CPU想要的内容Cache当中没有，那么Cache就需要去拷贝主存的部分信息，随后再让CPU来获取）。</p><p>而常见的替换算法有以下几种：</p><ol><li>随机替换算法：用随机数发生器产生一个要替换的块号，将该块替换出去。</li><li>先进先出算法：将最先进入的Cache块替换出去。</li><li>近期最少使用算法：将近期最少使用的Cache块替换出去。</li><li>优化替换算法：这种算法要求先执行一次程序来统计Cache的替换情况，随后据此在第二次执行该程序时选择最有效的方式。</li></ol><p>一个好的替换算法可以使Cache获得尽可能高的命中率。</p><div class="center"><style>.abpsfmrtkrvh{}</style><img src="/2025/04/20/note24/note24_pic21.png" class="abpsfmrtkrvh"></div><p>此外，正如前文所述，CPU在调取信息时送出的是主存单元的地址，但是首先会从Cache中读写信息，这就要求主存地址和Cache地址之间能够有效转换，我们将这种转换称之为地址映像，具体有如下几种方法：</p><ol><li>直接映像：主存的块与Cache的块的对应关系是固定的。</li></ol><div class="center"><style>.levbvlvcqfwj{}</style><img src="/2025/04/20/note24/note24_pic22.png" class="levbvlvcqfwj"></div><p>其优点为地址变换很简单，但具有灵活性差的缺点，比如不同区号中块号相同的块无法同时调入Cache中，将造成空间浪费。</p><ol start="2"><li>全相联映像：主存的任一块可以调入Cache中的任何一个块的空间中。</li></ol><div class="center"><style>.edsyvyqruyfn{}</style><img src="/2025/04/20/note24/note24_pic23.png" class="edsyvyqruyfn"></div><p>这种映像的主要优点是主存的块调入Cache的位置不受限制，十分灵活，而主要缺点是无法从主存块号直接获得Cache的块号，变换更加复杂，速度变慢。</p><h3 id="Ⅳ-真题赏析-3">Ⅳ 真题赏析</h3><div class="center"><style>.xcycwqflvocf{}</style><img src="/2025/04/20/note24/note24_pic17.png" class="xcycwqflvocf"></div><p><strong>A</strong>，虚拟存储器是一种用于扩展物理内存容量的核心技术，它一般采用主存-辅存两级结构来实现。这是由于主存（DRAM）昂贵且容量有限，因此可以仅将活跃数据存放在高速且容量小的主存当中，而将非活跃数据暂存到低速但容量大的辅存当中。这样就可以抽象出一块比物理内存大得多的逻辑空间。</p><hr><div class="center"><style>.gpccsvlxcunm{}</style><img src="/2025/04/20/note24/note24_pic18.png" class="gpccsvlxcunm"></div><p><strong>C</strong>，内存中保存的信息在断电后会被清除，属于易失性存储器，而闪存则是一种非易失性存储器，两者不可互换。</p><hr><div class="center"><style>.nhomvrkcuogu{}</style><img src="/2025/04/20/note24/note24_pic19.png" class="nhomvrkcuogu"></div><p><strong>B</strong>，CD都属于非易失性存储器，直接排除。A选项SRAM是静态RAM，无需刷新；B选项DRAM是动态RAM，它利用电容电荷存储数据，电荷会自然泄露，因此需要每隔几毫秒刷新一次。</p><hr><div class="center"><style>.kbqvcgqxbeko{}</style><img src="/2025/04/20/note24/note24_pic24.png" class="kbqvcgqxbeko"></div><p><strong>A</strong>，组相联映像是全相联映像和直接映像的一种折中方案，由于全相联映像中内存块号和Cache块号没有了一一对应的关系，冲突次数显著降低。发生块冲突次数：直接映像&gt;组相联映像&gt;全相联映像。</p><hr><div class="center"><style>.fnjnoytqtzep{}</style><img src="/2025/04/20/note24/note24_pic25.png" class="fnjnoytqtzep"></div><p><strong>A</strong>，地址映像由专门的硬件自动完成。</p><h2 id="六、输入-输出技术">六、输入/输出技术</h2><p>一般有以下三种I/O控制方式：</p><h3 id="Ⅰ-程序查询方式">Ⅰ 程序查询方式</h3><p>这种方式下CPU会执行程序逐一对外设进行查询，判断它们是否做好了接收或者发送数据的准备，发现哪个设备就绪就对该外设服务。这种方式有如下两个缺点：</p><ol><li>严重降低了CPU的效率。</li><li>对外部突发事件无法做出实时响应。</li></ol><h3 id="Ⅱ-中断驱动方式">Ⅱ 中断驱动方式</h3><p>由于程序查询方式会严重浪费CPU的算力，使其一直等待IO系统的结果，那么就可以利用中断方式完成数据的I/O过程。这种方式下CPU不会等待IO系统的结果，而是直接转身去处理其它任务，而当IO系统就绪时，就会向CPU发送一个中断请求。CPU在接收到这个中断请求之后，就会保存当下正在执行的现场，转入IO系统完成数据交换，然后再返回刚才的现场继续完成执行。</p><p>关于中断有以下两个概念：</p><ol><li>中断向量：中断向量提供了中断服务程序的入口地址。</li></ol><div class="center"><style>.zjsespbbfbgv{}</style><img src="/2025/04/20/note24/note24_pic26.png" class="zjsespbbfbgv"></div><ol start="2"><li>中断响应时间：即从发送中断请求开始到进入中断服务程序所需的时间。</li></ol><h3 id="Ⅲ-直接存储器存取方式">Ⅲ 直接存储器存取方式</h3><p>在上文提到的控制方式中，无论是查询方式传送还是中断方式传送，都需要由CPU执行程序来实现，这就限制了数据的传送速度。<br>而直接内存存取（Direct Memory Access, DMA）是指数据在内存和I/O设备间直接成块传送，不需要CPU的任何干涉。除了在开始和结束时需要CPU进行处理之外，其余操作都由DMA硬件来完成，在此期间CPU可进行其它任务。</p><h3 id="Ⅳ-真题赏析-4">Ⅳ 真题赏析</h3><div class="center"><style>.lyysyztiihph{}</style><img src="/2025/04/20/note24/note24_pic27.png" class="lyysyztiihph"></div><p><strong>A</strong>，C选项中由于DMA方式采用的是以块为基本单位的数据传送，其传输数据的速度是要大于程序中断方式的。</p><h2 id="七、计算机安全">七、计算机安全</h2><h3 id="Ⅰ-加密技术">Ⅰ 加密技术</h3><p>根据具体实现的不同，可以将加密技术分为对称加密和非对称加密两类：</p><ol><li>对称加密技术：其特点是文件加密和解密时使用相同的密钥。由于只有一把密钥，该技术在密钥分发上是有缺陷的。但其加密解密速度很快，适合用来加密大量明文数据。</li><li>非对称加密技术：和对称加密算法不同，非对称加密算法需要两个密钥：公开密钥(Publickey)和私有密钥(Privatekey)。这种技术进行加密的基本过程为：甲方生成一对密钥并将其中的一把作为公钥公开，得到该公钥的乙方使用该密钥加密后将密文发给甲方，甲方再使用自己的私钥对其进行解密。由于非对称加密技术避免了密钥的交换，因此其克服了密钥分发上的缺陷，只是会降低加密解密速度。</li></ol><div class="center"><style>.irkenbgcnhaw{}</style><img src="/2025/04/20/note24/note24_pic28.png" class="irkenbgcnhaw"></div><h3 id="Ⅱ-认证技术">Ⅱ 认证技术</h3><p>认证技术则主要用来验证用户、设备或数据的真实身份​​，确保通信双方可信，防止冒充或篡改。常见的认证技术主要以下几种：</p><ol><li>摘要：将想要发送的明文经过Hash算法后得到摘要，将摘要和密文一同发送。接收方通过验证解密后得到的明文进行Hash算法的结果和摘要是否一致来进行认证。</li><li>数字签名：发送方使用私钥将摘要加密后得到签名，随后将签名附送。其余步骤和摘要认证类似。</li><li>数字证书：数字证书由权威机构（CA）发放，用户需要将自己的个人信息和公钥交给CA，CA随后使用自己的私钥对数字证书签名。接收者可以使用CA的公钥解密数字证书，进而得到用户的公钥。</li></ol><h3 id="Ⅲ-真题赏析-2">Ⅲ 真题赏析</h3><div class="center"><style>.awckmcuklpbr{}</style><img src="/2025/04/20/note24/note24_pic29.png" class="awckmcuklpbr"></div><p><strong>AD</strong></p><blockquote><p>甲方生成一对密钥并将其中的一把作为公钥公开，得到该公钥的乙方使用该密钥加密后将密文发给甲方，甲方再使用自己的私钥对其进行解密。</p></blockquote><p>私钥用于解密而公钥用于加密，66题BD排除，67题AC排除。</p><blockquote><p>发送方使用私钥将摘要加密后得到签名。</p></blockquote><p>私钥用于签名，66题C排除，67题B排除。</p><hr><div class="center"><style>.ldrgimyoryjf{}</style><img src="/2025/04/20/note24/note24_pic30.png" class="ldrgimyoryjf"></div><p><strong>A</strong>，网站的真伪就在于数字证书的真伪，数字证书的真伪就在于CA的真伪，那么就可以通过CA的签名来判断CA的真伪。</p><hr><div class="center"><style>.yppdwnejcsih{}</style><img src="/2025/04/20/note24/note24_pic31.png" class="yppdwnejcsih"></div><p><strong>A</strong>，PKI体制即为公钥体制（PublicKey Infrastructure），在此体制下维护数字证书肯定是依靠公共性的机构，即CA。而正如上文所述，CA是使用自己的私钥对数字证书签名的。</p><hr><div class="center"><style>.ccnnihhyidfs{}</style><img src="/2025/04/20/note24/note24_pic32.png" class="ccnnihhyidfs"></div><p><strong>D</strong>，私钥是无论如何都不能互换的，AC选项排除。A、B互信的前提应该是I1、I2互信，即I1、I2能够交换公钥。</p><h2 id="八、计算机可靠性">八、计算机可靠性</h2><p>计算机系统十分复杂，若要分析其可靠性，可将这个大系统分割成若干个子系统来简化分析过程，常见的系统可靠性数学模型有以下几种：</p><h3 id="Ⅰ-串联系统">Ⅰ 串联系统</h3><div class="center"><style>.wpjuoelzxsuz{}</style><img src="/2025/04/20/note24/note24_pic33.png" class="wpjuoelzxsuz"></div><p>该系统当且仅当所有子系统都能正常工作时系统才能正常工作，其可靠性R为：</p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>R</mi><mo>=</mo><msub><mi>R</mi><mn>1</mn></msub><msub><mi>R</mi><mn>2</mn></msub><mo>⋅</mo><mo>⋅</mo><mo>⋅</mo><msub><mi>R</mi><mi>N</mi></msub></mrow><annotation encoding="application/x-tex">R=R_1R_2\cdot \cdot \cdot R_N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4445em;"></span><span class="mord">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p><h3 id="Ⅱ-并联系统">Ⅱ 并联系统</h3><div class="center"><style>.ipemshgxcnjg{}</style><img src="/2025/04/20/note24/note24_pic34.png" class="ipemshgxcnjg"></div><p>假如一个子系统能够正常工作，整个系统就能正常工作，其可靠性R为：</p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>R</mi><mo>=</mo><mn>1</mn><mo>−</mo><mrow><mo fence="true">(</mo><mn>1</mn><mo>−</mo><msub><mi>R</mi><mn>1</mn></msub><mo fence="true">)</mo></mrow><mrow><mo fence="true">(</mo><mn>1</mn><mo>−</mo><msub><mi>R</mi><mn>2</mn></msub><mo fence="true">)</mo></mrow><mo>⋅</mo><mo>⋅</mo><mo>⋅</mo><mrow><mo fence="true">(</mo><mn>1</mn><mo>−</mo><msub><mi>R</mi><mi>N</mi></msub><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">R=1-\left( 1-R_1 \right) \left( 1-R_2 \right) \cdot \cdot \cdot \left( 1-R_N \right) </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4445em;"></span><span class="mord">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;">)</span></span></span></span></span></span></p>]]></content>
    
    
    <summary type="html">软考中级备考笔记</summary>
    
    
    
    <category term="软考" scheme="http://example.com/categories/%E8%BD%AF%E8%80%83/"/>
    
    <category term="软件设计师" scheme="http://example.com/categories/%E8%BD%AF%E8%80%83/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/"/>
    
    <category term="上午题" scheme="http://example.com/categories/%E8%BD%AF%E8%80%83/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/%E4%B8%8A%E5%8D%88%E9%A2%98/"/>
    
    
    <category term="软考" scheme="http://example.com/tags/%E8%BD%AF%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>优先队列的应用</title>
    <link href="http://example.com/2025/04/11/note21/"/>
    <id>http://example.com/2025/04/11/note21/</id>
    <published>2025-04-11T12:33:54.000Z</published>
    <updated>2025-04-11T13:14:09.205Z</updated>
    
    <content type="html"><![CDATA[<style>.center {  width: auto;  display: table;  margin-left: auto;  margin-right: auto;}</style><h1>优先队列的应用</h1><p>优先队列是一种基于堆实现的数据结构，它使得队列中最高优先级的元素总是排在堆顶（优先级或大或小，与大顶堆或小顶堆有关）。</p><div class="center"><style>.aodvkykdssio{}</style><img src="/2025/04/11/note21/note21_pic01.png" class="aodvkykdssio"></div><p>在Python中可以直接使用<code>heapq</code>库来使用优先队列，主要有以下几个用法:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> heapq<br><span class="hljs-keyword">import</span> sys<br><br>heap = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, sys.stdin.readline().strip().split()))<br><br>heap = heapq.heapify(heap)      <span class="hljs-comment"># 将一个朴素队列堆化</span><br>min_num = heapq.heappop(heap)   <span class="hljs-comment"># 弹出堆中的最小元素（该库默认定义为小顶堆）</span><br><br>heapq.heappush(heap, new_num)   <span class="hljs-comment"># 插入一个新的数</span><br><br>n = <span class="hljs-number">3</span><br>heap = [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>]<br><span class="hljs-built_in">print</span>(heapq.nsmallest(n, heap)) <span class="hljs-comment"># 输出堆中最小的n个元素</span><br><span class="hljs-built_in">print</span>(heapq.nlargest(n, heap))  <span class="hljs-comment"># 输出堆中最大的n个元素</span><br></code></pre></td></tr></table></figure><p>最大堆可以通过将队列全部取相反数实现，不再赘述。</p><h2 id="P1090-NOIP-2004-提高组-合并果子"><a href="https://www.luogu.com.cn/problem/P1090">P1090 [NOIP 2004 提高组] 合并果子</a></h2><h3 id="题目描述">题目描述</h3><p>在一个果园里，多多已经将所有的果子打了下来，而且按果子的不同种类分成了不同的堆。多多决定把所有的果子合成一堆。</p><p>每一次合并，多多可以把两堆果子合并到一起，消耗的体力等于两堆果子的重量之和。可以看出，所有的果子经过 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 次合并之后， 就只剩下一堆了。多多在合并果子时总共消耗的体力等于每次合并所耗体力之和。</p><p>因为还要花大力气把这些果子搬回家，所以多多在合并果子时要尽可能地节省体力。假定每个果子重量都为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> ，并且已知果子的种类 数和每种果子的数目，你的任务是设计出合并的次序方案，使多多耗费的体力最少，并输出这个最小的体力耗费值。</p><p>例如有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>3</mn></mrow><annotation encoding="application/x-tex">3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">3</span></span></span></span> 种果子，数目依次为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> ， <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span> ， <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>9</mn></mrow><annotation encoding="application/x-tex">9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">9</span></span></span></span> 。可以先将 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 、 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span> 堆合并，新堆数目为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>3</mn></mrow><annotation encoding="application/x-tex">3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">3</span></span></span></span> ，耗费体力为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>3</mn></mrow><annotation encoding="application/x-tex">3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">3</span></span></span></span> 。接着，将新堆与原先的第三堆合并，又得到新的堆，数目为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>12</mn></mrow><annotation encoding="application/x-tex">12</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">12</span></span></span></span> ，耗费体力为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>12</mn></mrow><annotation encoding="application/x-tex">12</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">12</span></span></span></span> 。所以多多总共耗费体力 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>=</mo><mn>3</mn><mo>+</mo><mn>12</mn><mo>=</mo><mn>15</mn></mrow><annotation encoding="application/x-tex">=3+12=15</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">12</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">15</span></span></span></span> 。可以证明 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>15</mn></mrow><annotation encoding="application/x-tex">15</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">15</span></span></span></span> 为最小的体力耗费值。</p><h3 id="输入格式">输入格式</h3><p>共两行。<br>第一行是一个整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo stretchy="false">(</mo><mn>1</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>10000</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">n(1\leq n\leq 10000)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">10000</span><span class="mclose">)</span></span></span></span> ，表示果子的种类数。</p><p>第二行包含 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 个整数，用空格分隔，第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 个整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub><mo stretchy="false">(</mo><mn>1</mn><mo>≤</mo><msub><mi>a</mi><mi>i</mi></msub><mo>≤</mo><mn>20000</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">a_i(1\leq a_i\leq 20000)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.786em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">20000</span><span class="mclose">)</span></span></span></span> 是第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 种果子的数目。</p><h3 id="输出格式">输出格式</h3><p>一个整数，也就是最小的体力耗费值。输入数据保证这个值小于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>31</mn></msup></mrow><annotation encoding="application/x-tex">2^{31}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">31</span></span></span></span></span></span></span></span></span></span></span></span> 。</p><h3 id="输入输出样例-1">输入输出样例 #1</h3><h4 id="输入-1">输入 #1</h4><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs txt">3 <br>1 2 9<br></code></pre></td></tr></table></figure><h4 id="输出-1">输出 #1</h4><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs txt">15<br></code></pre></td></tr></table></figure><h3 id="说明-提示">说明/提示</h3><p>对于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>30</mn><mi mathvariant="normal">%</mi></mrow><annotation encoding="application/x-tex">30\%</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8056em;vertical-align:-0.0556em;"></span><span class="mord">30%</span></span></span></span> 的数据，保证有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>≤</mo><mn>1000</mn></mrow><annotation encoding="application/x-tex">n \le 1000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1000</span></span></span></span>：</p><p>对于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>50</mn><mi mathvariant="normal">%</mi></mrow><annotation encoding="application/x-tex">50\%</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8056em;vertical-align:-0.0556em;"></span><span class="mord">50%</span></span></span></span> 的数据，保证有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>≤</mo><mn>5000</mn></mrow><annotation encoding="application/x-tex">n \le 5000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">5000</span></span></span></span>；</p><p>对于全部的数据，保证有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>≤</mo><mn>10000</mn></mrow><annotation encoding="application/x-tex">n \le 10000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">10000</span></span></span></span>。</p><h3 id="解决方案">解决方案</h3><p>直接逐个弹出最小的两个元素，并将这两个元素的和再插入回堆中即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> heapq<br><span class="hljs-keyword">import</span> sys<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    n = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>())<br>    heap = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, sys.stdin.readline().strip().split()))<br><br>    heapq.heapify(heap)<br><br>    ans = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(heap) &gt; <span class="hljs-number">1</span>:<br>        pop_num1 = heapq.heappop(heap)<br>        pop_num2 = heapq.heappop(heap)<br><br>        push_num = pop_num1 + pop_num2<br>        ans += push_num<br><br>        heapq.heappush(heap, push_num)<br>        <br>    <span class="hljs-built_in">print</span>(ans)<br>    <br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    main()<br></code></pre></td></tr></table></figure><p>Bingo!</p><div class="center"><style>.ypllkvebchup{}</style><img src="/2025/04/11/note21/note21_pic02.png" class="ypllkvebchup"></div><h1>这里留个尾巴，等主播打完蓝桥杯回来更新P8755</h1>]]></content>
    
    
    <summary type="html">以洛谷P1090和P8755为例</summary>
    
    
    
    <category term="算法相关" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3/"/>
    
    <category term="堆" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3/%E5%A0%86/"/>
    
    
    <category term="洛谷" scheme="http://example.com/tags/%E6%B4%9B%E8%B0%B7/"/>
    
    <category term="蓝桥杯" scheme="http://example.com/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"/>
    
    <category term="堆" scheme="http://example.com/tags/%E5%A0%86/"/>
    
    <category term="优先队列" scheme="http://example.com/tags/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
</feed>
